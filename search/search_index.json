{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Home","text":""},{"location":"#jetpack-android-starter","title":"\ud83d\ude80 Jetpack Android Starter","text":"<p>A robust, production-ready template for modern Android development that takes the pain out of setting up a new project. Built on the foundation of Now In Android's architecture, this template provides a comprehensive starting point for both new and experienced Android developers.</p> <p>\"Android Development is Easy until You Rotate the Device\"</p> <p></p>"},{"location":"#apps-built-with-this-template","title":"\ud83d\udcf1 Apps Built With This Template","text":"<p>Check out apps built with this template here.</p> <p></p>"},{"location":"#why-this-template","title":"\u2603\ufe0f Why This Template?","text":"<ul> <li>Production-Ready Authentication: Firebase authentication with Google Sign-In and   email/password</li> <li>Clean Architecture: Clear separation of concerns with a modular, scalable architecture</li> <li>Modern Tech Stack: Latest Android development tools including Jetpack Compose</li> <li>Type-Safe Navigation: Fully typed navigation using Kotlin serialization</li> <li>Robust Data Management: Repository pattern with Room and DataStore</li> <li>Firebase Integration: Auth, Firestore, Analytics, and Crashlytics</li> <li>Background Sync: Data synchronization using WorkManager</li> <li>Multilingual Support: Runtime localization update with support for RTL languages</li> <li>CI/CD: Automated build, release, and deployment with GitHub Actions</li> </ul>"},{"location":"#technical-stack","title":"\ud83d\udcc2 Technical Stack","text":""},{"location":"#core-libraries","title":"\ud83d\udcbe Core Libraries","text":"<ul> <li>UI   : Jetpack Compose, Material3</li> <li>DI: Dagger Hilt</li> <li>Async   : Kotlin Coroutines &amp; Flow</li> <li>Network   : Retrofit, OkHttp</li> <li>Storage   : Room DB, DataStore</li> <li>Firebase   : Auth, Firestore, Analytics, Performance</li> <li>Others   : WorkManager, Coil, Timber, Lottie</li> </ul>"},{"location":"#build-tools","title":"\ud83c\udfd7\ufe0f Build &amp; Tools","text":"<ul> <li>Kotlin 2.0</li> <li>Gradle 8.11.1   with Version Catalogs</li> <li>Java 21</li> <li>Custom Gradle Convention Plugins</li> <li>Dokka   and MkDocs Material for documentation</li> <li>ktlint and Spotless   for code formatting</li> </ul>"},{"location":"#documentation","title":"\ud83d\udcd6 Documentation","text":""},{"location":"#full-documentation","title":"\ud83d\udcda Full Documentation","text":""},{"location":"#getting-started","title":"\ud83c\udfaf Getting Started","text":"<ul> <li>Quick Start Guide</li> <li>Firebase Setup</li> <li>Dependency Management</li> </ul>"},{"location":"#architecture-design","title":"\ud83c\udfdb\ufe0f Architecture &amp; Design","text":"<ul> <li>Architecture Overview</li> <li>Design Philosophy</li> <li>Adding New Features</li> </ul>"},{"location":"#development-tools","title":"\ud83d\udea7 Development Tools","text":"<ul> <li>Convention Plugins</li> <li>Code Style with Spotless</li> <li>Performance Optimization</li> <li>Useful Tips &amp; Tricks</li> </ul>"},{"location":"#deployment","title":"\u26a1 Deployment","text":"<ul> <li>GitHub CI/CD Setup</li> <li>Fastlane Configuration</li> </ul>"},{"location":"#api-reference","title":"\ud83d\udcda API Reference","text":"<p>Qatar University Machine Learning Group <p></p>"},{"location":"architecture/","title":"Architecture Overview","text":"<p>This project follows the official Android Architecture Guidelines with some pragmatic adaptations to keep the codebase simple and maintainable.</p>"},{"location":"architecture/#architectural-principles","title":"Architectural Principles","text":"<p>The architecture is built on several key principles:</p> <ol> <li>Separation of Concerns: Each component has its own responsibility</li> <li>Single Source of Truth: Data is managed in a single place</li> <li>Unidirectional Data Flow: Data flows in one direction, events flow in the opposite</li> <li>State-Based UI: UI is a reflection of the state</li> <li>Pragmatic Simplicity: Complex patterns are only added when necessary</li> </ol>"},{"location":"architecture/#core-layers","title":"Core Layers","text":"<p>The app uses a two-layer architecture:</p> <pre><code>graph TB\n    subgraph UI[\"UI Layer\"]\n        direction TB\n        Composable[\"Composables&lt;br/&gt;(Pure UI)\"]\n        ViewModel[\"ViewModels&lt;br/&gt;(State Management)\"]\n        ScreenData[\"Screen Data&lt;br/&gt;(Immutable State)\"]\n        UiState[\"UiState&amp;lt;T&amp;gt;&lt;br/&gt;(Wrapper)\"]\n        Composable -. observes .-&gt; UiState\n        ViewModel --&gt;|manages| UiState\n        UiState --&gt;|wraps| ScreenData\n    end\n\n    subgraph Data[\"Data Layer\"]\n        direction TB\n        Repository[\"Repositories&lt;br/&gt;(Single Source of Truth)\"]\n        LocalDS[\"Local Data Sources&lt;br/&gt;(Room, DataStore)\"]\n        NetworkDS[\"Network Data Sources&lt;br/&gt;(Retrofit, Firebase)\"]\n        Repository --&gt;|reads/writes| LocalDS\n        Repository --&gt;|fetches| NetworkDS\n        NetworkDS -. syncs .-&gt; LocalDS\n    end\n\n    subgraph DI[\"Dependency Injection\"]\n        Hilt[\"Hilt&lt;br/&gt;(Provides Dependencies)\"]\n    end\n\n    ViewModel --&gt;|calls| Repository\n    Hilt -. injects .-&gt; ViewModel\n    Hilt -. injects .-&gt; Repository</code></pre> <p>Simplified View:</p> <pre><code>graph TD\n    A[UI Layer] --&gt; B[Data Layer]</code></pre>"},{"location":"architecture/#ui-layer","title":"UI Layer","text":"<p>The UI layer follows MVVM pattern and consists of:</p> <ol> <li>Composables: Pure UI components built with Jetpack Compose</li> <li>ViewModels: Manage UI state and business logic</li> <li>Screen Data: Immutable data classes representing screen state</li> </ol> <p>Example UI Layer structure:</p> <pre><code>data class HomeScreenData(\n    val items: List&lt;Item&gt; = emptyList(),\n    // other UI state properties\n)\n\n@HiltViewModel\nclass HomeViewModel @Inject constructor(\n    private val repository: HomeRepository\n) : ViewModel() {\n    private val _uiState = MutableStateFlow(UiState(HomeScreenData()))\n    val uiState = _uiState.asStateFlow()\n}\n\n@Composable\nfun HomeScreen(\n    screenData: HomeScreenData,\n    onAction: (HomeAction) -&gt; Unit\n) {\n}\n</code></pre>"},{"location":"architecture/#data-layer","title":"Data Layer","text":"<p>The data layer handles data operations and consists of:</p> <ol> <li>Repositories: Single source of truth for data</li> <li>Data Sources: Interface with external systems (API, database, etc.)</li> <li>Models: Data representation classes</li> </ol> <p>Example Data Layer structure:</p> <pre><code>class HomeRepositoryImpl @Inject constructor(\n    private val localDataSource: LocalDataSource,\n    private val networkDataSource: NetworkDataSource\n) : HomeRepository {\n    override fun getData(): Flow&lt;List&lt;Data&gt;&gt; =\n        networkBoundResource(\n            query = { localDataSource.getData() },\n            fetch = { networkDataSource.getData() },\n            saveFetchResult = { localDataSource.saveData(it) }\n        )\n}\n</code></pre> <p>Note</p> <p>Unlike the official guidelines, this project intentionally omits the domain layer to reduce complexity. You can add a domain layer if your app requires complex business logic or needs to share logic between multiple ViewModels.</p>"},{"location":"architecture/#state-management","title":"State Management","text":"<p>The project uses a consistent state management pattern:</p> <ol> <li> <p>UiState Wrapper:</p> <pre><code>data class UiState&lt;T : Any&gt;(\n    val data: T,\n    val loading: Boolean = false,\n    val error: OneTimeEvent&lt;Throwable?&gt; = OneTimeEvent(null)\n)\n</code></pre> </li> <li> <p>State Updates:</p> <pre><code>// Regular state updates\n_uiState.updateState { copy(value = newValue) }\n\n// Async operations\n_uiState.updateStateWith {\n    repository.someAsyncOperation()\n}\n</code></pre> </li> </ol> <p>[!TIP] Kotlin Context Parameters: The <code>updateStateWith</code> and <code>updateWith</code> functions use Kotlin's context parameters feature (enabled via <code>-Xcontext-parameters</code> compiler flag) to automatically access the ViewModel's scope. You don't need to pass <code>viewModelScope</code> explicitly - it's injected via the <code>context(viewModel: ViewModel)</code> parameter.</p> <ol> <li> <p>State Display:</p> <pre><code>@Composable\nfun StatefulScreen(\n    state: UiState&lt;ScreenData&gt;,\n    onShowSnackbar: suspend (String, SnackbarAction, Throwable?) -&gt; Boolean\n) {\n    StatefulComposable(\n        state = state,\n        onShowSnackbar = onShowSnackbar\n    ) { screenData -&gt;\n        // UI Content\n    }\n}\n</code></pre> </li> </ol>"},{"location":"architecture/#dependency-injection","title":"Dependency Injection","text":"<p>The project uses Hilt for dependency injection:</p> <ul> <li>Modules: Organized by feature and core functionality</li> <li>Scoping: Primarily uses singleton scope for repositories and data sources</li> <li>Testing: Enables easy dependency replacement for testing</li> </ul>"},{"location":"architecture/#data-flow","title":"Data Flow","text":"<ol> <li>User Interaction \u2192 UI Events</li> <li>ViewModel \u2192 Business Logic</li> <li>Repository \u2192 Data Operations</li> <li>DataSource \u2192 External Systems</li> <li>Back to UI through StateFlow</li> </ol> <pre><code>graph LR\n    A[User Action] --&gt; B[ViewModel]\n    B --&gt; C[Repository]\n    C --&gt; D[Data Sources]\n    D --&gt; C\n    C --&gt; B\n    B --&gt; E[UI State]\n    E --&gt; F[UI]</code></pre>"},{"location":"architecture/#adding-a-domain-layer","title":"Adding a Domain Layer","text":"<p>If your app grows in complexity, you can add a domain layer:</p> <pre><code>class GetDataUseCase @Inject constructor(\n    private val repository: Repository\n) {\n    suspend operator fun invoke(params: Params): Result&lt;Data&gt; =\n        repository.getData(params)\n}\n</code></pre> <p>Tip</p> <p>Consider adding a domain layer when: - Multiple ViewModels share business logic - Business rules become complex - You need to transform data between layers</p>"},{"location":"architecture/#testing-strategy","title":"Testing Strategy","text":"<p>Note</p> <p>Testing infrastructure is planned but not yet implemented in this template.</p> <p>The architecture enables different types of tests:</p> <ol> <li>UI Tests: Test Composables in isolation</li> <li>ViewModel Tests: Test state management and business logic</li> <li>Repository Tests: Test data operations</li> <li>Integration Tests: Test multiple layers together</li> </ol>"},{"location":"architecture/#best-practices","title":"Best Practices","text":"<ol> <li>Keep Screen Data Simple: Only include what's needed for the UI</li> <li>Single Responsibility: Each class should have one clear purpose</li> <li>Error Handling: Use <code>Result</code> type for operations that can fail</li> <li>Coroutines: Use structured concurrency with proper scoping</li> <li>Immutable Data: Use data classes for state and models</li> </ol>"},{"location":"architecture/#integration-patterns","title":"Integration Patterns","text":"<p>Understanding how different architectural components work together is crucial for building features effectively. This section explains the key integration patterns in the template.</p>"},{"location":"architecture/#navigation-state-management-integration","title":"Navigation + State Management Integration","text":"<p>Navigation and state management work together to create a seamless user experience with proper state preservation.</p> <p>Pattern: Type-safe navigation with state restoration</p> <pre><code>// 1. Define navigation route with parameters\n@Serializable\ndata class ProfileRoute(val userId: String)\n\n// 2. ViewModel manages state\n@HiltViewModel\nclass ProfileViewModel @Inject constructor(\n    savedStateHandle: SavedStateHandle,\n    private val repository: UserRepository\n) : ViewModel() {\n    // Extract userId from navigation arguments\n    private val userId: String = savedStateHandle.toRoute&lt;ProfileRoute&gt;().userId\n\n    private val _uiState = MutableStateFlow(UiState(ProfileScreenData()))\n    val uiState = _uiState.asStateFlow()\n\n    init {\n        loadProfile()\n    }\n\n    private fun loadProfile() {\n        _uiState.updateStateWith {\n            repository.getUserProfile(userId)\n        }\n    }\n}\n\n// 3. Navigation integration in NavGraph\nfun NavGraphBuilder.profileScreen(\n    onShowSnackbar: suspend (String, SnackbarAction, Throwable?) -&gt; Boolean,\n    onNavigateBack: () -&gt; Unit\n) {\n    composable&lt;ProfileRoute&gt; { backStackEntry -&gt;\n        ProfileRoute(\n            onShowSnackbar = onShowSnackbar,\n            onNavigateBack = onNavigateBack\n        )\n    }\n}\n</code></pre> <p>Key Integration Points:</p> <ul> <li><code>SavedStateHandle</code> provides navigation arguments to ViewModel</li> <li><code>toRoute&lt;T&gt;()</code> converts type-safe route to data class</li> <li>State survives configuration changes automatically</li> <li>Back stack preservation handled by Navigation Compose</li> </ul> <p>Tip</p> <p>For detailed navigation patterns, see Navigation Deep Dive. For state management patterns, see State Management Guide.</p>"},{"location":"architecture/#firebase-data-layer-integration","title":"Firebase + Data Layer Integration","text":"<p>Firebase services integrate with the repository pattern to provide seamless authentication and cloud data access.</p> <p>Pattern: Firebase authentication flow with repository pattern</p> <pre><code>// 1. Firebase wrapper abstracts Firebase SDK\nclass FirebaseAuthWrapper @Inject constructor(\n    private val auth: FirebaseAuth\n) {\n    fun currentUserFlow(): Flow&lt;FirebaseUser?&gt; = callbackFlow {\n        val listener = FirebaseAuth.AuthStateListener { auth -&gt;\n            trySend(auth.currentUser)\n        }\n        auth.addAuthStateListener(listener)\n        awaitClose { auth.removeAuthStateListener(listener) }\n    }\n}\n\n// 2. Repository uses Firebase wrapper\nclass UserRepositoryImpl @Inject constructor(\n    private val firebaseAuth: FirebaseAuthWrapper,\n    private val firestore: FirestoreWrapper,\n    private val localDataSource: UserLocalDataSource\n) : UserRepository {\n    // Observe authentication state\n    override fun observeCurrentUser(): Flow&lt;User?&gt; =\n        firebaseAuth.currentUserFlow()\n            .map { firebaseUser -&gt;\n                firebaseUser?.let { getUserFromFirestore(it.uid) }\n            }\n\n    // Sync user data from Firestore to local database\n    private suspend fun getUserFromFirestore(uid: String): User {\n        val firestoreUser = firestore.getUser(uid)\n        localDataSource.saveUser(firestoreUser.toEntity())\n        return firestoreUser.toDomain()\n    }\n}\n\n// 3. ViewModel observes repository\n@HiltViewModel\nclass AuthViewModel @Inject constructor(\n    private val userRepository: UserRepository\n) : ViewModel() {\n    val currentUser: StateFlow&lt;User?&gt; = userRepository.observeCurrentUser()\n        .stateIn(\n            scope = viewModelScope,\n            started = SharingStarted.WhileSubscribed(5000),\n            initialValue = null\n        )\n}\n</code></pre> <p>Key Integration Points:</p> <ul> <li>Firebase wrappers provide reactive Flow-based APIs</li> <li>Repositories coordinate between Firebase and local database</li> <li>ViewModels observe repositories using StateFlow</li> <li>Local database serves as cache for offline access</li> </ul> <p>Tip</p> <p>For Firebase setup, see Firebase Setup Guide. For repository patterns, see Data Layer Guide.</p>"},{"location":"architecture/#dependency-injection-integration","title":"Dependency Injection Integration","text":"<p>Hilt ties all architectural components together by providing dependencies throughout the app.</p> <p>Pattern: Complete DI flow from data sources to UI</p> <pre><code>// 1. Provide data sources\n@Module\n@InstallIn(SingletonComponent::class)\nobject NetworkModule {\n    @Provides\n    @Singleton\n    fun provideApiService(): ApiService = Retrofit.Builder()\n        .baseUrl(BASE_URL)\n        .build()\n        .create(ApiService::class.java)\n}\n\n// 2. Bind repositories\n@Module\n@InstallIn(SingletonComponent::class)\nabstract class RepositoryModule {\n    @Binds\n    @Singleton\n    abstract fun bindUserRepository(\n        impl: UserRepositoryImpl\n    ): UserRepository\n}\n\n// 3. Inject into ViewModels\n@HiltViewModel\nclass HomeViewModel @Inject constructor(\n    private val userRepository: UserRepository,  // Injected by Hilt\n    private val contentRepository: ContentRepository  // Injected by Hilt\n) : ViewModel() {\n    // ViewModel automatically receives dependencies\n}\n\n// 4. Inject into Composables\n@Composable\nfun HomeRoute(\n    viewModel: HomeViewModel = hiltViewModel()  // Hilt provides ViewModel\n) {\n    val uiState by viewModel.uiState.collectAsStateWithLifecycle()\n    // Use ViewModel\n}\n</code></pre> <p>Key Integration Points:</p> <ul> <li>Data sources provided in Singleton scope</li> <li>Repositories use <code>@Binds</code> for interface-to-implementation mapping</li> <li>ViewModels annotated with <code>@HiltViewModel</code> for automatic injection</li> <li><code>hiltViewModel()</code> retrieves ViewModels in Composables</li> <li><code>@AndroidEntryPoint</code> enables injection in Activities/Fragments</li> </ul> <p>Tip</p> <p>For complete DI patterns, see Dependency Injection Guide (993 lines of comprehensive guidance).</p>"},{"location":"architecture/#sync-repositories-integration","title":"Sync + Repositories Integration","text":"<p>WorkManager-based sync integrates with repositories to keep local data synchronized with remote sources.</p> <p>Pattern: Background sync with repository coordination</p> <pre><code>// 1. Repository implements Syncable interface\nclass ContentRepositoryImpl @Inject constructor(\n    private val localDataSource: ContentLocalDataSource,\n    private val networkDataSource: ContentNetworkDataSource,\n    @IoDispatcher private val ioDispatcher: CoroutineDispatcher\n) : ContentRepository, Syncable {\n    // UI observes local database (single source of truth)\n    override fun observeContent(): Flow&lt;List&lt;Content&gt;&gt; =\n        localDataSource.observeContent()\n            .map { entities -&gt; entities.map { it.toDomain() } }\n\n    // Sync updates local database in background\n    override suspend fun sync(): Boolean = withContext(ioDispatcher) {\n        suspendRunCatching {\n            val remoteContent = networkDataSource.getContent()\n            localDataSource.saveContent(remoteContent.map { it.toEntity() })\n        }.isSuccess\n    }\n}\n\n// 2. SyncWorker coordinates repository sync with progress tracking\n@HiltWorker\nclass SyncWorker @AssistedInject constructor(\n    @Assisted private val context: Context,\n    @Assisted workerParameters: WorkerParameters,\n    @IoDispatcher private val ioDispatcher: CoroutineDispatcher,\n    private val homeRepository: HomeRepository\n) : CoroutineWorker(context, workerParameters) {\n    override suspend fun doWork(): Result = withContext(ioDispatcher) {\n        try {\n            setForeground(getForegroundInfo())\n            homeRepository.sync()\n                .flowOn(ioDispatcher)\n                .collect { progress -&gt;\n                    setForeground(getForegroundInfo(progress.total, progress.current))\n                }\n            Result.success()\n        } catch (e: Exception) {\n            if (runAttemptCount &lt; TOTAL_SYNC_ATTEMPTS) Result.retry()\n            else Result.failure()\n        }\n    }\n}\n\n// 3. Initialize sync in Application\nclass App : Application(), Configuration.Provider {\n    override fun onCreate() {\n        super.onCreate()\n        Sync.initialize(context = this)  // Sets up periodic sync\n    }\n}\n</code></pre> <p>Key Integration Points:</p> <ul> <li>Repositories implement <code>sync()</code> method returning <code>Flow&lt;SyncProgress&gt;</code></li> <li><code>SyncWorker</code> receives repository via Hilt dependency injection</li> <li><code>setForeground()</code> displays progress notification as sync runs</li> <li><code>Sync.initialize()</code> sets up periodic WorkManager sync</li> <li>Local database updated in background</li> <li>UI automatically reflects changes via Flow observation</li> <li>Network constraints ensure sync only runs when connected</li> <li>Retry logic with exponential backoff (up to 3 attempts)</li> </ul> <p>Tip</p> <p>For sync patterns and troubleshooting, see Sync Module README.</p>"},{"location":"architecture/#complete-integration-flow-example","title":"Complete Integration Flow Example","text":"<p>Here's how all systems work together when a user opens a feature screen:</p> <pre><code>sequenceDiagram\n    participant UI as Composable\n    participant VM as ViewModel\n    participant Repo as Repository\n    participant Local as Local DB\n    participant Remote as Remote API\n    participant Sync as SyncWorker\n    Note over UI, Sync: User Opens Screen\n    UI -&gt;&gt; VM: hiltViewModel() injection\n    VM -&gt;&gt; Repo: observeData()\n    Repo -&gt;&gt; Local: observeDataEntities()\n    Local --&gt;&gt; Repo: Flow&lt;List&lt;Entity&gt;&gt;\n    Repo --&gt;&gt; VM: Flow&lt;List&lt;Domain&gt;&gt;\n    VM --&gt;&gt; UI: StateFlow&lt;UiState&lt;Data&gt;&gt;\n    Note over UI, Sync: Background Sync (Periodic)\n    Sync -&gt;&gt; Repo: sync()\n    Repo -&gt;&gt; Remote: fetchData()\n    Remote --&gt;&gt; Repo: List&lt;DTO&gt;\n    Repo -&gt;&gt; Local: saveData(entities)\n    Local --&gt;&gt; Repo: Success\n    Note over Local, UI: Flow emits new data\n    Local --&gt;&gt; Repo: Updated Flow\n    Repo --&gt;&gt; VM: Updated Flow\n    VM --&gt;&gt; UI: Updated State\n    UI -&gt;&gt; UI: Recomposition</code></pre> <p>Flow Breakdown:</p> <ol> <li> <p>Screen Opens:</p> <ul> <li>Hilt injects ViewModel with Repository dependencies</li> <li>ViewModel starts observing repository data</li> <li>Repository returns Flow from local database (single source of truth)</li> </ul> </li> <li> <p>Initial Display:</p> <ul> <li>UI receives StateFlow with cached data</li> <li>Screen displays immediately (offline-first)</li> </ul> </li> <li> <p>Background Sync:</p> <ul> <li>WorkManager triggers SyncWorker periodically</li> <li>SyncWorker calls <code>sync()</code> on all repositories</li> <li>Repository fetches from remote and updates local database</li> </ul> </li> <li> <p>Automatic Update:</p> <ul> <li>Local database change triggers Flow emission</li> <li>ViewModel receives updated data</li> <li>UI automatically recomposes with new data</li> </ul> </li> </ol> <p>Key Benefits:</p> <ul> <li>Offline-first: App works without network</li> <li>Automatic updates: No manual refresh needed</li> <li>Type safety: Compile-time navigation and DI</li> <li>Separation of concerns: Each layer has clear responsibility</li> <li>Testability: Dependencies easily mocked via Hilt</li> </ul>"},{"location":"architecture/#summary","title":"Summary","text":"<p>This template uses a two-layer architecture (UI + Data) for simplicity:</p> <ul> <li>UI Layer: Composables + ViewModels with UiState wrapper</li> <li>Data Layer: Repositories + Data Sources (Network, Local, Firebase)</li> <li>State Management: Centralized with <code>updateState</code> and <code>updateStateWith</code> functions</li> <li>Dependency Injection: Hilt with feature-based modules</li> <li>Unidirectional Data Flow: User actions \u2192 ViewModel \u2192 Repository \u2192 Data Sources \u2192 UI</li> </ul> <p>The architecture is intentionally simple but allows for growth when needed.</p>"},{"location":"architecture/#further-reading","title":"Further Reading","text":""},{"location":"architecture/#concept-guides","title":"Concept Guides","text":"<ul> <li>Design Philosophy - Understand the design principles behind the architecture</li> <li>State Management - Deep dive into the UiState pattern</li> <li>Adding Features - Step-by-step guide to implementing new features</li> <li>Data Flow - Understand data flow patterns (offline-first, caching, sync)</li> <li>Dependency Injection - Complete guide to Hilt setup and patterns</li> </ul>"},{"location":"architecture/#module-documentation","title":"Module Documentation","text":"<ul> <li>Core UI Module - State management utilities and UI components</li> <li>Data Layer Module - Repository patterns and implementations</li> <li>App Module - Application architecture and MainActivity setup</li> </ul>"},{"location":"components/","title":"Component Usage Guide","text":"<p>This guide covers the pre-built UI components available in the <code>core:ui</code> module, their usage patterns, customization options, and best practices.</p>"},{"location":"components/#overview","title":"Overview","text":"<p>The Jetpack Android Starter template provides a curated set of Material 3 components with consistent styling and behavior patterns. These components are located in <code>core/ui/src/main/kotlin/dev/atick/core/ui/components/</code>.</p>"},{"location":"components/#component-philosophy","title":"Component Philosophy","text":"<ol> <li>Material 3 Foundation: All components wrap Material 3 components with opinionated defaults</li> <li>Consistent Theming: Components automatically adapt to your app's theme</li> <li>Accessibility First: Built-in content descriptions and semantic properties</li> <li>Minimal Configuration: Sensible defaults reduce boilerplate</li> <li>Composable: Flexible content slots for customization</li> </ol>"},{"location":"components/#when-to-use-pre-built-components","title":"When to Use Pre-Built Components","text":"<p>Use pre-built components when:</p> <ul> <li>You need standard UI patterns (buttons, text fields, app bars)</li> <li>You want consistent styling across your app</li> <li>You need accessibility features out of the box</li> <li>You want to reduce boilerplate code</li> </ul> <p>Create custom components when:</p> <ul> <li>You need highly specialized UI behavior</li> <li>Pre-built components don't match your design requirements</li> <li>You need fine-grained control over component internals</li> </ul>"},{"location":"components/#component-selection-guide","title":"Component Selection Guide","text":"<p>Use this flowchart to quickly find the right component for your needs:</p> <pre><code>graph TD\n    Start[What do you need?] --&gt; Input{User Input?}\n    Input --&gt;|Text| TextType{Input Type?}\n    Input --&gt;|Selection| SelectType{Selection Type?}\n    Input --&gt;|Action| ActionType{Action Type?}\n    Input --&gt;|Navigation| NavType{Navigation Type?}\n    Input --&gt;|Display| DisplayType{Display Type?}\n    TextType --&gt;|Regular Text| JetpackTextFiled\n    TextType --&gt;|Password| JetpackPasswordFiled\n    SelectType --&gt;|Multi - select Filter| JetpackFilterChip\n    SelectType --&gt;|Follow/Unfollow| JetpackTag\n    SelectType --&gt;|Toggle State| JetpackIconToggleButton\n    SelectType --&gt;|2 - 4 Options| JetpackToggleOptions\n    SelectType --&gt;|Tabs| JetpackTabRow\n    ActionType --&gt;|Primary| ButtonType{Need Emphasis?}\n    ActionType --&gt;|Icon Toggle| JetpackIconToggleButton\n    ActionType --&gt;|Primary FAB| FabType{Need Text?}\n    ButtonType --&gt;|High| JetpackButton\n    ButtonType --&gt;|Medium| JetpackOutlinedButton\n    ButtonType --&gt;|Low| JetpackTextButton\n    FabType --&gt;|Yes| JetpackExtendedFab\n    FabType --&gt;|No| MaterialFAB[Use Material3 FloatingActionButton]\n    NavType --&gt;|App - wide Adaptive| JetpackNavigationSuiteScaffold\n    NavType --&gt;|Bottom Bar Only| JetpackNavigationBar\n    NavType --&gt;|Side Rail Only| JetpackNavigationRail\n    NavType --&gt;|Top Bar| AppBarType{Need Action?}\n    AppBarType --&gt;|Back + Icon| JetpackTopAppBar1[JetpackTopAppBar]\n    AppBarType --&gt;|Icon Only| JetpackTopAppBar2[JetpackTopAppBar]\n    AppBarType --&gt;|Avatar| JetpackTopAppBarWithAvatar\n    AppBarType --&gt;|Text Action| JetpackActionBar\n    DisplayType --&gt;|Loading| LoadingType{Overlay?}\n    DisplayType --&gt;|Image| JetpackDynamicAsyncImage[DynamicAsyncImage]\n    DisplayType --&gt;|Divider| DividerWithText\n    DisplayType --&gt;|Background| BgType{Gradient?}\n    LoadingType --&gt;|Yes| JetpackOverlayLoadingWheel\n    LoadingType --&gt;|No| JetpackLoadingWheel\n    BgType --&gt;|Yes| AppGradientBackground\n    BgType --&gt;|No| AppBackground\n    Start --&gt; Gesture{Swipe Gesture?}\n    Gesture --&gt;|Swipe to Delete| SwipeToDismiss</code></pre>"},{"location":"components/#component-reference","title":"Component Reference","text":""},{"location":"components/#buttons","title":"Buttons","text":"<p>The template provides three button variants: filled, outlined, and text buttons. All support text and icon content.</p>"},{"location":"components/#jetpackbutton-filled","title":"JetpackButton (Filled)","text":"<p>Purpose: Primary actions, high emphasis</p> <p>Basic Usage:</p> <pre><code>JetpackButton(\n    onClick = { /* action */ },\n    text = { Text(\"Continue\") }\n)\n</code></pre> <p>With Leading Icon:</p> <pre><code>JetpackButton(\n    onClick = { /* action */ },\n    text = { Text(\"Sign In\") },\n    leadingIcon = {\n        Icon(\n            imageVector = Icons.Default.Login,\n            contentDescription = null\n        )\n    }\n)\n</code></pre> <p>Custom Content:</p> <pre><code>JetpackButton(\n    onClick = { /* action */ },\n    modifier = Modifier.fillMaxWidth()\n) {\n    Text(\"Custom Layout\")\n    Icon(Icons.Default.ArrowForward, contentDescription = null)\n}\n</code></pre> <p>Parameters:</p> <ul> <li><code>onClick</code>: Callback when button is clicked</li> <li><code>text</code>: Text label composable (in overload)</li> <li><code>leadingIcon</code>: Optional icon before text (in overload)</li> <li><code>content</code>: Custom content slot (in base overload)</li> <li><code>modifier</code>: Modifier to customize appearance</li> <li><code>enabled</code>: Boolean to enable/disable button (default: <code>true</code>)</li> <li><code>contentPadding</code>: Internal padding (default: <code>ButtonDefaults.ContentPadding</code>)</li> </ul> <p>Theming: Uses <code>MaterialTheme.colorScheme.onBackground</code> for container color</p>"},{"location":"components/#jetpackoutlinedbutton","title":"JetpackOutlinedButton","text":"<p>Purpose: Secondary actions, medium emphasis</p> <p>Usage: Same API as <code>JetpackButton</code>, but with outlined style</p> <pre><code>JetpackOutlinedButton(\n    onClick = { /* action */ },\n    text = { Text(\"Cancel\") }\n)\n</code></pre> <p>Theming:</p> <ul> <li>Uses <code>MaterialTheme.colorScheme.outline</code> for border</li> <li>Adapts border color when disabled (12% alpha)</li> <li>1.dp border width</li> </ul>"},{"location":"components/#jetpacktextbutton","title":"JetpackTextButton","text":"<p>Purpose: Tertiary actions, low emphasis</p> <p>Usage: Same API as <code>JetpackButton</code>, but with no background</p> <pre><code>JetpackTextButton(\n    onClick = { /* action */ },\n    text = { Text(\"Skip\") }\n)\n</code></pre> <p>Common Pattern - Button Row:</p> <pre><code>Row(\n    modifier = Modifier.fillMaxWidth(),\n    horizontalArrangement = Arrangement.spacedBy(8.dp)\n) {\n    JetpackOutlinedButton(\n        onClick = onCancel,\n        text = { Text(\"Cancel\") },\n        modifier = Modifier.weight(1f)\n    )\n    JetpackButton(\n        onClick = onConfirm,\n        text = { Text(\"Confirm\") },\n        modifier = Modifier.weight(1f)\n    )\n}\n</code></pre>"},{"location":"components/#text-fields","title":"Text Fields","text":""},{"location":"components/#jetpacktextfiled","title":"JetpackTextFiled","text":"<p>Purpose: Standard text input with validation support</p> <p>Basic Usage:</p> <pre><code>var email by remember { mutableStateOf(\"\") }\n\nJetpackTextFiled(\n    value = email,\n    onValueChange = { email = it },\n    label = { Text(\"Email\") },\n    leadingIcon = {\n        Icon(\n            imageVector = Icons.Default.Email,\n            contentDescription = null\n        )\n    }\n)\n</code></pre> <p>With Validation:</p> <pre><code>val emailData by viewModel.emailData.collectAsStateWithLifecycle()\n\nJetpackTextFiled(\n    value = emailData.value,\n    onValueChange = viewModel::updateEmail,\n    label = { Text(\"Email\") },\n    leadingIcon = {\n        Icon(Icons.Default.Email, contentDescription = null)\n    },\n    errorMessage = emailData.errorMessage,\n    keyboardOptions = KeyboardOptions(\n        keyboardType = KeyboardType.Email\n    )\n)\n</code></pre> <p>Parameters:</p> <ul> <li><code>value</code>: Current text value</li> <li><code>onValueChange</code>: Callback when text changes</li> <li><code>label</code>: Label composable</li> <li><code>leadingIcon</code>: Icon before text input</li> <li><code>trailingIcon</code>: Icon after text input (optional)</li> <li><code>errorMessage</code>: Error text to display (null for no error)</li> <li><code>keyboardOptions</code>: Keyboard configuration (default: <code>KeyboardOptions.Default</code>)</li> <li><code>modifier</code>: Modifier to customize appearance</li> </ul> <p>Validation Pattern: The recommended pattern uses <code>TextFiledData</code> from <code>core:ui</code>:</p> <pre><code>// In ViewModel\nprivate val _uiState = MutableStateFlow(UiState(ScreenData()))\n\nfun updateEmail(email: String) {\n    _uiState.updateState {\n        copy(\n            email = TextFiledData(\n                value = email,\n                errorMessage = if (email.isEmailValid()) null else \"Invalid email\"\n            )\n        )\n    }\n}\n\n// Data class\ndata class ScreenData(\n    val email: TextFiledData = TextFiledData(\"\")\n)\n</code></pre> <p>Styling:</p> <ul> <li>50% rounded corners</li> <li>Red border/color when error is present</li> <li>Animated error message appearance</li> </ul>"},{"location":"components/#jetpackpasswordfiled","title":"JetpackPasswordFiled","text":"<p>Purpose: Password input with visibility toggle</p> <p>Usage:</p> <pre><code>var password by remember { mutableStateOf(\"\") }\n\nJetpackPasswordFiled(\n    value = password,\n    onValueChange = { password = it },\n    label = { Text(\"Password\") },\n    leadingIcon = {\n        Icon(\n            imageVector = Icons.Default.Lock,\n            contentDescription = null\n        )\n    },\n    errorMessage = if (password.length &lt; 8) \"Too short\" else null\n)\n</code></pre> <p>Features:</p> <ul> <li>Automatic visibility toggle button</li> <li>Password masking by default</li> <li>Uses <code>PasswordVisualTransformation</code></li> <li>Saves visibility state across configuration changes</li> </ul> <p>Common Pattern - Login Form:</p> <pre><code>Column(\n    modifier = Modifier\n        .fillMaxWidth()\n        .padding(16.dp),\n    verticalArrangement = Arrangement.spacedBy(16.dp)\n) {\n    JetpackTextFiled(\n        value = email,\n        onValueChange = viewModel::updateEmail,\n        label = { Text(\"Email\") },\n        leadingIcon = { Icon(Icons.Default.Email, null) },\n        errorMessage = emailData.errorMessage\n    )\n\n    JetpackPasswordFiled(\n        value = password,\n        onValueChange = viewModel::updatePassword,\n        label = { Text(\"Password\") },\n        leadingIcon = { Icon(Icons.Default.Lock, null) },\n        errorMessage = passwordData.errorMessage\n    )\n\n    JetpackButton(\n        onClick = viewModel::signIn,\n        text = { Text(\"Sign In\") },\n        modifier = Modifier.fillMaxWidth(),\n        enabled = emailData.isValid &amp;&amp; passwordData.isValid\n    )\n}\n</code></pre>"},{"location":"components/#top-app-bars","title":"Top App Bars","text":""},{"location":"components/#jetpacktopappbar-navigation-action","title":"JetpackTopAppBar (Navigation + Action)","text":"<p>Purpose: Screen title with navigation and action icons</p> <p>Usage:</p> <pre><code>JetpackTopAppBar(\n    titleRes = R.string.screen_title,\n    navigationIcon = Icons.AutoMirrored.Filled.ArrowBack,\n    navigationIconContentDescription = \"Navigate back\",\n    actionIcon = Icons.Default.Settings,\n    actionIconContentDescription = \"Open settings\",\n    onNavigationClick = { navController.navigateUp() },\n    onActionClick = { /* open settings */ }\n)\n</code></pre> <p>Parameters:</p> <ul> <li><code>titleRes</code>: String resource for title</li> <li><code>navigationIcon</code>: Leading icon (typically back arrow)</li> <li><code>navigationIconContentDescription</code>: Accessibility label for navigation</li> <li><code>actionIcon</code>: Trailing action icon</li> <li><code>actionIconContentDescription</code>: Accessibility label for action</li> <li><code>onNavigationClick</code>: Navigation callback</li> <li><code>onActionClick</code>: Action callback</li> <li><code>colors</code>: TopAppBar colors (default: Material 3 defaults)</li> <li><code>modifier</code>: Modifier to customize appearance</li> </ul>"},{"location":"components/#jetpacktopappbar-action-only","title":"JetpackTopAppBar (Action Only)","text":"<p>Purpose: Screen title with action icon only</p> <p>Usage:</p> <pre><code>JetpackTopAppBar(\n    titleRes = R.string.home,\n    actionIcon = Icons.Default.Settings,\n    actionIconContentDescription = \"Settings\",\n    onActionClick = { /* open settings */ }\n)\n</code></pre>"},{"location":"components/#jetpacktopappbarwithavatar","title":"JetpackTopAppBarWithAvatar","text":"<p>Purpose: Screen title with user avatar</p> <p>Usage:</p> <pre><code>JetpackTopAppBarWithAvatar(\n    titleRes = R.string.home,\n    avatarUri = userProfilePictureUri,\n    avatarContentDescription = \"Profile picture\",\n    onAvatarClick = { navController.navigateToProfile() }\n)\n</code></pre> <p>Features:</p> <ul> <li>Loads avatar with Coil's <code>AsyncImage</code></li> <li>Fallback to default avatar drawable</li> <li>Circular clip automatically applied</li> </ul>"},{"location":"components/#jetpackactionbar","title":"JetpackActionBar","text":"<p>Purpose: Screen with back navigation and text action button</p> <p>Usage:</p> <pre><code>JetpackActionBar(\n    titleRes = R.string.edit_profile,\n    actionRes = R.string.save,\n    onNavigateBackClick = { navController.navigateUp() },\n    onActionClick = viewModel::saveProfile\n)\n</code></pre> <p>Unique Feature: Uses <code>JetpackButton</code> instead of icon for the action</p> <p>Common Pattern - Scaffold with Top App Bar:</p> <pre><code>Scaffold(\n    topBar = {\n        JetpackTopAppBar(\n            titleRes = R.string.screen_title,\n            navigationIcon = Icons.AutoMirrored.Filled.ArrowBack,\n            navigationIconContentDescription = \"Back\",\n            actionIcon = Icons.Default.MoreVert,\n            actionIconContentDescription = \"More options\",\n            onNavigationClick = { navController.navigateUp() },\n            onActionClick = { /* show menu */ }\n        )\n    }\n) { paddingValues -&gt;\n    // Screen content\n    Content(modifier = Modifier.padding(paddingValues))\n}\n</code></pre>"},{"location":"components/#loading-indicators","title":"Loading Indicators","text":""},{"location":"components/#jetpackloadingwheel","title":"JetpackLoadingWheel","text":"<p>Purpose: Animated loading indicator</p> <p>Usage:</p> <pre><code>JetpackLoadingWheel(\n    contentDesc = \"Loading data\",\n    modifier = Modifier.size(48.dp)\n)\n</code></pre> <p>Features:</p> <ul> <li>Custom animated wheel design</li> <li>12 rotating lines with color transitions</li> <li>Automatic rotation animation</li> <li>Material 3 color scheme integration</li> </ul> <p>Parameters:</p> <ul> <li><code>contentDesc</code>: Accessibility content description</li> <li><code>modifier</code>: Modifier (default includes 48.dp size)</li> </ul>"},{"location":"components/#jetpackoverlayloadingwheel","title":"JetpackOverlayLoadingWheel","text":"<p>Purpose: Loading indicator with semi-transparent background</p> <p>Usage:</p> <pre><code>Box(modifier = Modifier.fillMaxSize()) {\n    // Your content\n    Content()\n\n    // Show loading overlay\n    if (isLoading) {\n        JetpackOverlayLoadingWheel(\n            contentDesc = \"Loading\",\n            modifier = Modifier.align(Alignment.Center)\n        )\n    }\n}\n</code></pre> <p>Features:</p> <ul> <li>Rounded corners (60.dp)</li> <li>Elevated surface (8.dp shadow)</li> <li>83% opacity background</li> <li>Fixed 60.dp size</li> </ul> <p>Common Pattern - Loading State:</p> <pre><code>Box(modifier = Modifier.fillMaxSize()) {\n    when {\n        uiState.loading -&gt; {\n            JetpackOverlayLoadingWheel(\n                contentDesc = \"Loading content\",\n                modifier = Modifier.align(Alignment.Center)\n            )\n        }\n        uiState.data.isEmpty() -&gt; {\n            EmptyState(modifier = Modifier.align(Alignment.Center))\n        }\n        else -&gt; {\n            ContentList(items = uiState.data)\n        }\n    }\n}\n</code></pre>"},{"location":"components/#filter-chips","title":"Filter Chips","text":""},{"location":"components/#jetpackfilterchip","title":"JetpackFilterChip","text":"<p>Purpose: Multi-select filtering with visual checkmarks</p> <p>Usage:</p> <pre><code>var selectedCategories by remember { mutableStateOf(setOf&lt;String&gt;()) }\nval categories = listOf(\"Active\", \"Completed\", \"Archived\")\n\nLazyRow(horizontalArrangement = Arrangement.spacedBy(8.dp)) {\n    items(categories) { category -&gt;\n        JetpackFilterChip(\n            selected = category in selectedCategories,\n            onSelectedChange = { selected -&gt;\n                selectedCategories = if (selected) {\n                    selectedCategories + category\n                } else {\n                    selectedCategories - category\n                }\n            },\n            label = { Text(category) }\n        )\n    }\n}\n</code></pre> <p>Features:</p> <ul> <li>Automatic checkmark icon when selected</li> <li>Circular pill shape</li> <li>Custom border and color styling</li> <li>Disabled state support</li> </ul> <p>When to use:</p> <ul> <li>Filtering lists or content (e.g., \"Active\", \"Completed\", \"All\")</li> <li>Multi-select scenarios where users can pick multiple options</li> <li>Category or tag selection</li> </ul> <p>Parameters:</p> <ul> <li><code>selected</code>: Whether the chip is currently checked</li> <li><code>onSelectedChange</code>: Callback when chip is toggled</li> <li><code>label</code>: Text label content</li> <li><code>enabled</code>: Enable/disable chip (default: <code>true</code>)</li> <li><code>modifier</code>: Modifier to customize appearance</li> </ul> <p>See also: <code>JetpackTag</code> for non-toggleable tags with different visual style</p>"},{"location":"components/#tags","title":"Tags","text":""},{"location":"components/#jetpacktag","title":"JetpackTag","text":"<p>Purpose: Follow/unfollow topics or interests</p> <p>Usage:</p> <pre><code>var followedTopics by remember { mutableStateOf(setOf&lt;String&gt;()) }\nval availableTopics = listOf(\"Android\", \"Kotlin\", \"Compose\", \"Testing\")\n\nFlowRow(\n    horizontalArrangement = Arrangement.spacedBy(8.dp),\n    verticalArrangement = Arrangement.spacedBy(8.dp)\n) {\n    availableTopics.forEach { topic -&gt;\n        JetpackTag(\n            followed = topic in followedTopics,\n            onClick = {\n                followedTopics = if (topic in followedTopics) {\n                    followedTopics - topic\n                } else {\n                    followedTopics + topic\n                }\n            },\n            text = { Text(topic) }\n        )\n    }\n}\n</code></pre> <p>Features:</p> <ul> <li>Visual distinction between followed (solid) and unfollowed (translucent) states</li> <li>Rounded button shape with small text</li> <li>Theme-aware colors</li> <li>Disabled state support</li> </ul> <p>When to use:</p> <ul> <li>Interest or topic selection (e.g., \"Follow topics you're interested in\")</li> <li>Category management</li> <li>Tag-based filtering with persistent selection</li> </ul> <p>Parameters:</p> <ul> <li><code>followed</code>: Whether this tag is followed</li> <li><code>onClick</code>: Callback when tag is clicked</li> <li><code>text</code>: Text label content</li> <li><code>enabled</code>: Enable/disable tag (default: <code>true</code>)</li> <li><code>modifier</code>: Modifier to customize appearance</li> </ul> <p>See also: <code>JetpackFilterChip</code> for temporary filtering (non-persistent selection)</p>"},{"location":"components/#icon-toggle-buttons","title":"Icon Toggle Buttons","text":""},{"location":"components/#jetpackicontogglebutton","title":"JetpackIconToggleButton","text":"<p>Purpose: Binary toggle actions (favorite/unfavorite, bookmark/unbookmark)</p> <p>Usage:</p> <pre><code>var isFavorite by remember { mutableStateOf(false) }\n\nJetpackIconToggleButton(\n    checked = isFavorite,\n    onCheckedChange = { isFavorite = it },\n    icon = {\n        Icon(\n            imageVector = Icons.Default.FavoriteBorder,\n            contentDescription = \"Add to favorites\"\n        )\n    },\n    checkedIcon = {\n        Icon(\n            imageVector = Icons.Default.Favorite,\n            contentDescription = \"Remove from favorites\"\n        )\n    }\n)\n</code></pre> <p>Features:</p> <ul> <li>Automatic icon switching between checked/unchecked states</li> <li>Filled background with rounded shape</li> <li>Primary container color when checked, transparent when unchecked</li> <li>Disabled state support</li> </ul> <p>When to use:</p> <ul> <li>Binary toggle actions (favorite/unfavorite, bookmark/unbookmark)</li> <li>Visibility toggles (show/hide password, expand/collapse)</li> <li>State indicators that can be toggled</li> </ul> <p>Parameters:</p> <ul> <li><code>checked</code>: Whether the toggle button is currently checked</li> <li><code>onCheckedChange</code>: Callback when toggle button is clicked</li> <li><code>icon</code>: Icon content when unchecked</li> <li><code>checkedIcon</code>: Icon content when checked (defaults to <code>icon</code> if not provided)</li> <li><code>enabled</code>: Enable/disable button (default: <code>true</code>)</li> <li><code>modifier</code>: Modifier to customize appearance</li> </ul>"},{"location":"components/#toggle-options","title":"Toggle Options","text":""},{"location":"components/#jetpacktoggleoptions","title":"JetpackToggleOptions","text":"<p>Purpose: Segmented button selector for mutually exclusive choices</p> <p>Usage:</p> <pre><code>val themeOptions = listOf(\n    ToggleOption(text = R.string.light, icon = Icons.Default.LightMode),\n    ToggleOption(text = R.string.dark, icon = Icons.Default.DarkMode),\n    ToggleOption(text = R.string.system, icon = Icons.Default.SettingsBrightness)\n)\nvar selectedTheme by remember { mutableIntStateOf(2) } // System\n\nJetpackToggleOptions(\n    options = themeOptions,\n    selectedIndex = selectedTheme,\n    onSelectionChange = { selectedTheme = it }\n)\n</code></pre> <p>Features:</p> <ul> <li>Segmented button-style selector</li> <li>Animated transitions between states</li> <li>Icon and text for each option</li> <li>Fixed 56dp height with rounded corners</li> </ul> <p>When to use:</p> <ul> <li>Mutually exclusive choices (Light/Dark/System theme)</li> <li>View modes (List/Grid)</li> <li>Any set of 2-4 options requiring visual selection</li> </ul> <p>Parameters:</p> <ul> <li><code>options</code>: List of <code>ToggleOption</code> (recommended 2-4 options)</li> <li><code>selectedIndex</code>: Zero-based index of selected option</li> <li><code>onSelectionChange</code>: Callback when selection changes</li> <li><code>modifier</code>: Modifier to customize appearance</li> </ul>"},{"location":"components/#floating-action-buttons","title":"Floating Action Buttons","text":""},{"location":"components/#jetpackextendedfab","title":"JetpackExtendedFab","text":"<p>Purpose: Primary actions with text label for clarity</p> <p>Usage:</p> <pre><code>Scaffold(\n    floatingActionButton = {\n        JetpackExtendedFab(\n            icon = Icons.Default.Add,\n            text = R.string.create_item,\n            onClick = { navController.navigate(CreateItem) }\n        )\n    }\n) { padding -&gt;\n    ItemList(Modifier.padding(padding))\n}\n</code></pre> <p>Features:</p> <ul> <li>Combined icon and text for clarity</li> <li>Material 3 theming and colors</li> <li>Standard FAB elevation and behavior</li> <li>Uses the same resource for icon description and button text</li> </ul> <p>When to use:</p> <ul> <li>Primary actions that need text label for clarity (e.g., \"Create\", \"Compose\")</li> <li>When users need extra context beyond just an icon</li> <li>First-time user experiences where action should be obvious</li> </ul> <p>Parameters:</p> <ul> <li><code>icon</code>: Icon to display</li> <li><code>text</code>: String resource for both text label and icon content description</li> <li><code>onClick</code>: Callback when FAB is clicked</li> <li><code>modifier</code>: Modifier to customize appearance</li> </ul> <p>Note</p> <p>For icon-only FABs, use Material 3's <code>FloatingActionButton</code> directly.</p>"},{"location":"components/#navigation-components","title":"Navigation Components","text":"<p>The template provides adaptive navigation components that automatically adjust based on screen size.</p>"},{"location":"components/#jetpacknavigationsuitescaffold","title":"JetpackNavigationSuiteScaffold","text":"<p>Purpose: Adaptive navigation (bottom bar on phones, rail on tablets, drawer on large screens)</p> <p>Usage:</p> <pre><code>JetpackNavigationSuiteScaffold(\n    navigationSuiteItems = {\n        destinations.forEach { destination -&gt;\n            val selected = destination == currentDestination\n            item(\n                selected = selected,\n                onClick = { onNavigateToDestination(destination) },\n                icon = { Icon(destination.unselectedIcon, contentDescription = null) },\n                selectedIcon = { Icon(destination.selectedIcon, contentDescription = null) },\n                label = { Text(stringResource(destination.labelRes)) }\n            )\n        }\n    }\n) {\n    NavHost(navController = navController, startDestination = startDestination) {\n        // Navigation graph\n    }\n}\n</code></pre> <p>Features:</p> <ul> <li>Automatic adaptation based on window size:<ul> <li>Compact screens: Bottom navigation bar</li> <li>Medium screens: Navigation rail</li> <li>Expanded screens: Navigation drawer</li> </ul> </li> <li>Consistent theming across all layouts</li> <li>Icon switching between selected/unselected states</li> </ul> <p>When to use:</p> <ul> <li>App-wide navigation</li> <li>Multi-destination apps</li> <li>Responsive layouts across devices</li> </ul>"},{"location":"components/#jetpacknavigationbar","title":"JetpackNavigationBar","text":"<p>Purpose: Bottom navigation bar for compact screens</p> <p>Usage:</p> <pre><code>JetpackNavigationBar {\n    destinations.forEach { destination -&gt;\n        JetpackNavigationBarItem(\n            selected = currentDestination == destination,\n            onClick = { onNavigateToDestination(destination) },\n            icon = { Icon(destination.icon, contentDescription = null) },\n            label = { Text(stringResource(destination.label)) }\n        )\n    }\n}\n</code></pre> <p>When to use:</p> <ul> <li>Fixed bottom navigation on phones</li> <li>3-5 top-level destinations</li> </ul>"},{"location":"components/#jetpacknavigationrail","title":"JetpackNavigationRail","text":"<p>Purpose: Side navigation for tablets and larger screens</p> <p>Usage:</p> <pre><code>JetpackNavigationRail(\n    header = {\n        JetpackExtendedFab(\n            icon = Icons.Default.Add,\n            text = R.string.create,\n            onClick = { /* ... */ }\n        )\n    }\n) {\n    destinations.forEach { destination -&gt;\n        JetpackNavigationRailItem(\n            selected = currentDestination == destination,\n            onClick = { onNavigateToDestination(destination) },\n            icon = { Icon(destination.icon, contentDescription = null) },\n            label = { Text(stringResource(destination.label)) }\n        )\n    }\n}\n</code></pre> <p>When to use:</p> <ul> <li>Tablet and large screen layouts</li> <li>Apps with many destinations (5+)</li> </ul> <p>See also: Navigation Deep Dive for type-safe navigation patterns</p>"},{"location":"components/#tabs","title":"Tabs","text":""},{"location":"components/#jetpacktab-jetpacktabrow","title":"JetpackTab &amp; JetpackTabRow","text":"<p>Purpose: Tabbed content switching within a screen</p> <p>Usage:</p> <pre><code>var selectedTab by remember { mutableIntStateOf(0) }\nval tabs = listOf(\"Feed\", \"Explore\", \"Profile\")\n\nColumn {\n    JetpackTabRow(selectedTabIndex = selectedTab) {\n        tabs.forEachIndexed { index, title -&gt;\n            JetpackTab(\n                selected = selectedTab == index,\n                onClick = { selectedTab = index },\n                text = { Text(title) }\n            )\n        }\n    }\n\n    // Content for selected tab\n    when (selectedTab) {\n        0 -&gt; FeedScreen()\n        1 -&gt; ExploreScreen()\n        2 -&gt; ProfileScreen()\n    }\n}\n</code></pre> <p>Features:</p> <ul> <li>Transparent container background</li> <li>Secondary indicator (2dp height) that animates between tabs</li> <li>Equal spacing for all tabs</li> <li>Custom top padding for visual alignment</li> </ul> <p>When to use:</p> <ul> <li>Content switching within a single screen</li> <li>Viewing different aspects of the same data</li> <li>Alternative views of content</li> </ul> <p>Parameters (JetpackTab):</p> <ul> <li><code>selected</code>: Whether tab is selected</li> <li><code>onClick</code>: Callback when tab is clicked</li> <li><code>text</code>: Text label content</li> <li><code>enabled</code>: Enable/disable tab (default: <code>true</code>)</li> <li><code>modifier</code>: Modifier to customize appearance</li> </ul> <p>Parameters (JetpackTabRow):</p> <ul> <li><code>selectedTabIndex</code>: Index of currently selected tab</li> <li><code>tabs</code>: Tab composables (typically multiple <code>JetpackTab</code>s)</li> <li><code>modifier</code>: Modifier to customize appearance</li> </ul>"},{"location":"components/#dividers","title":"Dividers","text":""},{"location":"components/#dividerwithtext","title":"DividerWithText","text":"<p>Purpose: Horizontal divider with centered text (e.g., \"OR\" between sign-in methods)</p> <p>Usage:</p> <pre><code>Column {\n    // Email sign-in form\n    JetpackTextFiled(...)\n    JetpackPasswordFiled(...)\n    JetpackButton(onClick = { ... }) { Text(\"Sign In\") }\n\n    DividerWithText(text = R.string.or)\n\n    // Social sign-in buttons\n    GoogleSignInButton(onClick = { ... })\n    FacebookSignInButton(onClick = { ... })\n}\n</code></pre> <p>Features:</p> <ul> <li>Centered text label with equal dividers on both sides</li> <li>Material 3 HorizontalDivider styling</li> <li>Small typography for subtle visual separation</li> <li>16dp horizontal padding around text</li> </ul> <p>When to use:</p> <ul> <li>Separating alternative sign-in methods (\"OR\")</li> <li>Breaking up long forms into logical sections</li> <li>Showing \"More options\" between primary and secondary actions</li> </ul> <p>Parameters:</p> <ul> <li><code>text</code>: String resource for text to display</li> <li><code>modifier</code>: Modifier to customize appearance</li> </ul>"},{"location":"components/#swipe-to-dismiss","title":"Swipe to Dismiss","text":""},{"location":"components/#swipetodismiss","title":"SwipeToDismiss","text":"<p>Purpose: Swipe-to-delete gesture for list items</p> <p>Usage:</p> <pre><code>LazyColumn {\n    items(items, key = { it.id }) { item -&gt;\n        SwipeToDismiss(\n            onDelete = { viewModel.deleteItem(item.id) }\n        ) {\n            ItemCard(item = item)\n        }\n    }\n}\n</code></pre> <p>Features:</p> <ul> <li>End-to-start swipe only (prevents accidental dismissal)</li> <li>Visual feedback: delete icon with error container background</li> <li>Animated background color based on swipe progress</li> <li>Confirmation: <code>onDelete</code> only called when swipe completes threshold</li> </ul> <p>When to use:</p> <ul> <li>Dismissing items in a LazyColumn list</li> <li>Removing notifications</li> <li>Deleting messages or emails</li> </ul> <p>Parameters:</p> <ul> <li><code>onDelete</code>: Callback when item is swiped to dismiss</li> <li><code>content</code>: Content to display (the item being dismissed)</li> <li><code>modifier</code>: Modifier to customize appearance</li> </ul> <p>Tip</p> <p>Always use <code>key</code> parameter in <code>items()</code> for proper animation and recomposition when using SwipeToDismiss.</p>"},{"location":"components/#image-loading","title":"Image Loading","text":""},{"location":"components/#dynamicasyncimage","title":"DynamicAsyncImage","text":"<p>Purpose: Async image loading with Coil integration</p> <p>Usage:</p> <pre><code>DynamicAsyncImage(\n    imageUrl = \"https://example.com/avatar.jpg\",\n    contentDescription = \"User avatar\",\n    placeholder = painterResource(R.drawable.ic_placeholder),\n    modifier = Modifier\n        .size(80.dp)\n        .clip(CircleShape)\n)\n</code></pre> <p>Features:</p> <ul> <li>Loading state: Displays <code>JetpackLoadingWheel</code> while loading</li> <li>Error handling: Falls back to placeholder on failure</li> <li>Theme integration: Applies tint from <code>LocalTintTheme</code> when appropriate</li> <li>Preview mode: Shows placeholder in Android Studio preview</li> <li>Coil integration: Automatic memory and disk caching</li> </ul> <p>When to use:</p> <ul> <li>Loading remote images (avatars, thumbnails, photos)</li> <li>Any image that needs async loading</li> <li>Images requiring loading states and error handling</li> </ul> <p>Parameters:</p> <ul> <li><code>imageUrl</code>: URL of image to load</li> <li><code>contentDescription</code>: Accessibility description</li> <li><code>placeholder</code>: Painter to display while loading or on error (default: <code>ic_placeholder</code>)</li> <li><code>modifier</code>: Modifier to customize appearance</li> </ul> <p>See also: Performance Guide for image optimization patterns</p>"},{"location":"components/#background-components","title":"Background Components","text":""},{"location":"components/#appbackground","title":"AppBackground","text":"<p>Purpose: Main app background with theme support</p> <p>Usage:</p> <pre><code>@Composable\nfun MyApp() {\n    AppBackground {\n        Scaffold(\n            topBar = { JetpackTopAppBar(...) },\n            content = { padding -&gt;\n                MainContent(Modifier.padding(padding))\n            }\n        )\n    }\n}\n</code></pre> <p>Features:</p> <ul> <li>Automatic color from <code>LocalBackgroundTheme</code></li> <li>Tonal elevation support for depth</li> <li>Resets absolute tonal elevation for nested surfaces</li> <li>Fills max size by default</li> </ul> <p>When to use:</p> <ul> <li>App-level background wrapper</li> <li>Consistent theming across screens</li> </ul>"},{"location":"components/#appgradientbackground","title":"AppGradientBackground","text":"<p>Purpose: Decorative gradient background for special screens</p> <p>Usage:</p> <pre><code>@Composable\nfun OnboardingScreen() {\n    AppGradientBackground(\n        gradientColors = GradientColors(\n            top = Color(0xFF4CAF50),\n            bottom = Color(0xFF2196F3),\n            container = MaterialTheme.colorScheme.surface\n        )\n    ) {\n        Column(\n            modifier = Modifier.fillMaxSize(),\n            verticalArrangement = Arrangement.Center\n        ) {\n            Text(\"Welcome!\", style = MaterialTheme.typography.displayLarge)\n            Text(\"Get started with our app\")\n        }\n    }\n}\n</code></pre> <p>Features:</p> <ul> <li>Dual gradient (top fades out at 72.4%, bottom fades in at 25.5%)</li> <li>Angled at 11.06 degrees for visual interest</li> <li>Theme-aware gradient colors from <code>LocalGradientColors</code></li> <li>Container background with gradient overlay</li> </ul> <p>When to use:</p> <ul> <li>Onboarding or welcome screens</li> <li>Feature announcements or promotions</li> <li>Hero sections with visual emphasis</li> <li>Special event or seasonal theming</li> </ul> <p>Parameters:</p> <ul> <li><code>gradientColors</code>: Gradient colors to render (default: <code>LocalGradientColors.current</code>)</li> <li><code>content</code>: Background content</li> <li><code>modifier</code>: Modifier to customize appearance</li> </ul> <p>See also: <code>AppBackground</code> for standard solid backgrounds</p>"},{"location":"components/#theming-components","title":"Theming Components","text":""},{"location":"components/#color-scheme","title":"Color Scheme","text":"<p>All components use Material 3's <code>MaterialTheme.colorScheme</code>. The default color scheme is defined in <code>core/ui/src/main/kotlin/dev/atick/core/ui/theme/Color.kt</code>.</p> <p>Component Color Usage:</p> <ul> <li>JetpackButton: <code>colorScheme.onBackground</code> (container)</li> <li>JetpackOutlinedButton: <code>colorScheme.outline</code> (border)</li> <li>Loading Indicators: <code>colorScheme.onBackground</code> and <code>colorScheme.inversePrimary</code></li> <li>Text Fields: <code>colorScheme.error</code> (when error is present)</li> </ul>"},{"location":"components/#customizing-colors","title":"Customizing Colors","text":"<p>Option 1: Modify theme colors (affects all components):</p> <pre><code>// In core/ui/theme/Color.kt\nval LightColorScheme = lightColorScheme(\n    primary = Color(0xFF6200EE),\n    onBackground = Color(0xFF1C1B1F),\n    // ... other colors\n)\n</code></pre> <p>Option 2: Override colors for specific component instances:</p> <pre><code>JetpackButton(\n    onClick = { },\n    colors = ButtonDefaults.buttonColors(\n        containerColor = Color.Red // Override default\n    ),\n    content = { Text(\"Delete\") }\n)\n</code></pre>"},{"location":"components/#typography","title":"Typography","text":"<p>Components use Material 3 typography defined in <code>core/ui/src/main/kotlin/dev/atick/core/ui/theme/Type.kt</code>.</p> <p>Customizing Typography:</p> <pre><code>// In core/ui/theme/Type.kt\nval Typography = Typography(\n    bodyLarge = TextStyle(\n        fontFamily = FontFamily.Default,\n        fontWeight = FontWeight.Normal,\n        fontSize = 16.sp\n    ),\n    // ... other text styles\n)\n</code></pre>"},{"location":"components/#dynamic-color","title":"Dynamic Color","text":"<p>The app supports Material You dynamic colors. Enable in <code>SettingsScreen</code>:</p> <pre><code>// In feature/settings module\nsettingsViewModel.updateDynamicColorPreference(true)\n</code></pre> <p>Dynamic colors automatically adapt to the user's wallpaper (Android 12+).</p>"},{"location":"components/#accessibility-best-practices","title":"Accessibility Best Practices","text":""},{"location":"components/#content-descriptions","title":"Content Descriptions","text":"<p>Always provide content descriptions for icons:</p> <pre><code>Icon(\n    imageVector = Icons.Default.Home,\n    contentDescription = \"Navigate to home\" // \u2705 Good\n)\n\nIcon(\n    imageVector = Icons.Default.Home,\n    contentDescription = null // \u2705 Only for decorative icons\n)\n</code></pre> <p>Use semantic properties:</p> <pre><code>JetpackLoadingWheel(\n    contentDesc = \"Loading your data\" // \u2705 Describes what's loading\n)\n</code></pre>"},{"location":"components/#touch-targets","title":"Touch Targets","text":"<p>Ensure interactive elements meet minimum size requirements (48.dp):</p> <pre><code>IconButton(\n    onClick = { },\n    modifier = Modifier.size(48.dp) // \u2705 Meets minimum\n) {\n    Icon(Icons.Default.Close, contentDescription = \"Close\")\n}\n</code></pre>"},{"location":"components/#contrast","title":"Contrast","text":"<p>Components automatically use theme colors with sufficient contrast. Verify custom colors meet WCAG AA standards:</p> <ul> <li>Normal text: 4.5:1 contrast ratio</li> <li>Large text: 3:1 contrast ratio</li> </ul>"},{"location":"components/#custom-component-creation","title":"Custom Component Creation","text":"<p>When pre-built components don't meet your needs, create custom components following these patterns:</p>"},{"location":"components/#1-create-component-file","title":"1. Create Component File","text":"<p>Create in <code>core/ui/src/main/kotlin/dev/atick/core/ui/components/YourComponent.kt</code>:</p> <pre><code>/*\n * Copyright 2025 Your Name\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * ...\n */\n\npackage dev.atick.core.ui.components\n\nimport androidx.compose.runtime.Composable\nimport androidx.compose.ui.Modifier\n\n/**\n * Custom component description.\n *\n * @param param1 Parameter description\n * @param modifier Modifier to customize appearance\n */\n@Composable\nfun CustomComponent(\n    param1: String,\n    modifier: Modifier = Modifier\n) {\n    // Implementation\n}\n</code></pre>"},{"location":"components/#2-follow-material-3-patterns","title":"2. Follow Material 3 Patterns","text":"<p>Use Material 3 components as building blocks:</p> <pre><code>@Composable\nfun CustomCard(\n    title: String,\n    content: @Composable () -&gt; Unit,\n    modifier: Modifier = Modifier\n) {\n    Card(\n        modifier = modifier,\n        colors = CardDefaults.cardColors(\n            containerColor = MaterialTheme.colorScheme.surface\n        )\n    ) {\n        Column(modifier = Modifier.padding(16.dp)) {\n            Text(\n                text = title,\n                style = MaterialTheme.typography.titleMedium\n            )\n            Spacer(modifier = Modifier.height(8.dp))\n            content()\n        }\n    }\n}\n</code></pre>"},{"location":"components/#3-support-theming","title":"3. Support Theming","text":"<p>Always use <code>MaterialTheme</code> properties instead of hardcoded values:</p> <pre><code>// \u274c Bad\nText(text = \"Title\", color = Color(0xFF000000))\n\n// \u2705 Good\nText(\n    text = \"Title\",\n    color = MaterialTheme.colorScheme.onSurface\n)\n</code></pre>"},{"location":"components/#4-add-previews","title":"4. Add Previews","text":"<p>Use <code>@Preview</code> annotations for design iteration:</p> <pre><code>@PreviewDevices\n@PreviewThemes\n@Composable\nprivate fun CustomComponentPreview() {\n    JetpackTheme {\n        CustomComponent(param1 = \"Preview\")\n    }\n}\n</code></pre> <p>Preview Annotations:</p> <ul> <li><code>@PreviewDevices</code>: Shows component on multiple device sizes</li> <li><code>@PreviewThemes</code>: Shows component in light and dark themes</li> </ul>"},{"location":"components/#5-document-with-kdoc","title":"5. Document with KDoc","text":"<p>Provide comprehensive KDoc for all public components:</p> <pre><code>/**\n * A custom card component for displaying user information.\n *\n * Example usage:\n * ```\n\n* UserCard(\n*     name = \"John Doe\",\n*     email = \"john@example.com\"\n* )\n* ```\n*\n* @param name The user's display name\n* @param email The user's email address\n* @param modifier Modifier to be applied to the card\n  */\n  @Composable\n  fun UserCard(/* ... */) { /* ... */ }\n</code></pre>"},{"location":"components/#component-organization","title":"Component Organization","text":""},{"location":"components/#file-structure","title":"File Structure","text":"<pre><code>core/ui/src/main/kotlin/dev/atick/core/ui/\n\u251c\u2500\u2500 components/\n\u2502 \u251c\u2500\u2500 Button.kt # All button variants\n\u2502 \u251c\u2500\u2500 TextField.kt # All text field variants\n\u2502 \u251c\u2500\u2500 TopAppBar.kt # All app bar variants\n\u2502 \u251c\u2500\u2500 LoadingWheel.kt # Loading indicators\n\u2502 \u2514\u2500\u2500 ...\n\u251c\u2500\u2500 theme/\n\u2502 \u251c\u2500\u2500 Color.kt # Color definitions\n\u2502 \u251c\u2500\u2500 Type.kt # Typography\n\u2502 \u2514\u2500\u2500 Theme.kt # Theme setup\n\u2514\u2500\u2500 utils/\n\u2514\u2500\u2500 ... # UI utilities\n</code></pre>"},{"location":"components/#naming-conventions","title":"Naming Conventions","text":"<ul> <li>Component files: PascalCase, describe component type (e.g., <code>Button.kt</code>)</li> <li>Component functions: Prefixed with <code>Jetpack</code> (e.g., <code>JetpackButton</code>)</li> <li>Variants: Use descriptive suffixes (e.g., <code>JetpackOutlinedButton</code>)</li> <li>Private helpers: Standard Kotlin naming (e.g., <code>JetpackButtonContent</code>)</li> </ul>"},{"location":"components/#when-to-split-files","title":"When to Split Files","text":"<p>Create a new file when: - Component has multiple complex variants (3+ functions) - File exceeds ~300 lines - Component is unrelated to others in the file</p> <p>Keep in one file when: - Variants are closely related (e.g., filled/outlined/text buttons) - Total complexity is low - Components share private helpers</p>"},{"location":"components/#performance-considerations","title":"Performance Considerations","text":""},{"location":"components/#composition-optimization","title":"Composition Optimization","text":"<p>Use <code>remember</code> for expensive computations:</p> <pre><code>@Composable\nfun ExpensiveComponent(data: List&lt;Item&gt;) {\n    val processedData = remember(data) {\n        data.map { /* expensive transformation */ }\n    }\n    // Use processedData\n}\n</code></pre> <p>Avoid creating new lambdas in composition:</p> <pre><code>// \u274c Bad - Creates new lambda on each recomposition\nJetpackButton(\n    onClick = { viewModel.doSomething(item) },\n    text = { Text(\"Action\") }\n)\n\n// \u2705 Good - Stable reference\nval onClick = remember(item) {\n    { viewModel.doSomething(item) }\n}\nJetpackButton(\n    onClick = onClick,\n    text = { Text(\"Action\") }\n)\n</code></pre>"},{"location":"components/#lazylist-optimization","title":"LazyList Optimization","text":"<p>When using components in lists:</p> <pre><code>LazyColumn {\n    items(\n        items = itemList,\n        key = { it.id } // \u2705 Stable key for better performance\n    ) { item -&gt;\n        ItemCard(item = item)\n    }\n}\n</code></pre>"},{"location":"components/#image-loading_1","title":"Image Loading","text":"<p>Use <code>DynamicAsyncImage</code> for efficient image loading:</p> <pre><code>DynamicAsyncImage(\n    imageUrl = item.imageUrl,\n    contentDescription = item.title,\n    modifier = Modifier.size(100.dp)\n)\n</code></pre> <p>Features:</p> <ul> <li>Automatic memory and disk caching (Coil)</li> <li>Crossfade animations</li> <li>Placeholder and error handling</li> </ul>"},{"location":"components/#migration-from-xml-views","title":"Migration from XML Views","text":"<p>If migrating from XML to Compose, use these mappings:</p> XML View Jetpack Component <code>&lt;Button&gt;</code> <code>JetpackButton</code> <code>&lt;EditText&gt;</code> <code>JetpackTextFiled</code> <code>&lt;Toolbar&gt;</code> <code>JetpackTopAppBar</code> <code>&lt;ProgressBar&gt;</code> <code>JetpackLoadingWheel</code> <code>&lt;ImageView&gt;</code> <code>DynamicAsyncImage</code> <p>Example Migration:</p> <pre><code>&lt;!-- Before (XML) --&gt;\n&lt;Button android:id=\"@+id/submitButton\" android:layout_width=\"match_parent\"\n        android:layout_height=\"wrap_content\" android:text=\"@string/submit\"\n        android:onClick=\"onSubmitClick\" /&gt;\n</code></pre> <pre><code>// After (Compose)\nJetpackButton(\n    onClick = viewModel::onSubmitClick,\n    text = { Text(stringResource(R.string.submit)) },\n    modifier = Modifier.fillMaxWidth()\n)\n</code></pre>"},{"location":"components/#summary","title":"Summary","text":"<p>The component library provides:</p> <ul> <li>Consistent UI across your app with minimal effort</li> <li>Accessibility features built-in</li> <li>Material 3 theming and dynamic colors</li> <li>Flexibility through content slots and modifiers</li> <li>Performance optimizations for common patterns</li> </ul> <p>Follow the patterns in this guide to build beautiful, accessible, and performant UIs with minimal boilerplate.</p>"},{"location":"components/#further-reading","title":"Further Reading","text":""},{"location":"components/#concept-guides","title":"Concept Guides","text":"<ul> <li>Architecture Overview - Understand where components fit in the architecture</li> <li>State Management - Learn how to manage component state</li> <li>Adding Features - Step-by-step guide to building features with components</li> <li>Quick Reference - Cheat sheet for common component patterns</li> </ul>"},{"location":"components/#module-documentation","title":"Module Documentation","text":"<ul> <li>Core UI Module - Component architecture and state management utilities</li> <li>Feature Auth Module - Example of form components and authentication   UI</li> <li>Feature Home Module - Example of list components and data display</li> </ul>"},{"location":"components/#external-resources","title":"External Resources","text":"<ul> <li>Material 3 Guidelines - Official Material Design 3 documentation</li> </ul>"},{"location":"data-flow/","title":"Data Flow Guide","text":"<p>This guide explains how data flows through the application layers, covering different architectural patterns for network-only, local-only, and offline-first (network + local) data sources.</p>"},{"location":"data-flow/#table-of-contents","title":"Table of Contents","text":"<ol> <li>Architecture Overview</li> <li>Data Flow Patterns</li> <li>Network-Only Pattern</li> <li>Local-Only Pattern</li> <li>Offline-First Pattern (Network + Local)</li> <li>Real-Time Data Updates</li> <li>Caching Strategies</li> <li>Error Handling</li> </ol>"},{"location":"data-flow/#architecture-overview","title":"Architecture Overview","text":""},{"location":"data-flow/#two-layer-architecture","title":"Two-Layer Architecture","text":"<p>This template intentionally uses a simplified two-layer architecture (UI + Data) instead of the traditional three-layer approach. There is no domain layer by design to reduce complexity.</p> <pre><code>graph TB\n    subgraph UI[\"UI Layer (MVVM)\"]\n        VM[ViewModel&lt;br/&gt;- Manages UI state UiState&amp;ltScreenData&amp;gt&lt;br/&gt;- Calls repositories directly&lt;br/&gt;- Transforms data for UI]\n    end\n\n    subgraph Data[\"Data Layer\"]\n        Repo[Repository&lt;br/&gt;Interface + Implementation&lt;br/&gt;- Coordinates data sources&lt;br/&gt;- Implements business logic&lt;br/&gt;- Returns Flow&amp;ltT&amp;gt for reactive data&lt;br/&gt;- Returns Result&amp;ltT&amp;gt for one-shot operations]\n        Local[LocalDataSource&lt;br/&gt;Room]\n        Network[NetworkDataSource&lt;br/&gt;Retrofit]\n    end\n\n    UI --&gt;|Result&amp;lt T&amp;gt / Flow&amp;lt T&amp;gt| Data\n    Repo --&gt; Local\n    Repo --&gt; Network</code></pre>"},{"location":"data-flow/#unidirectional-data-flow","title":"Unidirectional Data Flow","text":"<p>Data flows in one direction through the layers:</p> <pre><code>graph LR\n    A[User Interaction] --&gt;|event| B[UI Layer]\n    B --&gt;|action| C[ViewModel]\n    C --&gt;|call| D[Repository]\n    D --&gt;|query| E[Data Sources]\n    E --&gt;|data| D\n    D --&gt;|Flow/Result| C\n    C --&gt;|StateFlow| B\n    B --&gt;|recompose| F[UI Rendered]</code></pre> <p>Flow Steps:</p> <ol> <li>User Interaction \u2192 UI Layer</li> <li>ViewModel \u2192 Calls Repository</li> <li>Repository \u2192 Coordinates Data Sources (Room/Retrofit/Firebase/DataStore)</li> <li>Data Sources \u2192 External Systems (Database/Network/Storage)</li> <li>Data flows back \u2192 Repository \u2192 ViewModel \u2192 UI</li> </ol>"},{"location":"data-flow/#key-principles","title":"Key Principles","text":"<ul> <li>Single Source of Truth: Local database (Room) is the source of truth for observable data</li> <li>Repositories Expose Flow: Observable data uses <code>Flow&lt;T&gt;</code>, one-shot operations use <code>Result&lt;T&gt;</code></li> <li>ViewModels Call Repositories Directly: No domain layer, repositories contain business logic</li> <li>Offline-First: Local data is displayed immediately, network updates happen in background</li> <li>Error Handling: Use <code>Result&lt;T&gt;</code> for error propagation, <code>suspendRunCatching</code> for repository   operations</li> </ul>"},{"location":"data-flow/#data-flow-patterns","title":"Data Flow Patterns","text":"<p>The template supports three main data flow patterns. Choose based on your feature requirements:</p> Pattern Use Case Data Source Example Network-Only Non-cacheable data, always fresh Retrofit API Weather data, stock prices Local-Only User preferences, settings Room or DataStore Theme preference, auth token Offline-First Core app data, sync required Room + Retrofit/Firebase User posts, profile data"},{"location":"data-flow/#network-only-pattern","title":"Network-Only Pattern","text":""},{"location":"data-flow/#when-to-use","title":"When to Use","text":"<ul> <li>Data must always be fresh (e.g., live sports scores, stock prices)</li> <li>Caching would provide stale or incorrect information</li> <li>Data is not critical for offline access</li> </ul>"},{"location":"data-flow/#architecture","title":"Architecture","text":"<pre><code>graph LR\n    VM[ViewModel] --&gt; Repo[Repository]\n    Repo --&gt; Network[NetworkDataSource&lt;br/&gt;Retrofit]\n    Network --&gt; API[API]\n    API --&gt;|Result&amp;ltT&amp;gt| Network\n    Network --&gt; Repo\n    Repo --&gt; VM</code></pre>"},{"location":"data-flow/#data-flow-diagram","title":"Data Flow Diagram","text":"<pre><code>sequenceDiagram\n    participant User\n    participant UI\n    participant VM as ViewModel\n    participant Repo as Repository\n    participant Network as NetworkDataSource\n    participant API\n    User -&gt;&gt; UI: Tap \"Refresh\"\n    UI -&gt;&gt; VM: loadWeather()\n    VM -&gt;&gt; Repo: getCurrentWeather()\n    Repo -&gt;&gt; Network: fetch()\n    Network -&gt;&gt; API: Retrofit call\n    API --&gt;&gt; Network: Weather data\n    Network --&gt;&gt; Repo: Result Weather\n    Repo --&gt;&gt; VM: Result Weather\n    VM -&gt;&gt; VM: Update UiState\n    VM --&gt;&gt; UI: StateFlow emits\n    UI -&gt;&gt; UI: Recompose with new data</code></pre>"},{"location":"data-flow/#key-characteristics","title":"Key Characteristics","text":"<ul> <li>No local caching - Data fetched directly from network</li> <li>Always fresh - Every request goes to the server</li> <li>No offline support - Requires active network connection</li> <li>Returns Result - One-shot operations for network calls <p>Note</p> <p>For complete repository implementation examples including interface definitions, data sources, and mapper functions, see the Data Module README.</p>"},{"location":"data-flow/#local-only-pattern","title":"Local-Only Pattern","text":""},{"location":"data-flow/#when-to-use_1","title":"When to Use","text":"<ul> <li>User preferences and settings</li> <li>Authentication tokens and session data</li> <li>Data that doesn't require network sync</li> <li>Small, simple key-value data</li> </ul>"},{"location":"data-flow/#architecture_1","title":"Architecture","text":"<pre><code>graph LR\n    VM[ViewModel] --&gt; Repo[Repository]\n    Repo --&gt; DS[DataStore / Room]\n    DS --&gt; Storage[(Local Storage)]\n    Storage --&gt;|Flow&amp;ltT&amp;gt| DS\n    DS --&gt; Repo\n    Repo --&gt; VM</code></pre>"},{"location":"data-flow/#data-flow-diagram_1","title":"Data Flow Diagram","text":"<pre><code>sequenceDiagram\n    participant User\n    participant UI\n    participant VM as ViewModel\n    participant Repo as Repository\n    participant DS as DataStore\n    Note over UI, DS: App Launch\n    UI -&gt;&gt; VM: observeSettings()\n    VM -&gt;&gt; Repo: observeSettings()\n    Repo -&gt;&gt; DS: Flow subscription\n    DS --&gt;&gt; Repo: Flow&amp;ltPreferences&amp;gt\n    Repo --&gt;&gt; VM: Flow emits\n    VM --&gt;&gt; UI: UiState updates\n    UI -&gt;&gt; UI: Render settings\n    Note over User, DS: User Changes Theme\n    User -&gt;&gt; UI: Select DARK theme\n    UI -&gt;&gt; VM: updateTheme(DARK)\n    VM -&gt;&gt; Repo: updateTheme(DARK)\n    Repo -&gt;&gt; DS: edit { ... }\n    DS -&gt;&gt; DS: Persist change\n    DS --&gt;&gt; Repo: Flow emits new prefs\n    Repo --&gt;&gt; VM: Flow emits\n    VM --&gt;&gt; UI: UiState updates\n    UI -&gt;&gt; UI: Update automatically</code></pre>"},{"location":"data-flow/#key-characteristics_1","title":"Key Characteristics","text":"<ul> <li>Fully offline - No network dependency</li> <li>Reactive with Flow - UI automatically updates when data changes</li> <li>Immediate persistence - Changes saved to local storage instantly</li> <li>DataStore for preferences - Type-safe, reactive preferences storage</li> <li>Room for complex data - Use Room if data structure is complex</li> </ul> <p>Tip</p> <p>Use DataStore for simple key-value preferences and Room for structured local data with relationships.</p>"},{"location":"data-flow/#offline-first-pattern-network-local","title":"Offline-First Pattern (Network + Local)","text":""},{"location":"data-flow/#when-to-use_2","title":"When to Use","text":"<ul> <li>Core application data (posts, messages, user profiles)</li> <li>Data needed offline</li> <li>Data that syncs with a server</li> <li>Multi-device synchronization required</li> </ul>"},{"location":"data-flow/#architecture_2","title":"Architecture","text":"<pre><code>graph TB\n    VM[ViewModel]\n    Repo[Repository&lt;br/&gt;Single Source of Truth]\n    Local[LocalDataSource&lt;br/&gt;Room Database]\n    Network[NetworkDataSource&lt;br/&gt;Retrofit/Firebase]\n    DB[(Local Database&lt;br/&gt;SQLite)]\n    API[Remote API&lt;br/&gt;Firestore]\n    VM --&gt;|observeData| Repo\n    Repo --&gt;|Flow&amp;ltT&amp;gt| VM\n    Repo --&gt;|observes| Local\n    Local --&gt;|Flow&amp;ltEntity&amp;gt| Repo\n    Repo -. sync .-&gt; Network\n    Network -. fetch .-&gt; API\n    Local &lt;--&gt;|read/write| DB\n    Network --&gt; Local</code></pre>"},{"location":"data-flow/#key-concepts","title":"Key Concepts","text":"<ol> <li>Room is the Single Source of Truth: UI always observes local database</li> <li>Network Updates Background: Fetch from network, update local database</li> <li>Sync Metadata: Track sync state (lastUpdated, lastSynced, needsSync)</li> <li>Soft Deletes: Mark as deleted locally, sync deletion, then remove</li> </ol>"},{"location":"data-flow/#data-flow-diagram_2","title":"Data Flow Diagram","text":"<pre><code>sequenceDiagram\n    participant User\n    participant UI\n    participant VM as ViewModel\n    participant Repo as Repository\n    participant Local as LocalDataSource\n    participant Network as NetworkDataSource\n    participant DB as Room Database\n    participant API\n    Note over User, API: App Launch / User Navigates\n    UI -&gt;&gt; VM: observePosts()\n    VM -&gt;&gt; Repo: observePosts()\n    Repo -&gt;&gt; Repo: Trigger sync (background)\n    Repo -&gt;&gt; Local: observePosts()\n    Local -&gt;&gt; DB: Query\n    DB --&gt;&gt; Local: Flow&amp;ltList&amp;ltPostEntity&amp;gt&amp;gt\n    Local --&gt;&gt; Repo: Flow emits\n    Repo -&gt;&gt; Repo: Map to domain\n    Repo --&gt;&gt; VM: Flow&amp;ltList&amp;ltPost&amp;gt&amp;gt\n    VM -&gt;&gt; VM: Update UiState\n    VM --&gt;&gt; UI: StateFlow emits\n    UI -&gt;&gt; UI: Display posts (offline-first!)\n    Note over Repo, API: Background Sync\n    par Push Local Changes\n        Repo -&gt;&gt; Local: Get unsynced posts\n        Local --&gt;&gt; Repo: Unsynced items\n        Repo -&gt;&gt; Network: UPSERT/DELETE\n        Network -&gt;&gt; API: Push changes\n        Repo -&gt;&gt; Local: Mark as synced\n    and Pull Remote Changes\n        Repo -&gt;&gt; Local: Get lastSyncTimestamp\n        Local --&gt;&gt; Repo: Timestamp\n        Repo -&gt;&gt; Network: Fetch since timestamp\n        Network -&gt;&gt; API: GET updated posts\n        API --&gt;&gt; Network: Remote posts\n        Network --&gt;&gt; Repo: Remote data\n        Repo -&gt;&gt; Local: Upsert to database\n        Local -&gt;&gt; DB: Save\n    end\n\n    DB --&gt;&gt; Local: Flow emits updated\n    Local --&gt;&gt; Repo: Updated data\n    Repo --&gt;&gt; VM: Flow emits\n    VM --&gt;&gt; UI: UI updates (reactive!)</code></pre>"},{"location":"data-flow/#key-characteristics_2","title":"Key Characteristics","text":"<ul> <li>Room as Single Source of Truth - UI always observes local database</li> <li>Immediate UI updates - Local changes reflected instantly</li> <li>Background synchronization - Network sync happens asynchronously</li> <li>Conflict resolution - Last-write-wins (server timestamp based)</li> <li>Bidirectional sync - Push local changes, pull remote changes</li> <li>Incremental sync - Only fetch data modified since last sync</li> </ul> <p>Important</p> <p>The offline-first pattern requires careful sync metadata tracking. Always include <code>lastUpdated</code>,</p> <p><code>lastSynced</code>, <code>needsSync</code>, and <code>syncAction</code> fields in your Room entities.</p> <p>For detailed offline-first repository implementation with sync metadata, see the Data Module README.</p>"},{"location":"data-flow/#real-time-data-updates","title":"Real-Time Data Updates","text":"<p>For real-time updates (e.g., Firebase Firestore snapshots, WebSocket), use Firebase's snapshot listeners or similar mechanisms.</p>"},{"location":"data-flow/#firebase-firestore-real-time-flow","title":"Firebase Firestore Real-Time Flow","text":"<pre><code>sequenceDiagram\n    participant Firestore as Firebase Firestore&lt;br/&gt;(Cloud)\n    participant Listener as Snapshot Listener\n    participant Flow as callbackFlow\n    participant Repo as Repository\n    participant Room as Local Database&lt;br/&gt;(Room)\n    participant VM as ViewModel\n    participant UI\n    Firestore -&gt;&gt; Listener: Data change\n    Listener -&gt;&gt; Flow: Emit snapshot\n    Flow -&gt;&gt; Repo: Observe changes\n    Repo -&gt;&gt; Room: Update local data\n    Room -&gt;&gt; Room: Persist\n    Room --&gt;&gt; Repo: Flow emits\n    Repo --&gt;&gt; VM: Flow&amp;ltData&amp;gt\n    VM -&gt;&gt; VM: Update UiState\n    VM --&gt;&gt; UI: StateFlow emits\n    UI -&gt;&gt; UI: Render updates</code></pre>"},{"location":"data-flow/#key-pattern-firestore-room-ui","title":"Key Pattern: Firestore \u2192 Room \u2192 UI","text":"<p>Even with real-time updates, maintain Room as the single source of truth:</p> <ol> <li>Firestore snapshot listener emits changes</li> <li>Repository updates local Room database</li> <li>UI observes Room Flow (not Firestore directly)</li> <li>Result: Consistent data access pattern across app</li> </ol> <p>This approach ensures:</p> <ul> <li>Offline access to last known data</li> <li>Consistent data access APIs</li> <li>Easy testing (mock Room, not Firestore)</li> <li>Works even if Firebase connection fails</li> </ul> <p>Note</p> <p>For Firebase Firestore integration examples, see the Firebase Module README.</p>"},{"location":"data-flow/#caching-strategies","title":"Caching Strategies","text":""},{"location":"data-flow/#1-time-based-cache-invalidation","title":"1. Time-Based Cache Invalidation","text":"<p>Fetch fresh data from network if cache is older than a threshold.</p> <p>Flow:</p> <pre><code>graph TD\n    Start[Repository called] --&gt; Check{Check lastSyncTimestamp}\n    Check --&gt; Stale{Is cache stale?&lt;br/&gt;current time - lastSync &gt; threshold}\n    Stale --&gt;|YES| Sync[Trigger background sync]\n    Stale --&gt;|NO| Use[Use cached data]\n    Sync --&gt; Emit[Emit local data immediately]\n    Use --&gt; Emit\n    Emit --&gt; End[offline-first!]</code></pre> <p>Use When:</p> <ul> <li>Data changes infrequently</li> <li>Staleness tolerance is acceptable (e.g., 5 minutes)</li> <li>Want to reduce network calls</li> </ul>"},{"location":"data-flow/#2-manual-refresh-pull-to-refresh","title":"2. Manual Refresh (Pull-to-Refresh)","text":"<p>Allow user to manually trigger sync.</p> <p>Flow:</p> <pre><code>sequenceDiagram\n    participant User\n    participant UI\n    participant VM as ViewModel\n    participant Repo as Repository\n    participant Network\n    participant Room as Local Database\n    User -&gt;&gt; UI: Pull to refresh\n    UI -&gt;&gt; VM: refreshPosts()\n    VM -&gt;&gt; VM: Set loading state\n    VM -&gt;&gt; Repo: syncPosts()\n    Repo -&gt;&gt; Network: Fetch from network\n    Network --&gt;&gt; Repo: Fresh data\n    Repo -&gt;&gt; Room: Update local database\n    Room -&gt;&gt; Room: Persist\n    Room --&gt;&gt; Repo: Flow emits updated\n    Repo --&gt;&gt; VM: Updated data\n    VM -&gt;&gt; VM: Clear loading state\n    VM --&gt;&gt; UI: UiState updates\n    UI -&gt;&gt; UI: Dismiss loading indicator</code></pre> <p>Use When:</p> <ul> <li>User wants to ensure fresh data</li> <li>Complementary to time-based caching</li> <li>Provides user control</li> </ul>"},{"location":"data-flow/#3-network-bound-resource-pattern","title":"3. Network-Bound Resource Pattern","text":"<p>Utility for coordinating network + local data with automatic caching.</p> <p>Flow:</p> <pre><code>graph TD\n    Start[Network-Bound Resource] --&gt; Loading1[1. Emit Loading state]\n    Loading1 --&gt; Query[2. Query local database]\n    Query --&gt; Loading2[3. Emit Loading with local data]\n    Loading2 --&gt; ShouldFetch{4. Should fetch&lt;br/&gt;from network?}\n    ShouldFetch --&gt;|YES| Fetch[Fetch from network]\n    Fetch --&gt; Save[Save to local database]\n    Save --&gt; Success[Emit Success with fresh data]\n    ShouldFetch --&gt;|NO| CachedSuccess[Emit Success with cached data]\n    Fetch -. Network Error .-&gt; Error[Emit Error&lt;br/&gt;with stale local data]</code></pre> <p>Use When:</p> <ul> <li>Want automatic cache-then-network pattern</li> <li>Need loading states with cached data</li> <li>Want to show stale data on network errors</li> </ul> <p>Note</p> <p>For <code>networkBoundResource</code> implementation and usage examples, see the Data Module README.</p>"},{"location":"data-flow/#error-handling","title":"Error Handling","text":"<p>All data layer operations use a layered error handling approach with <code>Result&lt;T&gt;</code> for error propagation:</p> <ul> <li>Repository Layer: Uses <code>suspendRunCatching</code> to wrap all operations</li> <li>ViewModel Layer: Uses <code>updateStateWith</code>/<code>updateWith</code> for automatic error capture</li> <li>UI Layer: Uses <code>StatefulComposable</code> for automatic error display via snackbar</li> </ul>"},{"location":"data-flow/#error-flow-diagram","title":"Error Flow Diagram","text":"<pre><code>graph TD\n    Start[Repository Operation] --&gt; Catch[suspendRunCatching]\n    Catch --&gt; Result{Success or Failure}\n    Result --&gt; Return[Result&amp;ltT&amp;gt]\n    Return --&gt; VM[ViewModel]\n    VM --&gt; Update[updateStateWith/&lt;br/&gt;updateWith]\n    Update --&gt; Auto[Auto-handle Result]\n    Auto --&gt; UiState[UiState&lt;br/&gt;data or error]\n    UiState --&gt; Stateful[StatefulComposable]\n    Stateful --&gt; Display{Display}\n    Display --&gt;|Success| Content[Show content]\n    Display --&gt;|Error| Snackbar[Show error snackbar]</code></pre> <p>For comprehensive error handling patterns including network-specific errors, HTTP error codes, and detailed examples, see:</p> <p>Note</p> <p>Complete error handling documentation is available in the Data Module README.</p>"},{"location":"data-flow/#summary","title":"Summary","text":"<p>This guide covered three main data flow patterns:</p> <ul> <li>Network-Only: For real-time data that doesn't need offline access (weather, stock prices)</li> <li>Local-Only: For preferences and settings using DataStore (theme, notifications)</li> <li>Offline-First: For user-generated content with Room as single source of truth (posts,   profiles)</li> </ul> <p>Key Takeaways:</p> <ol> <li>Choose the Right Pattern based on feature requirements</li> <li>Room is the Single Source of Truth for offline-first - UI observes local database, network    updates happen in background</li> <li>Use Proper Threading - Inject <code>@IoDispatcher</code> and use <code>withContext(ioDispatcher)</code> for    blocking calls</li> <li>Error Handling is Centralized - Repository uses <code>suspendRunCatching</code>, ViewModel uses    <code>updateStateWith</code>/<code>updateWith</code>, UI uses <code>StatefulComposable</code></li> <li>Flow for Reactive Data - Observe local database with Flow, UI updates automatically</li> <li>Result for Operations - One-shot operations return Result for error handling <p>All patterns use Repositories as the interface to ViewModels, Data Sources for external system interaction, Result type for error handling, and Flow for reactive data streams.</p>"},{"location":"data-flow/#further-reading","title":"Further Reading","text":"<ul> <li>Data Module README - Repository patterns, implementations, and error handling   reference</li> <li>State Management - Learn about ViewModel state patterns</li> <li>Architecture Overview - Understand the two-layer architecture</li> <li>Adding Features - Step-by-step implementation guide</li> <li>Quick Reference - Common data flow patterns cheat sheet</li> </ul>"},{"location":"dependency-injection/","title":"Dependency Injection Guide","text":"<p>This guide covers how dependency injection (DI) works in this template using Dagger Hilt. All examples are based on the actual implementation patterns used throughout the codebase.</p>"},{"location":"dependency-injection/#overview","title":"Overview","text":"<p>This template uses Dagger Hilt for dependency injection, which is the recommended DI solution for Android. Hilt is built on top of Dagger and provides:</p> <ul> <li>Simplified setup with convention-based configuration</li> <li>Integration with Android components (Activity, ViewModel, Worker, etc.)</li> <li>Compile-time safety and performance</li> <li>Automatic dependency graph generation</li> <li>Scoping strategies for managing object lifecycles</li> </ul>"},{"location":"dependency-injection/#quick-start","title":"Quick Start","text":""},{"location":"dependency-injection/#1-enable-hilt-in-your-module","title":"1. Enable Hilt in Your Module","text":"<p>All modules that need DI apply the Hilt convention plugin:</p> <pre><code>// feature/home/build.gradle.kts\nplugins {\n    alias(libs.plugins.jetpack.ui.library)\n    alias(libs.plugins.jetpack.dagger.hilt) // Add this\n    alias(libs.plugins.jetpack.dokka)\n}\n</code></pre> <p>The <code>jetpack.dagger.hilt</code> convention plugin automatically:</p> <ul> <li>Applies <code>com.google.dagger.hilt.android</code> plugin</li> <li>Applies <code>com.google.devtools.ksp</code> plugin</li> <li>Adds Hilt runtime and compiler dependencies</li> </ul>"},{"location":"dependency-injection/#2-annotate-your-application-class","title":"2. Annotate Your Application Class","text":"<p>The <code>Application</code> class must be annotated with <code>@HiltAndroidApp</code>:</p> <pre><code>@HiltAndroidApp\nclass JetpackApplication : Application() {\n    override fun onCreate() {\n        super.onCreate()\n        // Hilt is automatically initialized before this\n    }\n}\n</code></pre>"},{"location":"dependency-injection/#3-inject-into-android-components","title":"3. Inject into Android Components","text":"<p>Use <code>@AndroidEntryPoint</code> on Activities, Fragments, etc., and <code>@Inject</code> for field injection:</p> <pre><code>@AndroidEntryPoint\nclass MainActivity : AppCompatActivity() {\n\n    @Inject\n    lateinit var networkUtils: NetworkUtils\n\n    @Inject\n    lateinit var crashReporter: CrashReporter\n\n    override fun onCreate(savedInstanceState: Bundle?) {\n        super.onCreate(savedInstanceState)\n        // Dependencies are injected before onCreate()\n        // You can use networkUtils and crashReporter here\n    }\n}\n</code></pre>"},{"location":"dependency-injection/#4-inject-into-viewmodels","title":"4. Inject into ViewModels","text":"<p>Use <code>@HiltViewModel</code> and constructor injection:</p> <pre><code>@HiltViewModel\nclass SettingsViewModel @Inject constructor(\n    private val settingsRepository: SettingsRepository,\n) : ViewModel() {\n    // Repository is automatically injected\n}\n</code></pre>"},{"location":"dependency-injection/#core-concepts","title":"Core Concepts","text":""},{"location":"dependency-injection/#binds-vs-provides","title":"@Binds vs @Provides","text":"<p>Hilt modules use two different methods for providing dependencies:</p>"},{"location":"dependency-injection/#binds-preferred-for-interfaces","title":"@Binds (Preferred for Interfaces)","text":"<p>Use <code>@Binds</code> when you have an interface and a single implementation. It's more efficient than <code>@Provides</code> because it generates less code.</p> <p>Pattern:</p> <pre><code>@Module\n@InstallIn(SingletonComponent::class)\nabstract class RepositoryModule {\n\n    @Binds\n    @Singleton\n    internal abstract fun bindAuthRepository(\n        authRepositoryImpl: AuthRepositoryImpl\n    ): AuthRepository\n}\n</code></pre> <p>Real Example from <code>data/src/main/kotlin/dev/atick/data/di/RepositoryModule.kt</code>:</p> <pre><code>@Module\n@InstallIn(SingletonComponent::class)\nabstract class RepositoryModule {\n    @Binds\n    @Singleton\n    internal abstract fun bindAuthRepository(\n        authRepositoryImpl: AuthRepositoryImpl,\n    ): AuthRepository\n\n    @Binds\n    @Singleton\n    internal abstract fun bindHomeRepository(\n        homeRepositoryImpl: HomeRepositoryImpl,\n    ): HomeRepository\n\n    // ... more bindings\n}\n</code></pre> <p>When to use:</p> <ul> <li>Binding interfaces to implementations</li> <li>When the implementation has <code>@Inject constructor</code></li> <li>When you don't need any custom logic to create the object</li> </ul>"},{"location":"dependency-injection/#provides-for-complex-construction","title":"@Provides (For Complex Construction)","text":"<p>Use <code>@Provides</code> when you need custom logic to create objects, or when the type can't have <code>@Inject</code> on its constructor (e.g., third-party libraries, builders).</p> <p>Real Example from <code>core/room/src/main/kotlin/dev/atick/core/room/di/DatabaseModule.kt</code>:</p> <pre><code>@Module\n@InstallIn(SingletonComponent::class)\nobject DatabaseModule {\n\n    private const val ROOM_DATABASE_NAME = \"dev.atick.jetpack.room\"\n\n    @Singleton\n    @Provides\n    fun provideRoomDatabase(\n        @ApplicationContext appContext: Context,\n    ): JetpackDatabase {\n        return Room.databaseBuilder(\n            appContext,\n            JetpackDatabase::class.java,\n            ROOM_DATABASE_NAME,\n        ).fallbackToDestructiveMigration(true).build()\n    }\n}\n</code></pre> <p>Real Example from <code>core/network/src/main/kotlin/dev/atick/core/network/di/retrofit/RetrofitModule.kt</code>:</p> <pre><code>@Module(\n    includes = [\n        OkHttpClientModule::class,\n    ],\n)\n@InstallIn(SingletonComponent::class)\nobject RetrofitModule {\n\n    @Singleton\n    @Provides\n    fun provideRetrofitClient(\n        converterFactory: Converter.Factory,\n        okHttpClient: OkHttpClient,\n    ): Retrofit {\n        return Retrofit.Builder()\n            .baseUrl(BuildConfig.BACKEND_URL)\n            .addConverterFactory(converterFactory)\n            .client(okHttpClient)\n            .build()\n    }\n}\n</code></pre> <p>When to use:</p> <ul> <li>Creating objects with builders (Retrofit, Room, OkHttp)</li> <li>Third-party library types</li> <li>Objects requiring complex initialization logic</li> <li>When you need to use <code>@ApplicationContext</code> or other qualifiers</li> </ul>"},{"location":"dependency-injection/#scoping","title":"Scoping","text":"<p>Scoping controls the lifecycle of dependencies. This template uses three main scopes:</p>"},{"location":"dependency-injection/#singleton-application-scope","title":"@Singleton (Application Scope)","text":"<p>Objects live as long as the application process.</p> <p>Example:</p> <pre><code>@Binds\n@Singleton\ninternal abstract fun bindAuthRepository(\n    authRepositoryImpl: AuthRepositoryImpl,\n): AuthRepository\n</code></pre> <p>Use for:</p> <ul> <li>Repositories</li> <li>Data sources (Room DAOs, Retrofit services, DataStore)</li> <li>Network clients (OkHttp, Retrofit)</li> <li>Utilities (CrashReporter, NetworkUtils)</li> </ul>"},{"location":"dependency-injection/#viewmodelscoped","title":"@ViewModelScoped","text":"<p>Objects live as long as the ViewModel. Useful for dependencies that should be recreated when the ViewModel is recreated.</p> <p>Example:</p> <pre><code>@Provides\n@ViewModelScoped\nfun provideSpecialUseCase(): SpecialUseCase {\n    return SpecialUseCase()\n}\n</code></pre>"},{"location":"dependency-injection/#activityscoped","title":"@ActivityScoped","text":"<p>Objects live as long as the Activity. Less commonly used in this template.</p>"},{"location":"dependency-injection/#qualifier-annotations","title":"Qualifier Annotations","text":"<p>Qualifiers differentiate between multiple instances of the same type.</p> <p>Real Example from <code>core/android/src/main/kotlin/dev/atick/core/di/DispatcherModule.kt</code>:</p> <pre><code>@Module\n@InstallIn(SingletonComponent::class)\nobject DispatcherModule {\n    @DefaultDispatcher\n    @Provides\n    fun providesDefaultDispatcher(): CoroutineDispatcher = Dispatchers.Default\n\n    @IoDispatcher\n    @Provides\n    fun providesIoDispatcher(): CoroutineDispatcher = Dispatchers.IO\n\n    @MainDispatcher\n    @Provides\n    fun providesMainDispatcher(): CoroutineDispatcher = Dispatchers.Main\n}\n\n@Retention(AnnotationRetention.BINARY)\n@Qualifier\nannotation class DefaultDispatcher\n\n@Retention(AnnotationRetention.BINARY)\n@Qualifier\nannotation class IoDispatcher\n\n@Retention(AnnotationRetention.BINARY)\n@Qualifier\nannotation class MainDispatcher\n</code></pre> <p>Usage in Data Source:</p> <pre><code>class NetworkDataSourceImpl @Inject constructor(\n    private val restApi: RestApi,\n    @IoDispatcher private val ioDispatcher: CoroutineDispatcher,\n) : NetworkDataSource {\n\n    override suspend fun getData(): List&lt;JetpackDto&gt; = withContext(ioDispatcher) {\n        restApi.getData()\n    }\n}\n</code></pre> <p>When to create qualifiers:</p> <ul> <li>Multiple instances of the same type with different configurations</li> <li>Different implementations of the same interface for different purposes</li> <li>Named instances (like different dispatchers, different databases)</li> </ul>"},{"location":"dependency-injection/#injection-patterns","title":"Injection Patterns","text":""},{"location":"dependency-injection/#constructor-injection-preferred","title":"Constructor Injection (Preferred)","text":"<p>This is the most common and recommended pattern. Works for:</p> <ul> <li>ViewModels (<code>@HiltViewModel</code>)</li> <li>Repositories</li> <li>Data sources</li> <li>Any class you control</li> </ul> <p>ViewModel Example:</p> <pre><code>@HiltViewModel\nclass SettingsViewModel @Inject constructor(\n    private val settingsRepository: SettingsRepository,\n) : ViewModel() {\n    // Use settingsRepository\n}\n</code></pre> <p>Repository Example:</p> <pre><code>internal class AuthRepositoryImpl @Inject constructor(\n    private val authDataSource: AuthDataSource,\n    private val userPreferencesDataSource: UserPreferencesDataSource,\n) : AuthRepository {\n    // Use data sources\n}\n</code></pre> <p>Data Source Example:</p> <pre><code>class FirebaseDataSourceImpl @Inject constructor(\n    private val firestore: FirebaseFirestore,\n    @IoDispatcher private val ioDispatcher: CoroutineDispatcher,\n) : FirebaseDataSource {\n    // Use firestore and ioDispatcher\n}\n</code></pre>"},{"location":"dependency-injection/#field-injection","title":"Field Injection","text":"<p>Used for Android framework components where you can't control constructor.</p> <p>Activity Example from <code>app/src/main/kotlin/dev/atick/compose/MainActivity.kt</code>:</p> <pre><code>@AndroidEntryPoint\nclass MainActivity : AppCompatActivity() {\n\n    @Inject\n    lateinit var networkUtils: NetworkUtils\n\n    @Inject\n    lateinit var crashReporter: CrashReporter\n\n    private val viewModel: MainActivityViewModel by viewModels()\n\n    override fun onCreate(savedInstanceState: Bundle?) {\n        super.onCreate(savedInstanceState)\n        // networkUtils and crashReporter are now injected\n    }\n}\n</code></pre> <p>Important</p> <p>Field Injection Requirements: - Use <code>lateinit var</code> for field injection - Fields must not be private - Injection happens before <code>onCreate()</code> for Activities - For ViewModels, use <code>by viewModels()</code> delegate (Hilt integration)</p>"},{"location":"dependency-injection/#assistedinject-for-workers","title":"AssistedInject (For Workers)","text":"<p>WorkManager Workers need special handling because they receive runtime parameters from WorkManager.</p> <p>Real Example from <code>sync/src/main/kotlin/dev/atick/sync/worker/SyncWorker.kt</code>:</p> <pre><code>@HiltWorker\nclass SyncWorker @AssistedInject constructor(\n    @Assisted private val context: Context,\n    @Assisted workerParameters: WorkerParameters,\n    @IoDispatcher private val ioDispatcher: CoroutineDispatcher,\n    private val homeRepository: HomeRepository,\n) : CoroutineWorker(context, workerParameters) {\n\n    override suspend fun doWork(): Result {\n        // Use injected dependencies\n        return withContext(ioDispatcher) {\n            homeRepository.sync()\n            Result.success()\n        }\n    }\n}\n</code></pre> <p>Key Points:</p> <ul> <li>Use <code>@HiltWorker</code> annotation</li> <li>Use <code>@AssistedInject</code> for constructor</li> <li>Mark WorkManager-provided params with <code>@Assisted</code></li> <li>Regular dependencies are injected normally</li> </ul> <p>Note</p> <p>You must also use <code>DelegatingWorker</code> when enqueuing:</p> <pre><code>fun startUpSyncWork(): OneTimeWorkRequest {\n    return OneTimeWorkRequestBuilder&lt;DelegatingWorker&gt;()\n        .setExpedited(OutOfQuotaPolicy.RUN_AS_NON_EXPEDITED_WORK_REQUEST)\n        .setConstraints(SyncConstraints)\n        .setInputData(SyncWorker::class.delegatedData())\n        .build()\n}\n</code></pre>"},{"location":"dependency-injection/#module-organization","title":"Module Organization","text":"<p>Modules are organized by layer and purpose. Each module contains a <code>di/</code> package with Hilt modules.</p>"},{"location":"dependency-injection/#core-module-di-structure","title":"Core Module DI Structure","text":"<ul> <li><code>core/android/src/main/kotlin/dev/atick/core/di/</code><ul> <li><code>DispatcherModule.kt</code> - Coroutine dispatchers</li> <li><code>CoroutineModule.kt</code> - CoroutineScope</li> <li><code>StringDecoderModule.kt</code> - URI decoder</li> </ul> </li> <li><code>core/network/src/main/kotlin/dev/atick/core/network/di/</code><ul> <li><code>retrofit/</code><ul> <li><code>RetrofitModule.kt</code> - Retrofit instance</li> <li><code>ConverterModule.kt</code> - JSON converter</li> </ul> </li> <li><code>okhttp/</code><ul> <li><code>OkHttpClientModule.kt</code> - OkHttp client</li> <li><code>InterceptorModule.kt</code> - Interceptors</li> </ul> </li> <li><code>coil/</code><ul> <li><code>CoilModule.kt</code> - Image loader</li> </ul> </li> <li><code>NetworkUtilsModule.kt</code> - Network utilities</li> <li><code>DataSourceModule.kt</code> - Network data source</li> </ul> </li> <li><code>core/room/src/main/kotlin/dev/atick/core/room/di/</code><ul> <li><code>DatabaseModule.kt</code> - Room database</li> <li><code>DaoModule.kt</code> - DAOs</li> <li><code>DataSourceModule.kt</code> - Local data source</li> </ul> </li> <li><code>core/preferences/src/main/kotlin/dev/atick/core/preferences/di/</code><ul> <li><code>DatastoreModule.kt</code> - DataStore</li> <li><code>PreferencesDataSourceModule.kt</code> - Preferences data source</li> </ul> </li> </ul>"},{"location":"dependency-injection/#data-module-di-structure","title":"Data Module DI Structure","text":"<ul> <li><code>data/src/main/kotlin/dev/atick/data/di/</code><ul> <li><code>RepositoryModule.kt</code> - All repository bindings</li> </ul> </li> </ul>"},{"location":"dependency-injection/#firebase-module-di-structure","title":"Firebase Module DI Structure","text":"<ul> <li><code>firebase/analytics/src/main/kotlin/dev/atick/firebase/analytics/di/</code><ul> <li><code>FirebaseModule.kt</code> - Firebase Analytics</li> <li><code>CrashlyticsModule.kt</code> - CrashReporter</li> </ul> </li> <li><code>firebase/auth/src/main/kotlin/dev/atick/firebase/auth/di/</code><ul> <li><code>FirebaseAuthModule.kt</code> - Firebase Auth</li> <li><code>CredentialManagerModule.kt</code> - Credential Manager</li> <li><code>DataSourceModule.kt</code> - Auth data source</li> </ul> </li> <li><code>firebase/firestore/src/main/kotlin/dev/atick/firebase/firestore/di/</code><ul> <li><code>FirebaseModule.kt</code> - Firestore instance</li> <li><code>DataSourceModule.kt</code> - Firestore data source</li> </ul> </li> </ul>"},{"location":"dependency-injection/#sync-module-di-structure","title":"Sync Module DI Structure","text":"<ul> <li><code>sync/src/main/kotlin/dev/atick/sync/di/</code><ul> <li><code>SyncModule.kt</code> - SyncManager binding</li> </ul> </li> </ul>"},{"location":"dependency-injection/#module-inclusion-pattern","title":"Module Inclusion Pattern","text":"<p>Modules can include other modules to establish dependencies:</p> <p>Example from <code>core/room/di/DaoModule.kt</code>:</p> <pre><code>@Module(\n    includes = [\n        DatabaseModule::class,\n    ],\n)\n@InstallIn(SingletonComponent::class)\nobject DaoModule {\n\n    @Singleton\n    @Provides\n    fun provideJetpackDao(jetpackDatabase: JetpackDatabase) =\n        jetpackDatabase.getJetpackDao()\n}\n</code></pre> <p>This ensures <code>DatabaseModule</code> is processed before <code>DaoModule</code>, so the database is available when creating the DAO.</p>"},{"location":"dependency-injection/#common-patterns","title":"Common Patterns","text":""},{"location":"dependency-injection/#pattern-1-repository-with-multiple-data-sources","title":"Pattern 1: Repository with Multiple Data Sources","text":"<p>Real Example from <code>data/src/main/kotlin/dev/atick/data/repository/auth/AuthRepositoryImpl.kt</code>:</p> <pre><code>internal class AuthRepositoryImpl @Inject constructor(\n    private val authDataSource: AuthDataSource,\n    private val userPreferencesDataSource: UserPreferencesDataSource,\n) : AuthRepository {\n\n    override suspend fun signInWithEmailAndPassword(\n        email: String,\n        password: String,\n    ): Result&lt;Unit&gt; {\n        return suspendRunCatching {\n            val user = authDataSource.signInWithEmailAndPassword(email, password)\n            userPreferencesDataSource.setUserProfile(user.asPreferencesUserProfile())\n        }\n    }\n}\n</code></pre> <p>Binding:</p> <pre><code>@Binds\n@Singleton\ninternal abstract fun bindAuthRepository(\n    authRepositoryImpl: AuthRepositoryImpl,\n): AuthRepository\n</code></pre>"},{"location":"dependency-injection/#pattern-2-datastore-with-dispatcher","title":"Pattern 2: DataStore with Dispatcher","text":"<p>Real Example from <code>core/preferences/di/DatastoreModule.kt</code>:</p> <pre><code>@Module\n@InstallIn(SingletonComponent::class)\nobject DatastoreModule {\n\n    private const val DATA_STORE_FILE_NAME = \"user_preferences.json\"\n\n    @Singleton\n    @Provides\n    fun providePreferencesDataStore(\n        @ApplicationContext appContext: Context,\n        @IoDispatcher ioDispatcher: CoroutineDispatcher,\n    ): DataStore&lt;UserDataPreferences&gt; {\n        return DataStoreFactory.create(\n            serializer = UserDataSerializer,\n            produceFile = { appContext.dataStoreFile(DATA_STORE_FILE_NAME) },\n            scope = CoroutineScope(ioDispatcher + SupervisorJob()),\n        )\n    }\n}\n</code></pre> <p>Key points:</p> <ul> <li>Uses <code>@ApplicationContext</code> qualifier for Context</li> <li>Uses <code>@IoDispatcher</code> qualifier for CoroutineDispatcher</li> <li>Creates DataStore with custom scope on IO dispatcher</li> </ul>"},{"location":"dependency-injection/#pattern-3-android-system-service","title":"Pattern 3: Android System Service","text":"<p>Real Example from <code>firebase/auth/di/CredentialManagerModule.kt</code>:</p> <pre><code>@Module\n@InstallIn(SingletonComponent::class)\nobject CredentialManagerModule {\n\n    @Provides\n    @Singleton\n    fun provideCredentialManager(@ApplicationContext context: Context): CredentialManager {\n        return CredentialManager.create(context)\n    }\n}\n</code></pre>"},{"location":"dependency-injection/#pattern-4-third-party-library-with-builder","title":"Pattern 4: Third-Party Library with Builder","text":"<p>Real Example from Retrofit setup:</p> <pre><code>@Module(includes = [OkHttpClientModule::class])\n@InstallIn(SingletonComponent::class)\nobject RetrofitModule {\n\n    @Singleton\n    @Provides\n    fun provideRetrofitClient(\n        converterFactory: Converter.Factory,\n        okHttpClient: OkHttpClient,\n    ): Retrofit {\n        return Retrofit.Builder()\n            .baseUrl(BuildConfig.BACKEND_URL)\n            .addConverterFactory(converterFactory)\n            .client(okHttpClient)\n            .build()\n    }\n}\n</code></pre>"},{"location":"dependency-injection/#convention-plugin-pattern","title":"Convention Plugin Pattern","text":"<p>This template uses a Gradle Convention Plugin to simplify Hilt setup across modules.</p> <p>Convention Plugin (<code>build-logic/convention/src/main/kotlin/DaggerHiltConventionPlugin.kt</code>):</p> <pre><code>class DaggerHiltConventionPlugin : Plugin&lt;Project&gt; {\n    override fun apply(target: Project) {\n        with(target) {\n            val libs = extensions.getByType&lt;VersionCatalogsExtension&gt;().named(\"libs\")\n\n            with(pluginManager) {\n                apply(\"com.google.dagger.hilt.android\")\n                apply(\"com.google.devtools.ksp\")\n            }\n\n            dependencies {\n                \"implementation\"(libs.findLibrary(\"dagger.hilt.android\").get())\n                \"ksp\"(libs.findLibrary(\"dagger.hilt.compiler\").get())\n            }\n        }\n    }\n}\n</code></pre> <p>Usage in <code>feature/home/build.gradle.kts</code>:</p> <pre><code>plugins {\n    alias(libs.plugins.jetpack.ui.library)\n    alias(libs.plugins.jetpack.dagger.hilt) // One line to add Hilt\n    alias(libs.plugins.jetpack.dokka)\n}\n</code></pre> <p>Benefits:</p> <ul> <li>Consistent Hilt setup across all modules</li> <li>Single source of truth for Hilt configuration</li> <li>Easy to update Hilt version across the entire project</li> <li>Reduces boilerplate in build files</li> </ul>"},{"location":"dependency-injection/#testing-with-hilt","title":"Testing with Hilt","text":""},{"location":"dependency-injection/#unit-testing-repositories-and-viewmodels","title":"Unit Testing Repositories and ViewModels","text":"<p>For unit tests, you can use test doubles (fakes or mocks) instead of real implementations.</p> <p>Example (Not in codebase, but standard pattern):</p> <pre><code>class AuthRepositoryTest {\n\n    private lateinit var repository: AuthRepository\n    private val fakeAuthDataSource = FakeAuthDataSource()\n    private val fakePreferencesDataSource = FakeUserPreferencesDataSource()\n\n    @Before\n    fun setup() {\n        repository = AuthRepositoryImpl(\n            authDataSource = fakeAuthDataSource,\n            userPreferencesDataSource = fakePreferencesDataSource\n        )\n    }\n\n    @Test\n    fun signIn_success_savesUserToPreferences() = runTest {\n        // Test implementation\n    }\n}\n</code></pre> <p>Key points:</p> <ul> <li>No Hilt in unit tests</li> <li>Use constructor injection (makes testing easier)</li> <li>Inject fake/mock implementations manually</li> </ul>"},{"location":"dependency-injection/#integration-testing-with-hilt","title":"Integration Testing with Hilt","text":"<p>For Android instrumentation tests, use Hilt's testing library.</p> <p>Example (Not in codebase, but standard pattern):</p> <pre><code>@HiltAndroidTest\n@UninstallModules(RepositoryModule::class)\nclass FeatureIntegrationTest {\n\n    @get:Rule\n    var hiltRule = HiltAndroidRule(this)\n\n    @BindValue\n    @JvmField\n    val repository: AuthRepository = FakeAuthRepository()\n\n    @Test\n    fun testFeature() {\n        // Test with fake repository\n    }\n}\n</code></pre>"},{"location":"dependency-injection/#troubleshooting","title":"Troubleshooting","text":""},{"location":"dependency-injection/#common-issues","title":"Common Issues","text":""},{"location":"dependency-injection/#1-cannot-find-symbol-daggerapplicationcomponent","title":"1. \"Cannot find symbol: DaggerApplicationComponent\"","text":"<p>Cause: Hilt annotation processor hasn't run yet.</p> <p>Solution:</p> <ul> <li>Build the project: <code>./gradlew build</code></li> <li>Clean and rebuild: <code>./gradlew clean build</code></li> <li>Ensure <code>@HiltAndroidApp</code> is on your Application class</li> </ul>"},{"location":"dependency-injection/#2-missing-binding-for-type","title":"2. \"Missing binding for [Type]\"","text":"<p>Cause: No Hilt module provides this type.</p> <p>Solution:</p> <ul> <li>Create a module with <code>@Provides</code> or <code>@Binds</code> for the type</li> <li>If using <code>@Binds</code>, ensure the implementation has <code>@Inject constructor</code></li> <li>Check that the module is installed in the correct component (<code>@InstallIn</code>)</li> </ul> <p>Example:</p> <pre><code>// Problem: AuthRepository not bound\n@Binds\n@Singleton\ninternal abstract fun bindAuthRepository(\n    authRepositoryImpl: AuthRepositoryImpl,\n): AuthRepository\n</code></pre>"},{"location":"dependency-injection/#3-injected-field-must-not-be-private","title":"3. \"Injected field must not be private\"","text":"<p>Cause: Field injection doesn't work with private fields.</p> <p>Solution:</p> <pre><code>// \u274c Wrong\n@Inject\nprivate lateinit var repository: Repository\n\n// \u2705 Correct\n@Inject\nlateinit var repository: Repository\n</code></pre>"},{"location":"dependency-injection/#4-inject-constructor-required-when-using-binds","title":"4. \"@Inject constructor required\" (when using @Binds)","text":"<p>Cause: <code>@Binds</code> requires the implementation to have <code>@Inject constructor</code>.</p> <p>Solution:</p> <pre><code>// \u274c Wrong\nclass AuthRepositoryImpl(\n    private val authDataSource: AuthDataSource,\n) : AuthRepository\n\n// \u2705 Correct\nclass AuthRepositoryImpl @Inject constructor(\n    private val authDataSource: AuthDataSource,\n) : AuthRepository\n</code></pre>"},{"location":"dependency-injection/#5-scoping-mismatch","title":"5. \"Scoping mismatch\"","text":"<p>Cause: Dependency has a shorter scope than the class requesting it.</p> <p>Example of problem:</p> <pre><code>@Singleton\nclass Repository @Inject constructor(\n    @ActivityScoped val activityDep: ActivityDependency  // \u274c Wrong\n)\n</code></pre> <p>Solution: Ensure dependencies have equal or longer scopes:</p> <ul> <li><code>@Singleton</code> can depend on <code>@Singleton</code></li> <li><code>@ActivityScoped</code> can depend on <code>@Singleton</code> or <code>@ActivityScoped</code></li> <li><code>@ViewModelScoped</code> can depend on <code>@Singleton</code> or <code>@ViewModelScoped</code></li> </ul>"},{"location":"dependency-injection/#6-ksp-not-generating-code","title":"6. KSP not generating code","text":"<p>Cause: KSP configuration issue or cache corruption.</p> <p>Solution:</p> <ul> <li>Ensure convention plugin applies KSP: <code>apply(\"com.google.devtools.ksp\")</code></li> <li>Invalidate caches and restart Android Studio</li> <li>Clean build directory: <code>./gradlew clean</code></li> <li>Check KSP version compatibility with Kotlin version</li> </ul>"},{"location":"dependency-injection/#7-circular-dependency-error","title":"7. Circular dependency error","text":"<p>Cause: Two classes depend on each other.</p> <p>Example:</p> <pre><code>class A @Inject constructor(val b: B)\nclass B @Inject constructor(val a: A)  // Circular!\n</code></pre> <p>Solutions:</p> <ul> <li>Use <code>Lazy&lt;T&gt;</code> for one dependency</li> <li>Use <code>Provider&lt;T&gt;</code> for one dependency</li> <li>Refactor to break the cycle (extract common logic)</li> </ul> <p>Example fix:</p> <pre><code>class A @Inject constructor(val b: Lazy&lt;B&gt;)  // Break cycle with Lazy\nclass B @Inject constructor(val a: A)\n</code></pre>"},{"location":"dependency-injection/#best-practices","title":"Best Practices","text":""},{"location":"dependency-injection/#dos","title":"Do's","text":"<ol> <li> <p>Use constructor injection whenever possible    <pre><code>class Repository @Inject constructor(\n    private val dataSource: DataSource\n) : RepositoryInterface\n</code></pre></p> </li> <li> <p>Prefer @Binds over @Provides for interface bindings    <pre><code>@Binds\nabstract fun bindRepository(impl: RepositoryImpl): Repository\n</code></pre></p> </li> <li> <p>Use qualifiers for multiple instances of the same type    <pre><code>@IoDispatcher private val ioDispatcher: CoroutineDispatcher\n</code></pre></p> </li> <li> <p>Scope appropriately based on lifecycle needs    <pre><code>@Singleton  // Lives as long as app\n@Binds\nabstract fun bindRepository(impl: RepositoryImpl): Repository\n</code></pre></p> </li> <li> <p>Organize modules by layer (following the existing pattern)</p> <ul> <li><code>core/*/di/</code> for core infrastructure</li> <li><code>data/di/</code> for repositories</li> <li><code>firebase/*/di/</code> for Firebase integrations</li> </ul> </li> <li> <p>Use <code>internal</code> for implementation bindings <pre><code>@Binds\n@Singleton\ninternal abstract fun bindAuthRepository(\n    authRepositoryImpl: AuthRepositoryImpl,\n): AuthRepository\n</code></pre></p> </li> <li> <p>Inject dispatchers instead of hardcoding <code>Dispatchers.IO</code> <pre><code>class DataSource @Inject constructor(\n    @IoDispatcher private val ioDispatcher: CoroutineDispatcher\n) {\n    suspend fun getData() = withContext(ioDispatcher) { /* ... */ }\n}\n</code></pre></p> </li> </ol>"},{"location":"dependency-injection/#donts","title":"Don'ts","text":"<ol> <li> <p>Don't use field injection when constructor injection is possible    <pre><code>// \u274c Avoid\nclass Repository {\n    @Inject lateinit var dataSource: DataSource\n}\n\n// \u2705 Prefer\nclass Repository @Inject constructor(\n    private val dataSource: DataSource\n)\n</code></pre></p> </li> <li> <p>Don't inject Android components (Context, Activity, etc.) into Singletons    <pre><code>// \u274c Wrong - Activity will leak\n@Singleton\nclass BadRepository @Inject constructor(private val activity: Activity)\n\n// \u2705 Correct - Use ApplicationContext\n@Singleton\nclass GoodRepository @Inject constructor(\n    @ApplicationContext private val context: Context\n)\n</code></pre></p> </li> <li> <p>Don't hardcode Dispatchers <pre><code>// \u274c Wrong\nwithContext(Dispatchers.IO) { /* ... */ }\n\n// \u2705 Correct\n@Inject constructor(@IoDispatcher private val ioDispatcher: CoroutineDispatcher)\nwithContext(ioDispatcher) { /* ... */ }\n</code></pre></p> </li> <li> <p>Don't over-scope (don't make everything <code>@Singleton</code> unnecessarily)</p> </li> <li> <p>Don't create modules in feature packages - follow the <code>di/</code> package pattern</p> </li> <li> <p>Don't mix Hilt with other DI frameworks (like Koin, manual DI)</p> </li> </ol>"},{"location":"dependency-injection/#advanced-topics","title":"Advanced Topics","text":""},{"location":"dependency-injection/#custom-components-not-used-in-this-template","title":"Custom Components (Not Used in This Template)","text":"<p>Hilt allows creating custom components for specific lifecycles. This template doesn't use custom components, but they can be useful for:</p> <ul> <li>Fragment-specific dependencies</li> <li>Service-specific dependencies</li> <li>Custom lifecycle scopes</li> </ul>"},{"location":"dependency-injection/#entry-points","title":"Entry Points","text":"<p>If you need to inject dependencies into a class that Hilt doesn't support, use <code>@EntryPoint</code>.</p> <p>Example (not in codebase):</p> <pre><code>@EntryPoint\n@InstallIn(SingletonComponent::class)\ninterface MyEntryPoint {\n    fun repository(): Repository\n}\n\n// In non-Hilt class\nval entryPoint = EntryPointAccessors.fromApplication(\n    context.applicationContext,\n    MyEntryPoint::class.java\n)\nval repository = entryPoint.repository()\n</code></pre>"},{"location":"dependency-injection/#multibindings","title":"Multibindings","text":"<p>For providing multiple implementations of the same interface (e.g., list of plugins, interceptors).</p> <p>Example (not in codebase):</p> <pre><code>@Module\n@InstallIn(SingletonComponent::class)\nabstract class InterceptorModule {\n\n    @Binds\n    @IntoSet\n    abstract fun bindLoggingInterceptor(impl: LoggingInterceptor): Interceptor\n\n    @Binds\n    @IntoSet\n    abstract fun bindAuthInterceptor(impl: AuthInterceptor): Interceptor\n}\n\n// Inject\nclass Client @Inject constructor(\n    private val interceptors: Set&lt;@JvmSuppressWildcards Interceptor&gt;\n)\n</code></pre>"},{"location":"dependency-injection/#migration-guide","title":"Migration Guide","text":"<p>If you're adding Hilt to an existing project or module:</p>"},{"location":"dependency-injection/#step-1-add-convention-plugin","title":"Step 1: Add Convention Plugin","text":"<pre><code>// build.gradle.kts\nplugins {\n    alias(libs.plugins.jetpack.dagger.hilt)\n}\n</code></pre>"},{"location":"dependency-injection/#step-2-annotate-application-class","title":"Step 2: Annotate Application Class","text":"<pre><code>@HiltAndroidApp\nclass YourApplication : Application()\n</code></pre>"},{"location":"dependency-injection/#step-3-create-modules","title":"Step 3: Create Modules","text":"<ul> <li>Create <code>di/</code> package in each module</li> <li>Create Hilt modules for existing dependencies</li> <li>Use <code>@Binds</code> for interfaces, <code>@Provides</code> for complex types</li> </ul>"},{"location":"dependency-injection/#step-4-migrate-injection","title":"Step 4: Migrate Injection","text":"<ul> <li>Replace manual injection with <code>@Inject constructor</code></li> <li>Annotate Activities with <code>@AndroidEntryPoint</code></li> <li>Annotate ViewModels with <code>@HiltViewModel</code></li> </ul>"},{"location":"dependency-injection/#step-5-test","title":"Step 5: Test","text":"<ul> <li>Build the project</li> <li>Verify all dependencies are injected</li> <li>Run tests to ensure nothing broke</li> </ul>"},{"location":"dependency-injection/#further-reading","title":"Further Reading","text":"<ul> <li>Dagger Hilt Official Guide</li> <li>Hilt Codelab</li> <li>Dependency Injection on Android with Hilt</li> <li>Hilt Testing Guide</li> </ul>"},{"location":"dependency-injection/#summary","title":"Summary","text":"<p>This template follows these DI principles:</p> <ol> <li>Convention over configuration - Convention plugin simplifies setup</li> <li>Constructor injection first - Easier to test, explicit dependencies</li> <li>Organized by layer - Modules follow project structure</li> <li>Scoped appropriately - Most dependencies are <code>@Singleton</code></li> <li>Qualifier annotations - Used for dispatchers and multiple instances</li> <li>Compile-time safety - Hilt validates dependency graph at build time</li> </ol> <p>By following these patterns, you'll have a maintainable, testable, and efficient DI setup that scales with your project.</p>"},{"location":"dependency/","title":"Dependency Management","text":""},{"location":"dependency/#summary","title":"Summary","text":"<p>This guide explains the project's dependency management strategy using Gradle Version Catalogs and automated update tools (Renovate/Dependabot). Learn how to add dependencies, manage versions centrally, use BOMs for version compatibility, and leverage automated dependency updates to keep the project current.</p> <p>This project uses Version Catalogs and automated dependency updates to maintain a clean and up-to-date dependency management system.</p>"},{"location":"dependency/#version-catalog","title":"Version Catalog","text":"<p>Dependencies and versions are centrally managed in <code>gradle/libs.versions.toml</code>. This file serves as a single source of truth for:</p> <ul> <li>Library dependencies</li> <li>Plugin versions</li> <li>Project configuration</li> <li>SDK versions</li> </ul>"},{"location":"dependency/#structure","title":"Structure","text":"<p>The version catalog is organized into several sections:</p> <ol> <li>Versions</li> </ol> <pre><code>[versions]\n# Core versions\njava = \"21\"\nkotlin = \"2.1.10\"\n\n# SDK Configuration\nminSdk = \"24\"\ncompileSdk = \"35\"\ntargetSdk = \"35\"\n</code></pre> <ol> <li>Plugins</li> </ol> <pre><code>[plugins]\nkotlin = { id = \"org.jetbrains.kotlin.android\", version.ref = \"kotlin\" }\nandroid-library = { id = \"com.android.library\", version.ref = \"androidGradlePlugin\" }\n</code></pre> <ol> <li>Libraries</li> </ol> <pre><code>[libraries]\nandroidx-core-ktx = { group = \"androidx.core\", name = \"core-ktx\", version.ref = \"androidxCore\" }\n</code></pre> <p>Note</p> <p>Some versions in the catalog, like <code>java</code> and SDK versions, are not direct dependencies but are used by convention plugins and build configuration.</p>"},{"location":"dependency/#using-dependencies","title":"Using Dependencies","text":"<p>In your module's <code>build.gradle.kts</code>:</p> <pre><code>dependencies {\n    implementation(libs.androidx.core.ktx)\n    implementation(platform(libs.androidx.compose.bom))\n}\n</code></pre> <p>For plugins:</p> <pre><code>plugins {\n    alias(libs.plugins.kotlin)\n    alias(libs.plugins.android.library)\n}\n</code></pre>"},{"location":"dependency/#automated-dependency-updates","title":"Automated Dependency Updates","text":"<p>This project uses both Renovate and Dependabot to automate dependency updates.</p>"},{"location":"dependency/#renovate-setup","title":"Renovate Setup","text":"<p>The project includes a <code>renovate.json</code> configuration:</p> <pre><code>{\n  \"$schema\": \"https://docs.renovatebot.com/renovate-schema.json\",\n  \"extends\": [\n    \"config:base\",\n    \"group:all\",\n    \":dependencyDashboard\",\n    \"schedule:daily\"\n  ]\n}\n</code></pre> <p>To enable Renovate, install the Renovate app in your repository</p>"},{"location":"dependency/#dependabot-setup","title":"Dependabot Setup","text":"<p>The project includes a <code>.github/dependabot.yml</code> configuration:</p> <pre><code>version: 2\nupdates:\n  - package-ecosystem: \"github-actions\"\n    directory: \"/\"\n    schedule:\n      interval: \"weekly\"\n\n  - package-ecosystem: \"gradle\"\n    directory: \"/\"\n    schedule:\n      interval: \"weekly\"\n    groups:\n      kotlin-ksp-compose:\n        patterns:\n          - \"org.jetbrains.kotlin:*\"\n          - \"com.google.devtools.ksp\"\n          - \"androidx.compose.compiler:compiler\"\n</code></pre> <p>To enable Dependabot, ensure Dependabot is enabled in your repository settings</p> <p>Tip</p> <p>You can group dependencies that you want to get updated together in dependabot config as it has been done for the <code>kotlin-ksp-group</code>.</p>"},{"location":"dependency/#best-practices","title":"Best Practices","text":"<ol> <li> <p>Version Organization:</p> <ul> <li>Group related versions together</li> <li>Use comments to separate sections</li> <li>Keep SDK configurations in a dedicated section</li> </ul> </li> <li> <p>Version References:</p> </li> </ol> <pre><code>[versions]\ncompose-compiler = \"1.5.3\"\n\n[libraries]\ncompose-compiler = { group = \"androidx.compose.compiler\", name = \"compiler\", version.ref = \"compose-compiler\" }\n</code></pre> <ol> <li>Version Bundles:    Use BOM (Bill of Materials) when available:</li> </ol> <pre><code>[libraries]\ncompose-bom = { group = \"androidx.compose\", name = \"compose-bom\", version.ref = \"androidxComposeBom\" }\n</code></pre> <ol> <li>Custom Properties:    Store important project configuration in the version catalog:</li> </ol> <pre><code>[versions]\nminSdk = \"24\"\ncompileSdk = \"35\"\ntargetSdk = \"35\"\n</code></pre> <p>Warning</p> <p>Don't mix different versions of the same library family. Use BOMs when available to ensure compatibility.</p>"},{"location":"dependency/#adding-new-dependencies","title":"Adding New Dependencies","text":"<ol> <li>Add the version to <code>[versions]</code> section if needed</li> <li>Add the library definition to <code>[libraries]</code> section</li> <li>Use the new dependency in your module:</li> </ol> <pre><code>dependencies {\n    implementation(libs.your.new.dependency)\n}\n</code></pre>"},{"location":"dependency/#further-reading","title":"Further Reading","text":"<ul> <li>Convention Plugins - Build logic and plugin configuration that uses version   catalog</li> <li>Adding New Features - Step-by-step guide for implementing new features</li> <li>Architecture Overview - Module structure and architectural patterns</li> </ul>"},{"location":"faq/","title":"Frequently Asked Questions (FAQ)","text":"<p>This FAQ answers common questions about using and extending this Android starter template. Questions are organized by category for easy reference.</p>"},{"location":"faq/#table-of-contents","title":"Table of Contents","text":"<ol> <li>Architecture Questions</li> <li>Component Questions</li> <li>Data Layer Questions</li> <li>State Management Questions</li> <li>Deployment Questions</li> <li>Performance Questions</li> <li>Firebase Questions</li> </ol>"},{"location":"faq/#architecture-questions","title":"Architecture Questions","text":""},{"location":"faq/#why-no-domain-layer","title":"Why no domain layer?","text":"<p>TL;DR: To keep the template simple and avoid over-engineering.</p> <p>The template intentionally uses a two-layer architecture (UI + Data) instead of the traditional three-layer approach:</p> <pre><code>graph LR\n    UI[UI Layer&lt;br/&gt;ViewModel] --&gt; Data[Data Layer&lt;br/&gt;Repository + Data Sources]</code></pre> <p>Reasons:</p> <ul> <li>Reduces complexity: Fewer layers means less boilerplate and easier navigation</li> <li>Faster development: No need to create use cases for simple CRUD operations</li> <li>Easier to understand: New developers can grasp the architecture quickly</li> <li>Pragmatic: Most apps don't need the extra layer</li> </ul> <p>When to add a domain layer:</p> <ul> <li>Multiple ViewModels share complex business logic</li> <li>Business rules become too complex for repositories</li> <li>You need to transform data between multiple repositories</li> <li>Your team prefers strict layering</li> </ul> <p>See architecture.md for more details.</p>"},{"location":"faq/#when-should-i-add-a-domain-layer","title":"When should I add a domain layer?","text":"<p>Add a domain layer when you encounter any of these scenarios:</p>"},{"location":"faq/#1-shared-business-logic-across-viewmodels","title":"1. Shared Business Logic Across ViewModels","text":"<pre><code>// Without domain layer (code duplication)\nclass PostsViewModel : ViewModel() {\n    fun loadPosts() {\n        val posts = repository.getPosts()\n            .filter { it.isPublished }\n            .sortedByDescending { it.createdAt }\n        // Use posts\n    }\n}\n\nclass FeedViewModel : ViewModel() {\n    fun loadFeed() {\n        val posts = repository.getPosts()\n            .filter { it.isPublished }  // \u274c Duplicate logic\n            .sortedByDescending { it.createdAt }  // \u274c Duplicate logic\n        // Use posts\n    }\n}\n\n// With domain layer (shared logic)\nclass GetPublishedPostsUseCase @Inject constructor(\n    private val repository: PostsRepository\n) {\n    suspend operator fun invoke(): Result&lt;List&lt;Post&gt;&gt; {\n        return repository.getPosts().map { posts -&gt;\n            posts.filter { it.isPublished }\n                .sortedByDescending { it.createdAt }\n        }\n    }\n}\n\n// Now both ViewModels use the same logic\nclass PostsViewModel @Inject constructor(\n    private val getPublishedPosts: GetPublishedPostsUseCase\n) : ViewModel() {\n    fun loadPosts() {\n        _uiState.updateStateWith {\n            getPublishedPosts()\n        }\n    }\n}\n</code></pre>"},{"location":"faq/#2-complex-data-transformations","title":"2. Complex Data Transformations","text":"<p>When you need to combine data from multiple repositories with complex transformation logic, use cases keep this logic testable and reusable.</p> <pre><code>class GetUserDashboardUseCase @Inject constructor(\n    private val userRepository: UserRepository,\n    private val postsRepository: PostsRepository,\n    private val statsRepository: StatsRepository\n) {\n    suspend operator fun invoke(userId: String): Result&lt;Dashboard&gt; {\n        return suspendRunCatching {\n            // Complex orchestration of multiple repositories\n            val user = userRepository.getUser(userId).getOrThrow()\n            val posts = postsRepository.getUserPosts(userId).getOrThrow()\n            val stats = statsRepository.getUserStats(userId).getOrThrow()\n\n            Dashboard(\n                user = user,\n                recentPosts = posts.take(5),\n                totalViews = stats.views,\n                totalLikes = stats.likes,\n                engagement = calculateEngagement(posts, stats)\n            )\n        }\n    }\n\n    private fun calculateEngagement(posts: List&lt;Post&gt;, stats: Stats): Double {\n        // Complex business logic\n    }\n}\n</code></pre>"},{"location":"faq/#3-business-rules-enforcement","title":"3. Business Rules Enforcement","text":"<p>Use cases are perfect for enforcing business rules:</p> <pre><code>class PublishPostUseCase @Inject constructor(\n    private val postsRepository: PostsRepository,\n    private val userRepository: UserRepository\n) {\n    suspend operator fun invoke(post: Post): Result&lt;Unit&gt; {\n        return suspendRunCatching {\n            // Enforce business rules\n            val user = userRepository.getCurrentUser().getOrThrow()\n\n            require(user.canPublish) {\n                \"User doesn't have permission to publish\"\n            }\n\n            require(post.title.isNotBlank()) {\n                \"Post title cannot be empty\"\n            }\n\n            require(post.content.length &gt;= 100) {\n                \"Post content must be at least 100 characters\"\n            }\n\n            // Publish the post\n            postsRepository.publishPost(post).getOrThrow()\n        }\n    }\n}\n</code></pre> <p>How to add:</p> <ol> <li>Create <code>domain</code> module: <code>mkdir -p domain/src/main/kotlin/dev/atick/domain/usecase</code></li> <li>Create use case classes with <code>operator fun invoke()</code></li> <li>Inject into ViewModels instead of repositories</li> <li>Keep repositories for data operations only</li> </ol>"},{"location":"faq/#why-two-layer-architecture","title":"Why two-layer architecture?","text":"<p>The two-layer architecture prioritizes:</p> <ol> <li>Pragmatic Simplicity: Most apps don't need complex layering</li> <li>Reduced Boilerplate: Fewer interfaces and classes to maintain</li> <li>Faster Onboarding: New developers understand the flow quickly</li> <li>Direct Communication: ViewModels can directly call repositories</li> </ol> <p>This is a conscious trade-off:</p> <ul> <li>\u2705 Simpler codebase</li> <li>\u2705 Faster development</li> <li>\u2705 Less abstraction overhead</li> <li>\u274c Some business logic lives in repositories</li> <li>\u274c May need refactoring if complexity grows</li> </ul> <p>See philosophy.md for the full rationale.</p>"},{"location":"faq/#component-questions","title":"Component Questions","text":""},{"location":"faq/#how-do-i-customize-component-appearance","title":"How do I customize component appearance?","text":"<p>Option 1: Modify theme colors (affects all components globally):</p> <pre><code>// core/ui/src/main/kotlin/.../theme/Color.kt\nval LightDefaultColorScheme = lightColorScheme(\n    primary = Color(0xFF6200EE),           // Your brand color\n    onBackground = Color(0xFF1C1B1F),\n    outline = Color(0xFF79747E),\n    // ... other colors\n)\n</code></pre> <p>Option 2: Override individual component (for specific instances):</p> <pre><code>JetpackButton(\n    onClick = { },\n    colors = ButtonDefaults.buttonColors(\n        containerColor = Color.Red,  // Custom color for this button\n        contentColor = Color.White\n    ),\n    content = { Text(\"Delete\") }\n)\n</code></pre> <p>Option 3: Create themed variant:</p> <pre><code>@Composable\nfun DangerButton(\n    onClick: () -&gt; Unit,\n    text: @Composable () -&gt; Unit,\n    modifier: Modifier = Modifier\n) {\n    JetpackButton(\n        onClick = onClick,\n        colors = ButtonDefaults.buttonColors(\n            containerColor = MaterialTheme.colorScheme.error,\n            contentColor = MaterialTheme.colorScheme.onError\n        ),\n        modifier = modifier,\n        text = text\n    )\n}\n</code></pre> <p>See components.md for more customization patterns.</p>"},{"location":"faq/#how-do-i-create-a-new-custom-component","title":"How do I create a new custom component?","text":"<p>Follow this pattern:</p>"},{"location":"faq/#1-create-component-file","title":"1. Create Component File","text":"<pre><code>// core/ui/src/main/kotlin/dev/atick/core/ui/components/CustomCard.kt\npackage dev.atick.core.ui.components\n\nimport androidx.compose.material3.*\nimport androidx.compose.runtime.Composable\nimport androidx.compose.ui.Modifier\n\n/**\n * A custom card component for displaying featured content.\n *\n * Example:\n * ```\n\n* CustomCard(\n*     title = \"Featured Post\",\n*     subtitle = \"Read more about...\"\n* ) {\n*     Text(\"Card content\")\n* }\n* ```\n*\n* @param title Card title\n* @param subtitle Card subtitle\n* @param modifier Modifier to customize appearance\n* @param content Card body content\n  */\n  @Composable\n  fun CustomCard(\n  title: String,\n  subtitle: String,\n  modifier: Modifier = Modifier,\n  content: @Composable () -&gt; Unit\n  ) {\n  Card(\n  modifier = modifier,\n  colors = CardDefaults.cardColors(\n  containerColor = MaterialTheme.colorScheme.surfaceVariant\n  )\n  ) {\n  Column(modifier = Modifier.padding(16.dp)) {\n  Text(\n  text = title,\n  style = MaterialTheme.typography.titleLarge,\n  color = MaterialTheme.colorScheme.onSurface\n  )\n  Text(\n  text = subtitle,\n  style = MaterialTheme.typography.bodyMedium,\n  color = MaterialTheme.colorScheme.onSurfaceVariant\n  )\n  Spacer(modifier = Modifier.height(8.dp))\n  content()\n  }\n  }\n  }\n</code></pre>"},{"location":"faq/#2-add-previews","title":"2. Add Previews","text":"<pre><code>@PreviewDevices\n@PreviewThemes\n@Composable\nprivate fun CustomCardPreview() {\n    JetpackTheme {\n        CustomCard(\n            title = \"Sample Title\",\n            subtitle = \"Sample Subtitle\"\n        ) {\n            Text(\"Card content here\")\n        }\n    }\n}\n</code></pre> <p>See components.md for complete guide.</p>"},{"location":"faq/#when-should-i-use-which-component","title":"When should I use which component?","text":"Component Use Case Example <code>JetpackButton</code> Primary action Save, Submit, Continue <code>JetpackOutlinedButton</code> Secondary action Cancel, Skip <code>JetpackTextButton</code> Tertiary / low-emphasis Learn More, View Details <code>JetpackTextFiled</code> Standard text input Name, Email, Address <code>JetpackPasswordFiled</code> Password input Password, PIN <code>JetpackTopAppBar</code> Screen title + actions Most screens <code>JetpackActionBar</code> Screen with text action Edit Profile (Save button) <code>JetpackLoadingWheel</code> Content loading Inside LazyColumn <code>JetpackOverlayLoadingWheel</code> Full-screen loading Initial data load <p>General Rules:</p> <ul> <li>Use filled button for the most important action</li> <li>Use outlined button for secondary actions alongside primary</li> <li>Use text button for low-emphasis actions or inline links</li> <li>Use loading wheel for in-context loading</li> <li>Use overlay loading for blocking operations</li> </ul>"},{"location":"faq/#data-layer-questions","title":"Data Layer Questions","text":""},{"location":"faq/#how-do-i-add-a-new-data-source","title":"How do I add a new data source?","text":"<p>Follow these steps based on the data source type:</p>"},{"location":"faq/#network-data-source-retrofit","title":"Network Data Source (Retrofit)","text":"<pre><code>// 1. Define API interface\n// core/network/src/main/kotlin/.../api/UsersApi.kt\ninterface UsersApi {\n    @GET(\"users/{id}\")\n    suspend fun getUser(@Path(\"id\") String userId): UserResponse\n}\n\n// 2. Provide API instance in module\n@Module\n@InstallIn(SingletonComponent::class)\nobject UsersApiModule {\n    @Singleton\n    @Provides\n    fun provideUsersApi(retrofit: Retrofit): UsersApi {\n        return retrofit.create(UsersApi::class.java)\n    }\n}\n\n// 3. Create data source interface\ninterface UsersNetworkDataSource {\n    suspend fun getUser(userId: String): Result&lt;UserResponse&gt;\n}\n\n// 4. Implement data source\ninternal class UsersNetworkDataSourceImpl @Inject constructor(\n    private val usersApi: UsersApi,\n    @IoDispatcher private val ioDispatcher: CoroutineDispatcher\n) : UsersNetworkDataSource {\n    override suspend fun getUser(userId: String): Result&lt;UserResponse&gt; {\n        return withContext(ioDispatcher) {\n            suspendRunCatching {\n                usersApi.getUser(userId)\n            }\n        }\n    }\n}\n\n// 5. Bind in Hilt module\n@Module\n@InstallIn(SingletonComponent::class)\nabstract class UsersDataSourceModule {\n    @Binds\n    @Singleton\n    internal abstract fun bindUsersNetworkDataSource(\n        impl: UsersNetworkDataSourceImpl\n    ): UsersNetworkDataSource\n}\n</code></pre>"},{"location":"faq/#local-data-source-room","title":"Local Data Source (Room)","text":"<pre><code>// 1. Define entity\n@Entity(tableName = \"users\")\ndata class UserEntity(\n    @PrimaryKey val id: String,\n    val name: String,\n    val email: String\n)\n\n// 2. Create DAO\n@Dao\ninterface UserDao {\n    @Query(\"SELECT * FROM users WHERE id = :id\")\n    fun observeUser(id: String): Flow&lt;UserEntity&gt;\n\n    @Upsert\n    suspend fun upsert(user: UserEntity)\n}\n\n// 3. Add DAO to database\n@Database(\n    entities = [UserEntity::class, /* other entities */],\n    version = 1\n)\nabstract class JetpackDatabase : RoomDatabase() {\n    abstract fun getUserDao(): UserDao\n}\n\n// 4. Provide DAO in module\n@Module(includes = [DatabaseModule::class])\n@InstallIn(SingletonComponent::class)\nobject DaoModule {\n    @Singleton\n    @Provides\n    fun provideUserDao(database: JetpackDatabase): UserDao {\n        return database.getUserDao()\n    }\n}\n\n// 5. Create data source\ninternal class LocalDataSourceImpl @Inject constructor(\n    private val userDao: UserDao,\n    @IoDispatcher private val ioDispatcher: CoroutineDispatcher\n) : LocalDataSource {\n    override fun observeUser(id: String): Flow&lt;UserEntity&gt; {\n        return userDao.observeUser(id)\n    }\n\n    override suspend fun upsertUser(user: UserEntity) {\n        withContext(ioDispatcher) {\n            userDao.upsert(user)\n        }\n    }\n}\n</code></pre> <p>See data-flow.md for complete patterns.</p>"},{"location":"faq/#how-do-i-choose-between-room-datastore-and-firestore","title":"How do I choose between Room, DataStore, and Firestore?","text":"Data Source Use Case Pros Cons Room Structured relational data, offline-first Fast, SQL queries, type-safe More setup, migration complexity DataStore Simple key-value preferences Easy setup, type-safe, Flow support Not for large datasets Firestore Real-time sync, multi-device Real-time, serverless, scalable Requires network, query limitations <p>Decision Tree:</p> <pre><code>graph TD\n    Start{Do you need&lt;br/&gt;real-time multi-device sync?}\n    Start --&gt;|YES| Firestore[Use Firestore&lt;br/&gt;+ Room for offline]\n    Start --&gt;|NO| Complex{Do you need complex&lt;br/&gt;queries or relationships?}\n    Complex --&gt;|YES| Room1[Use Room]\n    Complex --&gt;|NO| Preferences{Is it simple&lt;br/&gt;preferences/settings?}\n    Preferences --&gt;|YES| DataStore[Use DataStore]\n    Preferences --&gt;|NO| Room2[Use Room&lt;br/&gt;structured data]</code></pre> <p>Examples:</p> <ul> <li>Room: User posts, messages, cached data, offline-first content</li> <li>DataStore: Theme preference, auth token, user settings, language</li> <li>Firestore: Chat messages, collaborative documents, social feeds</li> </ul> <p>Combining Multiple Sources:</p> <pre><code>// Offline-first pattern: Room + Firestore\nclass PostsRepositoryImpl @Inject constructor(\n    private val localDataSource: LocalDataSource,    // Room\n    private val firebaseDataSource: FirebaseDataSource,  // Firestore\n    private val preferencesDataSource: UserPreferencesDataSource  // DataStore\n) : PostsRepository {\n\n    override fun observePosts(): Flow&lt;List&lt;Post&gt;&gt; {\n        return flow {\n            // Get user ID from preferences\n            val userId = preferencesDataSource.getUserIdOrThrow()\n\n            // Listen to Firestore real-time updates\n            viewModelScope.launch {\n                firebaseDataSource.observePosts(userId)\n                    .collect { firestorePosts -&gt;\n                        localDataSource.savePosts(firestorePosts)\n                    }\n            }\n\n            // Emit from Room (single source of truth)\n            emitAll(\n                localDataSource.observePosts(userId)\n                    .map { it.map { entity -&gt; entity.toDomain() } }\n            )\n        }\n    }\n}\n</code></pre> <p>See data/README.md and data-flow.md for patterns.</p>"},{"location":"faq/#how-do-i-handle-offline-scenarios","title":"How do I handle offline scenarios?","text":"<p>The template supports offline-first by design. Follow this pattern:</p>"},{"location":"faq/#1-use-room-as-single-source-of-truth","title":"1. Use Room as Single Source of Truth","text":"<pre><code>// UI always observes Room, not network\noverride fun observePosts(): Flow&lt;List&lt;Post&gt;&gt; {\n    return localDataSource.observePosts()  // Room\n        .map { entities -&gt; entities.map { it.toDomain() } }\n}\n</code></pre>"},{"location":"faq/#2-sync-in-background","title":"2. Sync in Background","text":"<pre><code>override fun observePosts(): Flow&lt;List&lt;Post&gt;&gt; {\n    return flow {\n        // Trigger background sync\n        syncManager.requestSync()\n\n        // Emit local data immediately (works offline!)\n        emitAll(\n            localDataSource.observePosts()\n                .map { entities -&gt; entities.map { it.toDomain() } }\n        )\n    }\n}\n</code></pre>"},{"location":"faq/#3-track-sync-metadata","title":"3. Track Sync Metadata","text":"<pre><code>@Entity\ndata class PostEntity(\n    @PrimaryKey val id: String,\n    val title: String,\n    val content: String,\n\n    // Sync metadata\n    val lastUpdated: Long = 0,      // Local modification time\n    val lastSynced: Long = 0,       // Last successful sync\n    val needsSync: Boolean = false, // Has pending changes\n    val syncAction: SyncAction = SyncAction.NONE\n)\n\nenum class SyncAction {\n    NONE,    // Already synced\n    UPSERT,  // Create or update on server\n    DELETE   // Delete on server\n}\n</code></pre>"},{"location":"faq/#4-push-changes-when-online","title":"4. Push Changes When Online","text":"<pre><code>override suspend fun syncPosts(): Result&lt;Unit&gt; {\n    return suspendRunCatching {\n        // Get unsynced local changes\n        val unsyncedPosts = localDataSource.getUnsyncedPosts()\n\n        // Push to server when online\n        unsyncedPosts.forEach { post -&gt;\n            when (post.syncAction) {\n                SyncAction.UPSERT -&gt; networkDataSource.upsertPost(post)\n                SyncAction.DELETE -&gt; networkDataSource.deletePost(post.id)\n                SyncAction.NONE -&gt; { /* skip */\n                }\n            }\n            localDataSource.markAsSynced(post.id)\n        }\n\n        // Pull remote changes\n        val remotePosts = networkDataSource.getPosts()\n        localDataSource.savePosts(remotePosts)\n    }\n}\n</code></pre>"},{"location":"faq/#5-use-workmanager-for-background-sync","title":"5. Use WorkManager for Background Sync","text":"<p>The template includes <code>sync</code> module with WorkManager:</p> <pre><code>// Initialize in Application.onCreate()\nSync.initialize(context)  // Sets up periodic sync\n\n// Request immediate sync\nsyncManager.requestSync()\n\n// Observe sync state\nsyncManager.isSyncing.collect { isSyncing -&gt;\n    // Show sync indicator in UI\n}\n</code></pre> <p>See data-flow.md for complete offline-first pattern.</p>"},{"location":"faq/#state-management-questions","title":"State Management Questions","text":""},{"location":"faq/#when-should-i-use-updatestate-vs-updatestatewith","title":"When should I use <code>updateState</code> vs <code>updateStateWith</code>?","text":"<p>Quick Decision Tree:</p> <pre><code>graph TD\n    Start{Does this operation&lt;br/&gt;involve async work?}\n    Start --&gt;|NO| UpdateState[Use updateState]\n    Start --&gt;|YES| ReturnData{Does it return&lt;br/&gt;new data to display?}\n    ReturnData --&gt;|YES| UpdateStateWith[Use updateStateWith]\n    ReturnData --&gt;|NO| UpdateWith[Use updateWith]</code></pre>"},{"location":"faq/#use-updatestate-for-synchronous-state-changes","title":"Use <code>updateState</code> for synchronous state changes","text":"<pre><code>// Form input\nfun onNameChanged(name: String) {\n    _uiState.updateState {\n        copy(name = name)\n    }\n}\n\n// Toggle boolean\nfun toggleSelection(item: Item) {\n    _uiState.updateState {\n        copy(\n            items = items.map {\n                if (it.id == item.id) it.copy(selected = !it.selected)\n                else it\n            }\n        )\n    }\n}\n\n// Filter list\nfun applyFilter(filter: FilterType) {\n    _uiState.updateState {\n        copy(selectedFilter = filter)\n    }\n}\n</code></pre>"},{"location":"faq/#use-updatestatewith-for-async-operations-that-return-new-data","title":"Use <code>updateStateWith</code> for async operations that return new data","text":"<pre><code>// Load data from repository\nfun loadPosts() {\n    _uiState.updateStateWith {\n        postsRepository.getPosts().map { posts -&gt;\n            copy(posts = posts)\n        }\n    }\n}\n\n// Search with results\nfun search(query: String) {\n    _uiState.updateStateWith {\n        searchRepository.search(query).map { results -&gt;\n            copy(searchResults = results, searchQuery = query)\n        }\n    }\n}\n</code></pre>"},{"location":"faq/#use-updatewith-for-async-operations-without-new-data-side-effects","title":"Use <code>updateWith</code> for async operations without new data (side effects)","text":"<pre><code>// Save to database\nfun savePost(post: Post) {\n    _uiState.updateWith {\n        postsRepository.savePost(post)\n    }\n}\n\n// Delete\nfun deletePost(postId: String) {\n    _uiState.updateWith {\n        postsRepository.deletePost(postId)\n    }\n}\n\n// Update preferences\nfun enableNotifications() {\n    _uiState.updateWith {\n        settingsRepository.updateNotifications(true)\n    }\n}\n</code></pre> <p>See state-management.md for detailed examples.</p>"},{"location":"faq/#how-do-i-handle-multiple-loading-states","title":"How do I handle multiple loading states?","text":"<p>Option 1: Use separate boolean flags (recommended for distinct sections):</p> <pre><code>data class DashboardScreenData(\n    val user: User? = null,\n    val posts: List&lt;Post&gt; = emptyList(),\n    val stats: Stats? = null,\n\n    // Separate loading states\n    val isLoadingUser: Boolean = false,\n    val isLoadingPosts: Boolean = false,\n    val isLoadingStats: Boolean = false\n)\n\nclass DashboardViewModel : ViewModel() {\n    private val _uiState = MutableStateFlow(UiState(DashboardScreenData()))\n    val uiState = _uiState.asStateFlow()\n\n    fun loadUser() {\n        viewModelScope.launch {\n            _uiState.update { it.copy(data = it.data.copy(isLoadingUser = true)) }\n\n            userRepository.getUser().onSuccess { user -&gt;\n                _uiState.updateState {\n                    copy(user = user, isLoadingUser = false)\n                }\n            }.onFailure { error -&gt;\n                _uiState.update {\n                    it.copy(\n                        data = it.data.copy(isLoadingUser = false),\n                        error = OneTimeEvent(error)\n                    )\n                }\n            }\n        }\n    }\n\n    fun loadPosts() {\n        viewModelScope.launch {\n            _uiState.update { it.copy(data = it.data.copy(isLoadingPosts = true)) }\n\n            postsRepository.getPosts().onSuccess { posts -&gt;\n                _uiState.updateState {\n                    copy(posts = posts, isLoadingPosts = false)\n                }\n            }.onFailure { error -&gt;\n                _uiState.update {\n                    it.copy(\n                        data = it.data.copy(isLoadingPosts = false),\n                        error = OneTimeEvent(error)\n                    )\n                }\n            }\n        }\n    }\n}\n\n// In UI\n@Composable\nfun DashboardScreen(screenData: DashboardScreenData) {\n    Column {\n        if (screenData.isLoadingUser) {\n            CircularProgressIndicator()\n        } else {\n            UserCard(user = screenData.user)\n        }\n\n        if (screenData.isLoadingPosts) {\n            CircularProgressIndicator()\n        } else {\n            PostsList(posts = screenData.posts)\n        }\n    }\n}\n</code></pre> <p>Option 2: Use global loading state (for simple cases):</p> <pre><code>// The default UiState.loading applies to the whole screen\nfun loadAllData() {\n    _uiState.updateStateWith {\n        val user = userRepository.getUser().getOrThrow()\n        val posts = postsRepository.getPosts().getOrThrow()\n\n        Result.success(\n            copy(user = user, posts = posts)\n        )\n    }\n}\n</code></pre> <p>See state-management.md for more patterns.</p>"},{"location":"faq/#how-do-i-reset-state","title":"How do I reset state?","text":"<p>Reset to initial state:</p> <pre><code>data class FormScreenData(\n    val name: String = \"\",\n    val email: String = \"\",\n    val isSubmitted: Boolean = false\n)\n\nclass FormViewModel : ViewModel() {\n    private val _uiState = MutableStateFlow(UiState(FormScreenData()))\n    val uiState = _uiState.asStateFlow()\n\n    fun resetForm() {\n        _uiState.updateState {\n            FormScreenData()  // Reset to initial state\n        }\n    }\n\n    // Or reset specific fields\n    fun clearForm() {\n        _uiState.updateState {\n            copy(name = \"\", email = \"\", isSubmitted = false)\n        }\n    }\n}\n</code></pre> <p>Reset after navigation:</p> <pre><code>// In Route composable\n@Composable\nfun FormRoute(\n    onNavigateBack: () -&gt; Unit,\n    viewModel: FormViewModel = hiltViewModel()\n) {\n    val uiState by viewModel.uiState.collectAsStateWithLifecycle()\n\n    // Reset when leaving screen\n    DisposableEffect(Unit) {\n        onDispose {\n            viewModel.resetForm()\n        }\n    }\n\n    StatefulComposable(state = uiState) { screenData -&gt;\n        FormScreen(\n            screenData = screenData,\n            onSubmit = {\n                viewModel.submitForm()\n                onNavigateBack()\n            }\n        )\n    }\n}\n</code></pre>"},{"location":"faq/#deployment-questions","title":"Deployment Questions","text":""},{"location":"faq/#how-do-i-prepare-for-release","title":"How do I prepare for release?","text":""},{"location":"faq/#1-set-up-signing","title":"1. Set Up Signing","text":"<p>Create <code>keystore.properties</code> in the root directory:</p> <pre><code>storeFile=/path/to/your/keystore.jks\nstorePassword=your-store-password\nkeyAlias=your-key-alias\nkeyPassword=your-key-password\n</code></pre> <p>Generate keystore (if you don't have one):</p> <pre><code>keytool -genkey -v -keystore my-release-key.jks -keyalg RSA -keysize 2048 -validity 10000 -alias my-key-alias\n</code></pre>"},{"location":"faq/#2-update-version","title":"2. Update Version","text":"<p>Edit <code>app/build.gradle.kts</code>:</p> <pre><code>val majorUpdateVersion = 1\nval minorUpdateVersion = 2  // Increment for features\nval patchVersion = 3       // Increment for fixes\n\n// versionCode automatically calculated\n// versionName: \"1.2.3\"\n</code></pre>"},{"location":"faq/#3-run-code-quality-checks","title":"3. Run Code Quality Checks","text":"<pre><code># Format code\n./gradlew spotlessApply --init-script gradle/init.gradle.kts --no-configuration-cache\n\n# Check formatting\n./gradlew spotlessCheck --init-script gradle/init.gradle.kts --no-configuration-cache\n\n# Build release\n./gradlew assembleRelease\n</code></pre>"},{"location":"faq/#4-test-release-build","title":"4. Test Release Build","text":"<pre><code># Install on device\n./gradlew installRelease\n\n# Or locate APK\n# app/Jetpack-Android-Starter_release_v1.2.3_YYYY_MM_DD_HH_MM_AM.apk\n</code></pre>"},{"location":"faq/#5-configure-proguard-optional","title":"5. Configure ProGuard (Optional)","text":"<p>Edit <code>app/proguard-rules.pro</code> if needed. Current rules:</p> <pre><code># Keep @Serializable classes for Navigation\n-keep @kotlinx.serialization.Serializable class * { *; }\n\n# Crashlytics\n-keepattributes SourceFile,LineNumberTable\n-keep public class * extends java.lang.Exception\n</code></pre>"},{"location":"faq/#6-set-up-firebase-production","title":"6. Set Up Firebase (Production)","text":"<ol> <li>Create production Firebase project</li> <li>Download <code>google-services.json</code></li> <li>Place in <code>app/google-services.json</code></li> <li>Update SHA-1 fingerprint for production keystore:</li> </ol> <pre><code>keytool -list -v -keystore my-release-key.jks -alias my-key-alias\n# Copy SHA-1 fingerprint to Firebase Console\n</code></pre> <p>See github.md for CI/CD setup.</p>"},{"location":"faq/#how-do-i-set-up-signing","title":"How do I set up signing?","text":"<p>The template automatically handles signing configuration in <code>app/build.gradle.kts</code>:</p> <p>Signing Configuration (Already Implemented):</p> <pre><code>signingConfigs {\n    create(\"release\") {\n        if (keystorePropertiesFile.exists()) {\n            val keystoreProperties = Properties()\n            keystoreProperties.load(FileInputStream(keystorePropertiesFile))\n            keyAlias = keystoreProperties[\"keyAlias\"] as String\n            keyPassword = keystoreProperties[\"keyPassword\"] as String\n            storeFile = file(keystoreProperties[\"storeFile\"] as String)\n            storePassword = keystoreProperties[\"storePassword\"] as String\n        }\n    }\n}\n\nbuildTypes {\n    release {\n        signingConfig = if (keystorePropertiesFile.exists()) {\n            signingConfigs.getByName(\"release\")\n        } else {\n            println(\"keystore.properties not found. Using debug key.\")\n            signingConfigs.getByName(\"debug\")\n        }\n        isMinifyEnabled = true\n        proguardFiles(\n            getDefaultProguardFile(\"proguard-android-optimize.txt\"),\n            \"proguard-rules.pro\"\n        )\n    }\n}\n</code></pre> <p>You only need to:</p> <ol> <li>Create <code>keystore.properties</code> in root directory</li> <li>Generate keystore (if needed)</li> <li>Build release: <code>./gradlew assembleRelease</code></li> </ol> <p>Without keystore, release builds automatically fall back to debug signing (for testing).</p>"},{"location":"faq/#how-do-i-configure-cicd","title":"How do I configure CI/CD?","text":"<p>The template includes GitHub Actions workflow (<code>.github/workflows/ci.yml</code>):</p> <p>Current CI Pipeline:</p> <pre><code>1. Lint Job:\n  - Validates Gradle wrapper\n  - Runs spotlessCheck (code formatting)\n\n2. Build Job (only if lint passes):\n  - Clean project\n  - Build debug APK\n</code></pre> <p>To extend for release builds:</p> <pre><code>release:\n  name: \ud83d\ude80 Build Release APK\n  needs: build\n  runs-on: ubuntu-latest\n  if: github.ref == 'refs/heads/main'\n  steps:\n    - name: \u2b07\ufe0f Checkout Repository\n      uses: actions/checkout@v5\n\n    - name: \ud83c\udfd7\ufe0f Set up JDK 21\n      uses: actions/setup-java@v5\n      with:\n        java-version: 21\n        distribution: 'temurin'\n\n    - name: \ud83d\udd10 Decode Keystore\n      env:\n        ENCODED_STRING: ${{ secrets.KEYSTORE_BASE64 }}\n      run: |\n        echo $ENCODED_STRING | base64 -di &gt; app/keystore.jks\n\n    - name: \ud83d\udce6 Build Release APK\n      env:\n        KEY_ALIAS: ${{ secrets.KEY_ALIAS }}\n        KEY_PASSWORD: ${{ secrets.KEY_PASSWORD }}\n        STORE_PASSWORD: ${{ secrets.STORE_PASSWORD }}\n      run: |\n        echo \"storeFile=app/keystore.jks\" &gt; keystore.properties\n        echo \"keyAlias=$KEY_ALIAS\" &gt;&gt; keystore.properties\n        echo \"keyPassword=$KEY_PASSWORD\" &gt;&gt; keystore.properties\n        echo \"storePassword=$STORE_PASSWORD\" &gt;&gt; keystore.properties\n        ./gradlew assembleRelease\n\n    - name: \ud83d\udce4 Upload Release APK\n      uses: actions/upload-artifact@v4\n      with:\n        name: release-apk\n        path: app/build/outputs/apk/release/*.apk\n</code></pre> <p>Add GitHub Secrets:</p> <ol> <li>Go to repository Settings \u2192 Secrets</li> <li>Add:<ul> <li><code>KEYSTORE_BASE64</code>: Base64-encoded keystore</li> <li><code>KEY_ALIAS</code>: Keystore alias</li> <li><code>KEY_PASSWORD</code>: Key password</li> <li><code>STORE_PASSWORD</code>: Store password</li> </ul> </li> </ol>"},{"location":"faq/#performance-questions","title":"Performance Questions","text":""},{"location":"faq/#how-do-i-optimize-compose-performance","title":"How do I optimize Compose performance?","text":"<p>Follow these patterns:</p>"},{"location":"faq/#1-use-remember-for-expensive-computations","title":"1. Use <code>remember</code> for Expensive Computations","text":"<pre><code>@Composable\nfun ExpensiveList(items: List&lt;Item&gt;) {\n    val processedItems = remember(items) {\n        items.map { /* expensive transformation */ }\n    }\n\n    LazyColumn {\n        items(processedItems) { item -&gt;\n            ItemCard(item = item)\n        }\n    }\n}\n</code></pre>"},{"location":"faq/#2-use-stable-keys-in-lazycolumn","title":"2. Use Stable Keys in <code>LazyColumn</code>","text":"<pre><code>LazyColumn {\n    items(\n        items = postsList,\n        key = { post -&gt; post.id }  // \u2705 Stable key\n    ) { post -&gt;\n        PostCard(post = post)\n    }\n}\n</code></pre>"},{"location":"faq/#3-avoid-creating-lambdas-in-composition","title":"3. Avoid Creating Lambdas in Composition","text":"<pre><code>// \u274c Bad - Creates new lambda on each recomposition\n@Composable\nfun PostCard(post: Post, onDelete: (Post) -&gt; Unit) {\n    JetpackButton(\n        onClick = { onDelete(post) },  // New lambda each time\n        text = { Text(\"Delete\") }\n    )\n}\n\n// \u2705 Good - Stable reference\n@Composable\nfun PostCard(post: Post, onDelete: (Post) -&gt; Unit) {\n    val onClick = remember(post) {\n        { onDelete(post) }\n    }\n\n    JetpackButton(\n        onClick = onClick,\n        text = { Text(\"Delete\") }\n    )\n}\n</code></pre>"},{"location":"faq/#4-use-derivedstateof-for-computed-values","title":"4. Use <code>derivedStateOf</code> for Computed Values","text":"<pre><code>@Composable\nfun SearchScreen(posts: List&lt;Post&gt;, query: String) {\n    val filteredPosts = remember(posts, query) {\n        derivedStateOf {\n            posts.filter { it.title.contains(query, ignoreCase = true) }\n        }\n    }.value\n\n    LazyColumn {\n        items(filteredPosts) { post -&gt;\n            PostCard(post = post)\n        }\n    }\n}\n</code></pre> <p>See performance.md for more optimization techniques.</p>"},{"location":"faq/#how-do-i-reduce-app-size","title":"How do I reduce app size?","text":""},{"location":"faq/#1-enable-r8proguard","title":"1. Enable R8/ProGuard","text":"<p>Already enabled in <code>app/build.gradle.kts</code>:</p> <pre><code>buildTypes {\n    release {\n        isMinifyEnabled = true  // \u2705 Enabled\n        proguardFiles(\n            getDefaultProguardFile(\"proguard-android-optimize.txt\"),\n            \"proguard-rules.pro\"\n        )\n    }\n}\n</code></pre>"},{"location":"faq/#2-enable-resource-shrinking","title":"2. Enable Resource Shrinking","text":"<pre><code>buildTypes {\n    release {\n        isMinifyEnabled = true\n        isShrinkResources = true  // Add this\n        proguardFiles(/*...*/)\n    }\n}\n</code></pre>"},{"location":"faq/#3-use-app-bundles","title":"3. Use App Bundles","text":"<pre><code># Instead of APK, build App Bundle\n./gradlew bundleRelease\n\n# Output: app/build/outputs/bundle/release/app-release.aab\n</code></pre>"},{"location":"faq/#4-analyze-apk-size","title":"4. Analyze APK Size","text":"<pre><code>./gradlew assembleRelease\n\n# Analyze\n./gradlew :app:analyzeReleaseBundle\n</code></pre>"},{"location":"faq/#firebase-questions","title":"Firebase Questions","text":""},{"location":"faq/#how-do-i-set-up-firebase-for-this-project","title":"How do I set up Firebase for this project?","text":"<p>Firebase is already configured in the template. You just need to add your project:</p>"},{"location":"faq/#1-create-firebase-project","title":"1. Create Firebase Project","text":"<ol> <li>Go to Firebase Console</li> <li>Click \"Add project\"</li> <li>Follow the wizard</li> </ol>"},{"location":"faq/#2-download-google-servicesjson","title":"2. Download <code>google-services.json</code>","text":"<ol> <li>In Firebase Console, go to Project Settings</li> <li>Under \"Your apps\", click \"Add app\" \u2192 Android</li> <li>Register app with package name: <code>dev.atick.compose</code></li> <li>Download <code>google-services.json</code></li> <li>Place in <code>app/google-services.json</code></li> </ol>"},{"location":"faq/#3-add-sha-1-fingerprint-for-google-sign-in","title":"3. Add SHA-1 Fingerprint (for Google Sign-In)","text":"<pre><code># Get debug SHA-1\n./gradlew signingReport\n\n# Copy SHA-1 from debug config\n# Add to Firebase Console \u2192 Project Settings \u2192 Your apps\n</code></pre>"},{"location":"faq/#4-enable-authentication-methods","title":"4. Enable Authentication Methods","text":"<ol> <li>Go to Firebase Console \u2192 Authentication</li> <li>Click \"Get Started\"</li> <li>Enable sign-in methods you need:<ul> <li>Email/Password</li> <li>Google</li> </ul> </li> </ol> <p>That's it! The template already includes:</p> <ul> <li>\u2705 Firebase Crashlytics (<code>firebase:analytics</code>)</li> <li>\u2705 Firebase Auth (<code>firebase:auth</code>)</li> <li>\u2705 Firebase Firestore (<code>firebase:firestore</code>)</li> <li>\u2705 Convention plugin for Firebase setup</li> </ul> <p>See firebase/auth/README.md for detailed authentication setup.</p>"},{"location":"faq/#why-is-google-sign-in-not-working","title":"Why is Google Sign-In not working?","text":"<p>Common causes:</p>"},{"location":"faq/#1-missing-sha-1-fingerprint","title":"1. Missing SHA-1 Fingerprint","text":"<pre><code># Get SHA-1\n./gradlew signingReport\n\n# Add to Firebase Console:\n# Project Settings \u2192 Your apps \u2192 SHA certificate fingerprints\n</code></pre>"},{"location":"faq/#2-wrong-package-name","title":"2. Wrong Package Name","text":"<p>Package name in Firebase Console must match <code>app/build.gradle.kts</code>:</p> <pre><code>defaultConfig {\n    applicationId = \"dev.atick.compose\"  // Must match Firebase\n}\n</code></pre>"},{"location":"faq/#3-credential-manager-not-available-android-14","title":"3. Credential Manager Not Available (Android &lt; 14)","text":"<p>Google Sign-In uses Credential Manager (Android 14+). On older devices, it falls back to standard Google Sign-In flow.</p> <p>Check implementation:</p> <pre><code>// firebase/auth/src/main/kotlin/.../AuthDataSource.kt\noverride suspend fun signInWithGoogle(activity: Activity): Result&lt;AuthUser&gt; {\n    return suspendRunCatching {\n        try {\n            // Try Credential Manager first (Android 14+)\n            val credential = credentialManager.getCredential(...)\n            // ...\n        } catch (e: Exception) {\n            // Fallback for older devices\n            // Implement traditional Google Sign-In\n        }\n    }\n}\n</code></pre> <p>See troubleshooting.md for more solutions.</p>"},{"location":"faq/#additional-resources","title":"Additional Resources","text":""},{"location":"faq/#documentation-guides","title":"Documentation Guides","text":"<ul> <li>Architecture: architecture.md</li> <li>State Management: state-management.md</li> <li>Components: components.md</li> <li>Data Flow: data-flow.md</li> <li>Navigation: navigation.md</li> <li>Dependency Injection: dependency-injection.md</li> <li>Troubleshooting: troubleshooting.md</li> <li>Quick Reference: quick-reference.md</li> </ul>"},{"location":"faq/#module-documentation","title":"Module Documentation","text":"<ul> <li>Core UI: core/ui/README.md - UI components and state management   utilities</li> <li>Data Layer: data/README.md - Repository patterns and data sources</li> <li>Firebase Auth: firebase/auth/README.md - Firebase Authentication   integration</li> <li>Firebase Firestore: firebase/firestore/README.md - Cloud   Firestore integration</li> <li>Sync: sync/README.md - Background data synchronization</li> <li>App Module: app/README.md - Main application architecture</li> </ul> <p>Note</p> <p>API Documentation is available after running <code>./gradlew dokkaGeneratePublicationHtml</code>. The generated docs will be at <code>build/dokka/html/index.html</code>.</p>"},{"location":"faq/#still-have-questions","title":"Still Have Questions?","text":"<p>If your question isn't answered here:</p> <ol> <li>Check the Troubleshooting Guide</li> <li>Search existing GitHub Issues</li> <li>Create a new issue with:<ul> <li>Clear description of the problem</li> <li>Steps to reproduce</li> <li>Expected vs actual behavior</li> <li>Relevant code snippets</li> <li>Android Studio version and device info</li> </ul> </li> </ol>"},{"location":"fastlane/","title":"Fastlane and Play Store Setup","text":""},{"location":"fastlane/#summary","title":"Summary","text":"<p>This guide explains how to set up Fastlane for automated Play Store deployments. Learn how to configure Play Store authentication with service account JSON, manage metadata and changelogs, deploy updates to different tracks (internal/alpha/beta/production), and troubleshoot common deployment issues.</p> <p>This project uses Fastlane to automate Play Store deployments. This guide will help you set up Fastlane for your deployment needs.</p>"},{"location":"fastlane/#prerequisites","title":"Prerequisites","text":"<p>Before you begin, make sure you have:</p> <ol> <li>Ruby installed (version 2.5 or higher)</li> <li>Bundler installed (<code>gem install bundler</code>)</li> <li>A Google Play Console account with access to your app</li> <li>A Play Store API service account (JSON key file)</li> </ol> <p>Note</p> <p>For detailed instructions about setting up Fastlane for Android, refer to the official Android setup guide.</p>"},{"location":"fastlane/#initial-setup","title":"Initial Setup","text":"<ol> <li> <p>Install Fastlane:    <pre><code>gem install fastlane\n</code></pre></p> </li> <li> <p>Set up Play Store authentication:</p> <ul> <li>Follow   the Fastlane Play Store Setup Guide   to create and download your <code>play-store.json</code> service account key</li> <li>Place the <code>play-store.json</code> file in your fastlane directory</li> </ul> </li> </ol> <p>Warning</p> <p>Never commit your <code>play-store.json</code> file to the repository. Make sure it's included in your</p> <p><code>.gitignore</code>.</p>"},{"location":"fastlane/#configure-fastlane-files","title":"Configure Fastlane Files","text":""},{"location":"fastlane/#appfile-configuration","title":"Appfile Configuration","text":"<p>Edit the <code>fastlane/Appfile</code> to configure your app-specific information:</p> <pre><code>json_key_file(\"fastlane/play-store.json\") # Path to your Play Store service account json file\npackage_name(\"dev.your.package.name\") # Your app's package name\n</code></pre>"},{"location":"fastlane/#fastfile-configuration","title":"Fastfile Configuration","text":"<p>Edit the <code>fastlane/Fastfile</code> to define your deployment lanes:</p> <pre><code>default_platform(:android)\n\nplatform :android do\n  desc \"Deploy a new version to the Google Play\"\n  lane :deploy do\n    # Upload to Play Store\n    upload_to_play_store(\n      track: 'internal', # or 'alpha', 'beta', 'production'\n      aab: '../app/build/outputs/bundle/release/app-release.aab',\n      skip_upload_metadata: true,\n      skip_upload_images: true,\n      skip_upload_screenshots: true,\n      release_status: \"completed\",\n      version_code: ENV[\"VERSION_CODE\"].to_i\n    )\n  end\nend\n</code></pre>"},{"location":"fastlane/#metadata-management","title":"Metadata Management","text":"<p>The project includes a standard Fastlane metadata structure:</p> <pre><code>metadata/\n\u2514\u2500\u2500 android/\n    \u2514\u2500\u2500 en-US/\n        \u251c\u2500\u2500 changelogs/\n        \u251c\u2500\u2500 images/\n        \u251c\u2500\u2500 full_description.txt\n        \u251c\u2500\u2500 short_description.txt\n        \u251c\u2500\u2500 title.txt\n        \u2514\u2500\u2500 video.txt\n</code></pre> <p>To pull existing metadata from Play Store:</p> <pre><code>fastlane supply init\n</code></pre> <p>Important</p> <p>For <code>supply</code> to be able to initialize, you need to have successfully uploaded an APK to your app in the Google Play Console at least once.</p> <p>Note</p> <p>This command downloads all your existing Play Store metadata and screenshots. It's useful when setting up a new machine or CI environment.</p>"},{"location":"fastlane/#deploying-updates","title":"Deploying Updates","text":"<ol> <li> <p>Update your changelog:</p> <ul> <li>Edit <code>fastlane/metadata/android/en-US/changelogs/default.txt</code></li> <li>Or create a version-specific changelog: <code>changelogs/&lt;version_code&gt;.txt</code></li> </ul> </li> <li> <p>Update app metadata (if needed):</p> <ul> <li>Edit relevant files in <code>metadata/android/en-US/</code></li> <li>Update screenshots in <code>metadata/android/en-US/images/</code></li> </ul> </li> <li> <p>Run deployment:    <pre><code>fastlane android deploy\n</code></pre></p> </li> </ol> <p>Tip</p> <p>Our GitHub Actions workflow automatically runs the deployment when you create a new release tag. See the GitHub CI/CD guide for details.</p>"},{"location":"fastlane/#troubleshooting-common-issues","title":"Troubleshooting Common Issues","text":"<ol> <li> <p>Authentication Errors:</p> <ul> <li>Verify your <code>play-store.json</code> file is correctly placed</li> <li>Ensure the service account has appropriate permissions in Play Console</li> <li>Check if the JSON key is properly formatted</li> </ul> </li> <li> <p>Upload Failures:</p> <ul> <li>Verify your app's version code is incremented</li> <li>Ensure the APK/AAB is properly signed</li> <li>Check if the track (internal/alpha/beta/production) exists</li> </ul> </li> <li> <p>Metadata Issues:</p> <ul> <li>Validate all required metadata files exist</li> <li>Check character limits in descriptions</li> <li>Ensure screenshot dimensions meet Play Store requirements</li> </ul> </li> </ol> <p>Note</p> <p>For more detailed information about Fastlane commands and options, refer to the Fastlane supply action documentation.</p>"},{"location":"fastlane/#further-reading","title":"Further Reading","text":"<ul> <li>GitHub CI/CD Setup - Automated release workflow that uses Fastlane</li> <li>Troubleshooting - Solutions for common deployment issues</li> <li>FAQ - Release preparation and deployment questions</li> </ul>"},{"location":"firebase/","title":"Firebase Setup","text":""},{"location":"firebase/#summary","title":"Summary","text":"<p>This guide walks you through setting up Firebase for this project, including Authentication (Google Sign-In and Email/Password), Firestore database, and Analytics. Learn how to configure the Firebase Console, download and protect <code>google-services.json</code>, set up security rules, and troubleshoot common Firebase issues.</p> <p>This project uses Firebase for authentication, Firestore database, and analytics. Follow this guide to set up Firebase for your project.</p>"},{"location":"firebase/#prerequisites","title":"Prerequisites","text":"<ul> <li>A Google account</li> <li>Access to Firebase Console</li> <li>Android Studio</li> </ul>"},{"location":"firebase/#firebase-console-setup","title":"Firebase Console Setup","text":"<ol> <li> <p>Create a new project in Firebase Console:</p> <ul> <li>Go to Firebase Console</li> <li>Click \"Add project\"</li> <li>Enter your project name</li> <li>Follow the setup wizard</li> </ul> </li> <li> <p>Add Android app to your Firebase project:</p> <ul> <li>Click on Android icon in project overview</li> <li>Register app using your package name (<code>dev.your.package.name</code>)</li> <li>Get the SHA-1 using the provided Signing Report configuration:<ul> <li>Open Android Studio</li> <li>Run the \"Signing Report\" configuration from the run configurations dropdown</li> <li>Copy the SHA-1 hash</li> </ul> </li> <li>Enter the SHA-1 in Firebase console</li> </ul> </li> <li> <p>Enable Required Services:</p> </li> </ol> <p>a. Authentication:     - Go to \"Authentication\" in Firebase Console     - Click \"Get Started\"     - Enable \"Google\" sign-in method     - Enable \"Email/Password\" sign-in method     - Add your support email</p> <p>b. Firestore:     - Go to \"Firestore Database\"     - Click \"Create Database\"     - Choose your location     - Start in production mode</p>"},{"location":"firebase/#local-project-setup","title":"Local Project Setup","text":"<ol> <li> <p>Download Configuration File:</p> <ul> <li>Download <code>google-services.json</code> from Firebase Console</li> <li>Before replacing the template file, stop Git from tracking it:   <pre><code>git update-index --skip-worktree app/google-services.json\n</code></pre></li> <li>Replace the template <code>google-services.json</code> in the <code>app</code> directory with your downloaded file</li> </ul> </li> <li> <p>Verify Firebase Setup:</p> <ul> <li>Build and run the app</li> <li>Try signing in with Google</li> <li>Check Firebase Console to verify authentication is working</li> </ul> </li> </ol> <p>Warning</p> <p>Never commit your actual <code>google-services.json</code> to version control. The template file is provided only to ensure successful builds.</p>"},{"location":"firebase/#troubleshooting","title":"Troubleshooting","text":"<p>Common issues and solutions:</p> <ol> <li> <p>Google Sign-In Not Working:</p> <ul> <li>Verify SHA-1 is correctly added in Firebase Console</li> <li>Check if <code>google-services.json</code> is up to date</li> <li>Ensure the OAuth consent screen is configured</li> </ul> </li> <li> <p>Firestore Access Issues:</p> <ul> <li>Check your Firestore rules</li> <li>Verify your device has internet connection</li> <li>Check if the user is properly authenticated</li> </ul> </li> <li> <p>Build Issues:</p> <ul> <li>Clean and rebuild the project</li> <li>Verify <code>google-services.json</code> is in the correct location</li> <li>Check if all Firebase dependencies are resolved</li> </ul> </li> </ol> <p>Tip</p> <p>If you need to get the SHA-1 hash again later, you can always run the \"Signing Report\" configuration from Android Studio.</p>"},{"location":"firebase/#firebase-configuration-files","title":"Firebase Configuration Files","text":"<p>The project handles Firebase configuration files in several ways:</p> <ol> <li> <p>Development:</p> <ul> <li>Use your local <code>google-services.json</code></li> <li>Keep it private using <code>git update-index --skip-worktree</code></li> </ul> </li> <li> <p>CI/CD:</p> <ul> <li>GitHub Actions workflow uses encoded secrets</li> <li>See GitHub CI/CD Setup for details</li> </ul> </li> </ol> <p>Note</p> <p>The template <code>google-services.json</code> allows the project to build but won't enable Firebase services. You must replace it with your own configuration file.</p>"},{"location":"firebase/#firestore-security-rules","title":"Firestore Security Rules","text":"<p>Set up security rules in Firebase Console to protect your data:</p> <ol> <li>Go to Firestore Database</li> <li>Click on \"Rules\" tab</li> <li>Replace the default rules with the following structure:</li> </ol> <pre><code>rules_version = '2';\nservice cloud.firestore {\n  match /databases/{database}/documents {\n    // Helper function to check if user is authenticated\n    function isAuthenticated() {\n      return request.auth != null;\n    }\n\n    // Helper function to check if the user is accessing their own data\n    function isUserOwner(userId) {\n      return isAuthenticated() &amp;&amp; request.auth.uid == userId;\n    }\n\n    // Helper function to validate Jetpack data structure\n    function isValidJetpack(jetpack) {\n      return jetpack.size() == 7\n        &amp;&amp; 'id' in jetpack &amp;&amp; jetpack.id is string\n        // ... other validations\n    }\n\n    // Match the specific path structure: dev.atick.jetpack/{userId}/jetpacks/{jetpackId}\n    match /dev.atick.jetpack/{userId}/jetpacks/{jetpackId} {\n      allow read: if isUserOwner(userId);\n\n      allow create: if isUserOwner(userId) \n        &amp;&amp; isValidJetpack(request.resource.data);\n\n      allow update: if isUserOwner(userId) \n        &amp;&amp; isValidJetpack(request.resource.data)\n        &amp;&amp; request.resource.data.id == resource.data.id;\n\n      allow delete: if isUserOwner(userId);\n    }\n\n    // Deny access to all other documents by default\n    match /{document=**} {\n      allow read, write: if false;\n    }\n  }\n}\n</code></pre> <p>These rules implement several security features:</p> <ul> <li>User authentication check</li> <li>Data ownership validation</li> <li>Document structure validation</li> <li>Explicit deny-by-default for unmatched paths</li> </ul> <p>Important</p> <p>Always test your security rules thoroughly using the Firebase Console Rules Playground before deploying to production.</p>"},{"location":"firebase/#additional-setup","title":"Additional Setup","text":"<ol> <li>Test Your Configuration:</li> </ol> <pre><code>// Add this in an activity or fragment\nFirebaseAuth.getInstance().currentUser?.let {\n  Timber.d(\"Firebase Auth is working: ${it.email}\")\n}\n</code></pre> <ol> <li>Reset Git Tracking (if needed):</li> </ol> <pre><code>git update-index --no-skip-worktree app/google-services.json\n</code></pre> <ol> <li>Multiple Environments:<ul> <li>Create separate Firebase projects for development and production</li> <li>Manage different <code>google-services.json</code> files for each build variant</li> </ul> </li> </ol> <p>Important</p> <p>Remember to add your <code>google-services.json</code> to <code>.gitignore</code> if you're setting up the project from scratch.</p>"},{"location":"firebase/#further-reading","title":"Further Reading","text":"<ul> <li>Troubleshooting - Solutions for common Firebase setup and runtime issues</li> <li>GitHub CI/CD Setup - CI/CD workflow that uses Firebase secrets</li> <li>FAQ - Firebase setup questions and Google Sign-In troubleshooting</li> </ul>"},{"location":"getting-started/","title":"Getting Started","text":"<p>This guide helps you set up and run the project on your local machine. You'll learn how to clone the repository, configure Firebase, and prepare for release builds.</p>"},{"location":"getting-started/#summary","title":"Summary","text":"<p>Get started quickly with the Jetpack Android Starter template:</p> <ol> <li>Clone the repository and open in Android Studio</li> <li>Build and run the debug variant out of the box</li> <li>Optionally configure Firebase for authentication and Firestore</li> <li>Set up signing configuration for release builds</li> </ol> <p>The debug variant works immediately with minimal setup. Firebase configuration and release builds are optional until you're ready to use those features.</p>"},{"location":"getting-started/#quick-start","title":"Quick Start","text":"<p>Clone the repository (with depth 1 to reduce clone size):</p> <pre><code>git clone --depth 1 -b main https://github.com/atick-faisal/Jetpack-Android-Starter.git\n</code></pre> <p>Open the project in Android Studio Hedgehog or newer</p> <p>Run the debug build variant:</p> <pre><code>./gradlew assembleDebug\n</code></pre> <p>Note</p> <p>The debug variant works out of the box with the template <code>google-services.json</code> file. However, Firebase features like authentication and Firestore won't be functional until you set up your own Firebase project.</p>"},{"location":"getting-started/#prerequisites","title":"Prerequisites","text":"<ul> <li>Android Studio Hedgehog or newer</li> <li>JDK 21</li> <li>An Android device or emulator running API 24 (Android 7.0) or higher</li> </ul>"},{"location":"getting-started/#setting-up-firebase-features","title":"Setting Up Firebase Features","text":"<p>This project includes Firebase integration for authentication, Firestore, and analytics. The debug variant works out of the box with a template <code>google-services.json</code>, but Firebase features won't be functional until you configure your own Firebase project.</p> <p>Note</p> <p>For complete Firebase setup instructions, see the Firebase Setup Guide. The guide covers: - Creating your Firebase project - Configuring Authentication (Google Sign-In and Email/Password) - Setting up Firestore database - Downloading and configuring <code>google-services.json</code> - Setting up security rules - Troubleshooting common Firebase issues</p>"},{"location":"getting-started/#release-build-setup","title":"Release Build Setup","text":"<p>To create release builds, you need to set up signing:</p> <p>Create a keystore file using Android Studio's \"Generate Signed Bundle/APK\" tool</p> <p>Create <code>keystore.properties</code> in the project root:</p> <pre><code>storePassword=your-store-password\nkeyPassword=your-key-password\nkeyAlias=your-key-alias\nstoreFile=your-keystore-file.jks\n</code></pre> <p>Place your keystore file in the <code>app/</code> directory</p> <p>Build the release variant:</p> <pre><code>./gradlew assembleRelease\n</code></pre> <p>Tip</p> <p>Use Android Studio's \"Generate Signed Bundle/APK\" tool to create your keystore if you don't have one.</p>"},{"location":"getting-started/#next-steps","title":"Next Steps","text":"<p>After getting the project running, continue with these guides:</p> <p>Understand the Architecture - Read the Architecture Overview to understand how the app is structured</p> <p>Setup CI/CD - Follow the GitHub CI/CD Guide to set up automation</p> <p>Code Style - Review the Spotless Setup for code formatting guidelines</p>"},{"location":"getting-started/#common-issues","title":"Common Issues","text":"<p>Build Fails:</p> <ul> <li>Ensure you have JDK 21 set in Android Studio</li> <li>Run <code>./gradlew clean</code> and try again</li> <li>Check if all dependencies are resolved</li> </ul> <p>Firebase Features Not Working:</p> <ul> <li>Verify you've replaced <code>google-services.json</code></li> <li>Check Firebase Console for proper setup</li> <li>Ensure SHA-1 is added for authentication</li> </ul> <p>Release Build Fails:</p> <ul> <li>Verify <code>keystore.properties</code> exists and has correct values</li> <li>Confirm keystore file is in the correct location</li> <li>Check signing configuration in <code>app/build.gradle.kts</code></li> </ul> <p>Important</p> <p>Never commit sensitive files like <code>keystore.properties</code>, your keystore file, or your real <code>google-services.json</code> to version control.</p> <p>For more troubleshooting help, see the Troubleshooting Guide.</p>"},{"location":"getting-started/#ide-setup","title":"IDE Setup","text":"<p>For the best development experience:</p> <p>Enable Compose Preview:</p> <ul> <li>Ensure \"Live Edit of Literals\" is enabled</li> <li>Configure appropriate preview devices</li> </ul> <p>Run Configurations:</p> <ul> <li>Use provided run configurations for common tasks</li> <li>Signing Report configuration helps get SHA-1 for Firebase</li> </ul> <p>Code Style:</p> <ul> <li>Import the project's <code>.editorconfig</code></li> <li>Enable \"Format on Save\" for Kotlin files</li> <li>Use the Spotless plugin for consistent formatting</li> </ul>"},{"location":"getting-started/#further-reading","title":"Further Reading","text":"<ul> <li>Firebase Setup Guide - Configure Firebase features in your project</li> <li>Architecture Overview - Learn about the app's architecture</li> <li>Design Philosophy - Understand the design principles</li> <li>Adding New Features - Step-by-step feature implementation guide</li> <li>Dependency Management - Understand dependency management</li> <li>Convention Plugins - Learn about custom Gradle plugins</li> <li>Spotless Setup - Code formatting and style enforcement</li> <li>GitHub CI/CD - Continuous integration and deployment</li> <li>Performance Optimization - Optimize app speed and efficiency</li> <li>Tips &amp; Tricks - Useful development and debugging tips</li> <li>Publishing to Play Store - Deploy your app to Google Play</li> </ul>"},{"location":"github/","title":"GitHub CI/CD Setup","text":""},{"location":"github/#summary","title":"Summary","text":"<p>This guide explains the project's three GitHub Actions workflows: Build (runs on PRs with Spotless checks), Documentation (deploys to GitHub Pages), and Release (builds signed APKs and deploys to Play Store). Learn how to set up required secrets, create releases with tags, and troubleshoot failed workflows.</p> <p>This project uses GitHub Actions for continuous integration and deployment. We have three main workflows:</p>"},{"location":"github/#build-workflow","title":"Build Workflow","text":"<p>The build workflow runs on every pull request and when libraries are updated. It performs the following tasks:</p> <ul> <li>Validates Gradle wrapper</li> <li>Sets up JDK 21</li> <li>Runs code style checks using Spotless</li> <li>Builds the project</li> </ul> <p>Note</p> <p>The build workflow runs automatically and requires no additional setup.</p>"},{"location":"github/#documentation-workflow","title":"Documentation Workflow","text":"<p>The documentation workflow runs whenever changes are pushed to the main branch. It:</p> <ul> <li>Sets up Python and required dependencies</li> <li>Generates API documentation using Dokka</li> <li>Deploys documentation to GitHub Pages</li> </ul> <p>Note</p> <p>The documentation workflow runs automatically and requires no additional setup. Make sure your repository has GitHub Pages enabled in the settings.</p>"},{"location":"github/#release-workflow","title":"Release Workflow","text":"<p>The release workflow is triggered when you push a tag with the format <code>v*.*.*</code> (e.g., v1.0.0). It:</p> <ul> <li>Builds a signed release APK</li> <li>Creates a GitHub release with the APK</li> <li>Deploys to Google Play Store using Fastlane</li> </ul>"},{"location":"github/#prerequisites","title":"Prerequisites","text":"<p>Before you can use the release workflow, you need to set up the following GitHub secrets:</p> <ol> <li> <p><code>GOOGLE_SERVICES</code>: Base64 encoded content of your <code>google-services.json</code> file    <pre><code>base64 -i google-services.json | tr -d '\\n'\n</code></pre></p> </li> <li> <p><code>KEYSTORE</code>: Base64 encoded content of your keystore file    <pre><code>base64 -i your-keystore.jks | tr -d '\\n'\n</code></pre></p> </li> <li> <p><code>KEYSTORE_PROPERTIES</code>: Base64 encoded content of your keystore.properties file containing:    <pre><code>storeFile=key.jks\nstorePassword=your-store-password\nkeyAlias=your-key-alias\nkeyPassword=your-key-password\n</code></pre></p> </li> <li> <p><code>PLAY_STORE_JSON</code>: Base64 encoded content of your <code>play-store.json</code> file    <pre><code>base64 -i play-store.json | tr -d '\\n'\n</code></pre></p> </li> </ol> <p>Warning</p> <p>Never commit your keystore file, keystore properties, google-services.json or play-store.json directly to the repository.</p>"},{"location":"github/#creating-a-release","title":"Creating a Release","text":"<p>To create a new release:</p> <ol> <li>Update the <code>CHANGELOG.md</code> file with your release notes</li> <li>Create and push a new tag:    <pre><code>git tag -a v1.0.0 -m \"Release v1.0.0\"\ngit push origin v1.0.0\n</code></pre></li> </ol> <p>The workflow will automatically:</p> <ul> <li>Generate a signed APK</li> <li>Create a GitHub release with the changelog</li> <li>Upload the APK to the release</li> <li>Deploy to Play Store via Fastlane</li> </ul> <p>Tip</p> <p>Make sure your Fastlane setup is complete before using the release workflow. See the Fastlane Setup guide for details.</p>"},{"location":"github/#debugging-failed-releases","title":"Debugging Failed Releases","text":"<p>If the release workflow fails, check:</p> <ol> <li>GitHub Secrets are properly set</li> <li>Tag format follows <code>v*.*.*</code> pattern</li> <li><code>CHANGELOG.md</code> exists and is properly formatted</li> <li>Fastlane configuration is correct</li> <li>Keystore and signing configuration match Play Store requirements</li> </ol> <p>Note</p> <p>The workflow timeout is set to 45 minutes. For large projects, you might need to adjust this in the workflow file.</p>"},{"location":"github/#further-reading","title":"Further Reading","text":"<ul> <li>Fastlane Setup - Play Store deployment automation used by release workflow</li> <li>Firebase Setup - Firebase configuration needed for release builds</li> <li>Spotless - Code formatting checked by build workflow</li> </ul>"},{"location":"guide/","title":"Adding a New Feature","text":"<p>This guide walks you through the complete process of adding a new feature to the app, following established patterns and best practices.</p>"},{"location":"guide/#summary","title":"Summary","text":"<p>To add a new feature to this template, follow this workflow:</p> <ol> <li>Define data models - Create network, database, and repository models</li> <li>Create data sources - Implement network and local data sources</li> <li>Create repository - Coordinate data sources and handle errors</li> <li>Create UI layer - Build ViewModel with Screen Data and composables</li> <li>Set up navigation - Define type-safe routes and navigation extensions</li> <li>Configure DI - Wire everything together with Hilt modules</li> </ol> <p>This guide provides complete code examples for each step, showing the exact patterns used in this template.</p>"},{"location":"guide/#overview-of-steps","title":"Overview of Steps","text":"<ol> <li>Define data models</li> <li>Create/update data sources</li> <li>Create repository layer</li> <li>Create UI layer</li> <li>Set up navigation</li> <li>Configure dependency injection</li> </ol>"},{"location":"guide/#step-1-data-models","title":"Step 1: Data Models","text":""},{"location":"guide/#11-data-source-models","title":"1.1 Data Source Models","text":"<p>Create models in the appropriate core module (for example, <code>core:network</code> or <code>core:room</code>). Create new core modules if needed:</p> <pre><code>// core/network/src/main/kotlin/dev/atick/core/network/model/NetworkFeature.kt\n@Serializable\ndata class NetworkFeature(\n    val id: String,\n    val name: String,\n    val createdAt: Long = System.currentTimeMillis()\n)\n\n// core/room/src/main/kotlin/dev/atick/core/room/model/FeatureEntity.kt\n@Entity(tableName = \"features\")\ndata class FeatureEntity(\n    @PrimaryKey val id: String,\n    val name: String,\n    val lastSynced: Long = 0,\n    val needsSync: Boolean = true\n)\n</code></pre>"},{"location":"guide/#step-2-data-sources","title":"Step 2: Data Sources","text":""},{"location":"guide/#21-network-data-source","title":"2.1 Network Data Source","text":"<pre><code>// core/network/src/main/kotlin/dev/atick/core/network/data/\ninterface NetworkDataSource {\n    suspend fun getFeatures(): List&lt;NetworkFeature&gt;\n    suspend fun createFeature(feature: NetworkFeature)\n}\n\nclass NetworkDataSourceImpl @Inject constructor(\n    private val api: FeatureApi,\n    @IoDispatcher private val ioDispatcher: CoroutineDispatcher\n) : NetworkDataSource {\n    override suspend fun getFeatures(): List&lt;NetworkFeature&gt; =\n        withContext(ioDispatcher) {\n            api.getFeatures()\n        }\n\n    override suspend fun createFeature(feature: NetworkFeature) =\n        withContext(ioDispatcher) {\n            api.createFeature(feature)\n        }\n}\n</code></pre>"},{"location":"guide/#22-local-data-source","title":"2.2 Local Data Source","text":"<pre><code>// core/room/src/main/kotlin/dev/atick/core/room/data/\ninterface LocalDataSource {\n    fun observeFeatures(): Flow&lt;List&lt;FeatureEntity&gt;&gt;\n    suspend fun saveFeatures(features: List&lt;FeatureEntity&gt;)\n}\n\nclass LocalDataSourceImpl @Inject constructor(\n    private val featureDao: FeatureDao,\n    @IoDispatcher private val ioDispatcher: CoroutineDispatcher\n) : LocalDataSource {\n    override fun observeFeatures(): Flow&lt;List&lt;FeatureEntity&gt;&gt; =\n        featureDao.observeFeatures()\n            .flowOn(ioDispatcher)\n\n    override suspend fun saveFeatures(features: List&lt;FeatureEntity&gt;) =\n        withContext(ioDispatcher) {\n            featureDao.insertFeatures(features)\n        }\n}\n</code></pre> <p>Note</p> <p>Always use <code>withContext(ioDispatcher)</code> in data sources to ensure operations run on the IO thread.</p>"},{"location":"guide/#step-3-repository-layer","title":"Step 3: Repository Layer","text":""},{"location":"guide/#31-feature-models","title":"3.1 Feature Models","text":"<pre><code>// data/src/main/kotlin/dev/atick/data/model/Feature.kt\ndata class Feature(\n    val id: String,\n    val name: String,\n    val lastSynced: Long = 0\n)\n\n// Conversion Functions\nfun NetworkFeature.toFeature() = Feature(\n    id = id,\n    name = name\n)\n\nfun FeatureEntity.toFeature() = Feature(\n    id = id,\n    name = name,\n    lastSynced = lastSynced\n)\n\nfun Feature.toEntity() = FeatureEntity(\n    id = id,\n    name = name,\n    lastSynced = lastSynced\n)\n</code></pre>"},{"location":"guide/#32-repository-implementation","title":"3.2 Repository Implementation","text":"<pre><code>// data/src/main/kotlin/dev/atick/data/repository/\ninterface FeatureRepository {\n    fun observeFeatures(): Flow&lt;List&lt;Feature&gt;&gt;\n    suspend fun createFeature(feature: Feature): Result&lt;Unit&gt;\n    suspend fun syncFeatures(): Result&lt;Unit&gt;\n}\n\nclass FeatureRepositoryImpl @Inject constructor(\n    private val localDataSource: LocalDataSource,\n    private val networkDataSource: NetworkDataSource\n) : FeatureRepository {\n    override fun observeFeatures(): Flow&lt;List&lt;Feature&gt;&gt; =\n        localDataSource.observeFeatures()\n            .map { entities -&gt; entities.map { it.toFeature() } }\n\n    override suspend fun createFeature(feature: Feature): Result&lt;Unit&gt; =\n        suspendRunCatching {\n            networkDataSource.createFeature(feature.toNetworkFeature())\n            localDataSource.saveFeature(feature.toEntity())\n        }\n\n    override suspend fun syncFeatures(): Result&lt;Unit&gt; =\n        suspendRunCatching {\n            val networkFeatures = networkDataSource.getFeatures()\n            val entities = networkFeatures.map { it.toFeature().toEntity() }\n            localDataSource.saveFeatures(entities)\n        }\n}\n</code></pre> <p>Tip</p> <p>Use <code>suspendRunCatching</code> in repositories to handle errors consistently.</p> <p>Note</p> <p>This is a minimal repository example for the tutorial. For detailed repository patterns including offline-first with sync metadata, network-only, local-only, error handling, and caching strategies, see the Data Module README.</p>"},{"location":"guide/#step-4-ui-layer","title":"Step 4: UI Layer","text":""},{"location":"guide/#41-screen-data","title":"4.1 Screen Data","text":"<pre><code>// feature/feature-name/src/main/kotlin/dev/atick/feature/model/\ndata class FeatureScreenData(\n    val features: List&lt;Feature&gt; = emptyList(),\n    val newFeatureName: String = \"\"\n)\n</code></pre>"},{"location":"guide/#42-viewmodel","title":"4.2 ViewModel","text":"<pre><code>// feature/feature-name/src/main/kotlin/dev/atick/feature/ui/\n@HiltViewModel\nclass FeatureViewModel @Inject constructor(\n    private val featureRepository: FeatureRepository\n) : ViewModel() {\n    private val _uiState = MutableStateFlow(UiState(FeatureScreenData()))\n    val uiState = _uiState.asStateFlow()\n\n    init {\n        observeFeatures()\n    }\n\n    private fun observeFeatures() {\n        featureRepository.observeFeatures()\n            .onEach { features -&gt;\n                _uiState.updateState {\n                    copy(features = features)\n                }\n            }\n            .launchIn(viewModelScope)\n    }\n\n    fun updateFeatureName(name: String) {\n        _uiState.updateState {\n            copy(newFeatureName = name)\n        }\n    }\n\n    fun createFeature() {\n        _uiState.updateStateWith {\n            val feature = Feature(\n                id = UUID.randomUUID().toString(),\n                name = newFeatureName\n            )\n            featureRepository.createFeature(feature)\n        }\n    }\n}\n</code></pre>"},{"location":"guide/#43-ui-components","title":"4.3 UI Components","text":"<pre><code>// feature/feature-name/src/main/kotlin/dev/atick/feature/ui/\n@Composable\nfun FeatureRoute(\n    onShowSnackbar: suspend (String, SnackbarAction, Throwable?) -&gt; Boolean,\n    viewModel: FeatureViewModel = hiltViewModel()\n) {\n    val uiState by viewModel.uiState.collectAsStateWithLifecycle()\n\n    StatefulComposable(\n        state = uiState,\n        onShowSnackbar = onShowSnackbar\n    ) { screenData -&gt;\n        FeatureScreen(\n            screenData = screenData,\n            onNameChange = viewModel::updateFeatureName,\n            onCreateFeature = viewModel::createFeature\n        )\n    }\n}\n\n@Composable\nprivate fun FeatureScreen(\n    screenData: FeatureScreenData,\n    onNameChange: (String) -&gt; Unit,\n    onCreateFeature: () -&gt; Unit\n) {\n    Column(modifier = Modifier.fillMaxSize()) {\n        // UI Implementation\n    }\n}\n</code></pre>"},{"location":"guide/#step-5-navigation","title":"Step 5: Navigation","text":"<p>This section shows the minimal navigation code needed when adding a new feature. For comprehensive navigation patterns and best practices, see the Navigation Deep Dive guide.</p> <pre><code>// feature/feature-name/src/main/kotlin/dev/atick/feature/navigation/\n@Serializable\ndata object FeatureNavGraph\n\n@Serializable\ndata object Feature\n\nfun NavController.navigateToFeature(\n    navOptions: NavOptions? = null\n) {\n    navigate(Feature, navOptions)\n}\n\nfun NavGraphBuilder.featureScreen(\n    onShowSnackbar: suspend (String, SnackbarAction, Throwable?) -&gt; Boolean\n) {\n    composable&lt;Feature&gt; {\n        FeatureRoute(onShowSnackbar = onShowSnackbar)\n    }\n}\n\nfun NavGraphBuilder.featureNavGraph(\n    nestedGraphs: NavGraphBuilder.() -&gt; Unit\n) {\n    navigation&lt;FeatureNavGraph&gt;(\n        startDestination = Feature\n    ) {\n        nestedGraphs()\n    }\n}\n</code></pre>"},{"location":"guide/#step-6-dependency-injection","title":"Step 6: Dependency Injection","text":""},{"location":"guide/#61-data-source-module","title":"6.1 Data Source Module","text":"<pre><code>@Module\n@InstallIn(SingletonComponent::class)\nabstract class DataSourceModule {\n    @Binds\n    @Singleton\n    abstract fun bindNetworkDataSource(\n        impl: NetworkDataSourceImpl\n    ): NetworkDataSource\n}\n</code></pre>"},{"location":"guide/#62-repository-module","title":"6.2 Repository Module","text":"<pre><code>@Module\n@InstallIn(SingletonComponent::class)\nabstract class RepositoryModule {\n    @Binds\n    @Singleton\n    abstract fun bindFeatureRepository(\n        impl: FeatureRepositoryImpl\n    ): FeatureRepository\n}\n</code></pre>"},{"location":"guide/#best-practices-reminder","title":"Best Practices Reminder","text":"<p>Data Sources:</p> <ul> <li>Use <code>withContext(ioDispatcher)</code> for IO operations</li> <li>Handle raw data models</li> <li>One responsibility per data source</li> </ul> <p>Repositories:</p> <ul> <li>Use <code>suspendRunCatching</code> for error handling</li> <li>Convert between data models</li> <li>Coordinate between data sources</li> </ul> <p>ViewModels:</p> <ul> <li>Use <code>updateState</code>, <code>updateStateWith</code>, and <code>updateWith</code> utilities</li> <li>Handle UI logic and state management</li> <li>Convert to Screen Data</li> </ul> <p>UI Components:</p> <ul> <li>Use <code>StatefulComposable</code> for consistent loading/error handling</li> <li>Keep composables pure and state-driven</li> <li>Separate route from screen implementation</li> </ul> <p>Important</p> <p>Always follow the unidirectional data flow pattern: UI Events \u2192 ViewModel \u2192 Repository \u2192 Data Sources \u2192 Back to UI through StateFlow.</p>"},{"location":"guide/#testing","title":"Testing","text":"<p>Note</p> <p>Testing infrastructure is upcoming. The template doesn't currently include test examples, but you should add tests for production apps.</p> <p>Remember to add tests for your new feature:</p> <p>Data Source Tests - Test IO operations</p> <p>Repository Tests - Test business logic</p> <p>ViewModel Tests - Test state management</p> <p>UI Tests - Test composables</p> <p>Integration Tests - Test full feature flow</p>"},{"location":"guide/#further-reading","title":"Further Reading","text":"<ul> <li>Architecture Overview - Understand the app's architecture</li> <li>Design Philosophy - Learn about design principles</li> <li>State Management - Deep dive into UiState patterns</li> <li>Data Flow - Understand data flow patterns</li> <li>Navigation - Type-safe navigation guide</li> <li>Dependency Injection - Complete DI guide</li> <li>Firebase Setup Guide - Add Firebase to your app</li> <li>Dependency Management - Version catalogs and configurations</li> </ul>"},{"location":"license/","title":"Apache License","text":"<p>Version 2.0, January 2004 &lt;http://www.apache.org/licenses/&gt;</p>"},{"location":"license/#terms-and-conditions-for-use-reproduction-and-distribution","title":"Terms and Conditions for use, reproduction, and distribution","text":""},{"location":"license/#1-definitions","title":"1. Definitions","text":"<p>\u201cLicense\u201d shall mean the terms and conditions for use, reproduction, and distribution as defined by Sections 1 through 9 of this document.</p> <p>\u201cLicensor\u201d shall mean the copyright owner or entity authorized by the copyright owner that is granting the License.</p> <p>\u201cLegal Entity\u201d shall mean the union of the acting entity and all other entities that control, are controlled by, or are under common control with that entity. For the purposes of this definition, \u201ccontrol\u201d means (i) the power, direct or indirect, to cause the direction or management of such entity, whether by contract or otherwise, or (ii) ownership of fifty percent (50%) or more of the outstanding shares, or (iii) beneficial ownership of such entity.</p> <p>\u201cYou\u201d (or \u201cYour\u201d) shall mean an individual or Legal Entity exercising permissions granted by this License.</p> <p>\u201cSource\u201d form shall mean the preferred form for making modifications, including but not limited to software source code, documentation source, and configuration files.</p> <p>\u201cObject\u201d form shall mean any form resulting from mechanical transformation or translation of a Source form, including but not limited to compiled object code, generated documentation, and conversions to other media types.</p> <p>\u201cWork\u201d shall mean the work of authorship, whether in Source or Object form, made available under the License, as indicated by a copyright notice that is included in or attached to the work (an example is provided in the Appendix below).</p> <p>\u201cDerivative Works\u201d shall mean any work, whether in Source or Object form, that is based on (or derived from) the Work and for which the editorial revisions, annotations, elaborations, or other modifications represent, as a whole, an original work of authorship. For the purposes of this License, Derivative Works shall not include works that remain separable from, or merely link (or bind by name) to the interfaces of, the Work and Derivative Works thereof.</p> <p>\u201cContribution\u201d shall mean any work of authorship, including the original version of the Work and any modifications or additions to that Work or Derivative Works thereof, that is intentionally submitted to Licensor for inclusion in the Work by the copyright owner or by an individual or Legal Entity authorized to submit on behalf of the copyright owner. For the purposes of this definition, \u201csubmitted\u201d means any form of electronic, verbal, or written communication sent to the Licensor or its representatives, including but not limited to communication on electronic mailing lists, source code control systems, and issue tracking systems that are managed by, or on behalf of, the Licensor for the purpose of discussing and improving the Work, but excluding communication that is conspicuously marked or otherwise designated in writing by the copyright owner as \u201cNot a Contribution.\u201d</p> <p>\u201cContributor\u201d shall mean Licensor and any individual or Legal Entity on behalf of whom a Contribution has been received by Licensor and subsequently incorporated within the Work.</p>"},{"location":"license/#2-grant-of-copyright-license","title":"2. Grant of Copyright License","text":"<p>Subject to the terms and conditions of this License, each Contributor hereby grants to You a perpetual, worldwide, non-exclusive, no-charge, royalty-free, irrevocable copyright license to reproduce, prepare Derivative Works of, publicly display, publicly perform, sublicense, and distribute the Work and such Derivative Works in Source or Object form.</p>"},{"location":"license/#3-grant-of-patent-license","title":"3. Grant of Patent License","text":"<p>Subject to the terms and conditions of this License, each Contributor hereby grants to You a perpetual, worldwide, non-exclusive, no-charge, royalty-free, irrevocable (except as stated in this section) patent license to make, have made, use, offer to sell, sell, import, and otherwise transfer the Work, where such license applies only to those patent claims licensable by such Contributor that are necessarily infringed by their Contribution(s) alone or by combination of their Contribution(s) with the Work to which such Contribution(s) was submitted. If You institute patent litigation against any entity (including a cross-claim or counterclaim in a lawsuit) alleging that the Work or a Contribution incorporated within the Work constitutes direct or contributory patent infringement, then any patent licenses granted to You under this License for that Work shall terminate as of the date such litigation is filed.</p>"},{"location":"license/#4-redistribution","title":"4. Redistribution","text":"<p>You may reproduce and distribute copies of the Work or Derivative Works thereof in any medium, with or without modifications, and in Source or Object form, provided that You meet the following conditions:</p> <ul> <li>(a) You must give any other recipients of the Work or Derivative Works a copy of   this License; and</li> <li>(b) You must cause any modified files to carry prominent notices stating that You   changed the files; and</li> <li>(c) You must retain, in the Source form of any Derivative Works that You distribute,   all copyright, patent, trademark, and attribution notices from the Source form   of the Work, excluding those notices that do not pertain to any part of the   Derivative Works; and</li> <li>(d) If the Work includes a \u201cNOTICE\u201d text file as part of its distribution, then any   Derivative Works that You distribute must include a readable copy of the   attribution notices contained within such NOTICE file, excluding those notices   that do not pertain to any part of the Derivative Works, in at least one of the   following places: within a NOTICE text file distributed as part of the   Derivative Works; within the Source form or documentation, if provided along   with the Derivative Works; or, within a display generated by the Derivative   Works, if and wherever such third-party notices normally appear. The contents of   the NOTICE file are for informational purposes only and do not modify the   License. You may add Your own attribution notices within Derivative Works that   You distribute, alongside or as an addendum to the NOTICE text from the Work,   provided that such additional attribution notices cannot be construed as   modifying the License.</li> </ul> <p>You may add Your own copyright statement to Your modifications and may provide additional or different license terms and conditions for use, reproduction, or distribution of Your modifications, or for any such Derivative Works as a whole, provided Your use, reproduction, and distribution of the Work otherwise complies with the conditions stated in this License.</p>"},{"location":"license/#5-submission-of-contributions","title":"5. Submission of Contributions","text":"<p>Unless You explicitly state otherwise, any Contribution intentionally submitted for inclusion in the Work by You to the Licensor shall be under the terms and conditions of this License, without any additional terms or conditions. Notwithstanding the above, nothing herein shall supersede or modify the terms of any separate license agreement you may have executed with Licensor regarding such Contributions.</p>"},{"location":"license/#6-trademarks","title":"6. Trademarks","text":"<p>This License does not grant permission to use the trade names, trademarks, service marks, or product names of the Licensor, except as required for reasonable and customary use in describing the origin of the Work and reproducing the content of the NOTICE file.</p>"},{"location":"license/#7-disclaimer-of-warranty","title":"7. Disclaimer of Warranty","text":"<p>Unless required by applicable law or agreed to in writing, Licensor provides the Work (and each Contributor provides its Contributions) on an \u201cAS IS\u201d BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied, including, without limitation, any warranties or conditions of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A PARTICULAR PURPOSE. You are solely responsible for determining the appropriateness of using or redistributing the Work and assume any risks associated with Your exercise of permissions under this License.</p>"},{"location":"license/#8-limitation-of-liability","title":"8. Limitation of Liability","text":"<p>In no event and under no legal theory, whether in tort (including negligence), contract, or otherwise, unless required by applicable law (such as deliberate and grossly negligent acts) or agreed to in writing, shall any Contributor be liable to You for damages, including any direct, indirect, special, incidental, or consequential damages of any character arising as a result of this License or out of the use or inability to use the Work (including but not limited to damages for loss of goodwill, work stoppage, computer failure or malfunction, or any and all other commercial damages or losses), even if such Contributor has been advised of the possibility of such damages.</p>"},{"location":"license/#9-accepting-warranty-or-additional-liability","title":"9. Accepting Warranty or Additional Liability","text":"<p>While redistributing the Work or Derivative Works thereof, You may choose to offer, and charge a fee for, acceptance of support, warranty, indemnity, or other liability obligations and/or rights consistent with this License. However, in accepting such obligations, You may act only on Your own behalf and on Your sole responsibility, not on behalf of any other Contributor, and only if You agree to indemnify, defend, and hold each Contributor harmless for any liability incurred by, or claims asserted against, such Contributor by reason of your accepting any such warranty or additional liability.</p> <p>END OF TERMS AND CONDITIONS</p>"},{"location":"license/#appendix-how-to-apply-the-apache-license-to-your-work","title":"APPENDIX: How to apply the Apache License to your work","text":"<p>To apply the Apache License to your work, attach the following boilerplate notice, with the fields enclosed by brackets <code>[]</code> replaced with your own identifying information. (Don't include the brackets!) The text should be enclosed in the appropriate comment syntax for the file format. We also recommend that a file or class name and description of purpose be included on the same \u201cprinted page\u201d as the copyright notice for easier identification within third-party archives.</p> <pre><code>Copyright 2025 Atick Faisal\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n  http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n</code></pre>"},{"location":"navigation/","title":"Navigation Deep Dive","text":"<p>This guide provides a comprehensive overview of navigation in this Android template, which uses Jetpack Navigation Compose with type-safe navigation powered by Kotlin Serialization.</p>"},{"location":"navigation/#table-of-contents","title":"Table of Contents","text":"<ul> <li>Overview</li> <li>Type-Safe Navigation</li> <li>Simple Navigation</li> <li>Navigation with Arguments</li> <li>Nested Navigation Graphs</li> <li>Adaptive Navigation (Bottom Bar / Navigation Rail / Drawer)</li> <li>Back Stack Management</li> <li>Navigation Testing</li> <li>Common Patterns</li> <li>Best Practices</li> <li>Troubleshooting</li> </ul>"},{"location":"navigation/#overview","title":"Overview","text":""},{"location":"navigation/#navigation-architecture","title":"Navigation Architecture","text":"<p>This template uses Jetpack Navigation Compose with type-safe navigation via Kotlin Serialization. This approach provides:</p> <ul> <li>Compile-time safety: Routes are defined as Kotlin objects/data classes</li> <li>Type-safe arguments: Arguments are passed as typed parameters</li> <li>IDE support: Auto-completion and refactoring support</li> <li>Reduced errors: No string-based routes to mess up</li> </ul>"},{"location":"navigation/#key-components","title":"Key Components","text":"<p>The Navigation Layer consists of:</p> <ul> <li>Route Definitions - <code>@Serializable</code> objects/data classes</li> <li>Navigation Extensions - <code>NavController.navigateToX()</code></li> <li>Graph Builders - <code>NavGraphBuilder.xScreen()</code></li> <li>Top-Level Destinations - <code>TopLevelDestination</code> enum</li> <li>App State - <code>JetpackAppState</code></li> <li>NavHost Setup - <code>JetpackNavHost</code></li> </ul>"},{"location":"navigation/#navigation-flow","title":"Navigation Flow","text":"<pre><code>graph LR\n    A[User Action] --&gt; B[Screen Composable]\n    B --&gt; C[NavController Extension]\n    C --&gt; D[JetpackAppState/NavController]\n    D --&gt; E[Route Composable]\n    E --&gt; F[Screen Composable]</code></pre>"},{"location":"navigation/#complete-navigation-graph","title":"Complete Navigation Graph","text":"<p>This diagram shows the complete navigation graph structure used in this template:</p> <pre><code>graph TB\n    subgraph NavHost[\"NavHost (app/navigation/NavHost.kt)\"]\n        Start{{\"Conditional Start Destination&lt;br/&gt;(Auth vs Home)\"}}\n    end\n\n    subgraph AuthGraph[\"AuthNavGraph\"]\n        SignIn[\"SignIn&lt;br/&gt;(No arguments)\"]\n        SignUp[\"SignUp&lt;br/&gt;(No arguments)\"]\n        SignIn -. navigate .-&gt; SignUp\n        SignUp -. navigate .-&gt; SignIn\n    end\n\n    subgraph HomeGraph[\"HomeNavGraph\"]\n        Home[\"Home&lt;br/&gt;(No arguments)\"]\n        Item[\"Item&lt;br/&gt;(itemId: String?)\"]\n        Home --&gt;|onJetpackClick| Item\n        Item --&gt;|onBackClick| Home\n    end\n\n    Profile[\"Profile&lt;br/&gt;(Top-level destination)\"]\n    Start --&gt;|isUserLoggedIn = false| AuthGraph\n    Start --&gt;|isUserLoggedIn = true| HomeGraph\n    SignIn -. auth success .-&gt; HomeGraph\n    SignUp -. auth success .-&gt; HomeGraph\n    HomeGraph &lt;-. bottom nav .-&gt; Profile\n    Profile &lt;-. bottom nav .-&gt; HomeGraph</code></pre> <p>Legend:</p> <ul> <li>Solid arrows (\u2192): Direct navigation within a graph</li> <li>Dotted arrows (-.-&gt;): Navigation between graphs or conditional navigation</li> <li>Orange box: Conditional routing logic</li> <li>Red box: Authentication graph (not logged in)</li> <li>Green boxes: Main app destinations (logged in)</li> </ul>"},{"location":"navigation/#type-safe-navigation","title":"Type-Safe Navigation","text":""},{"location":"navigation/#defining-routes","title":"Defining Routes","text":"<p>Routes are defined as <code>@Serializable</code> objects or data classes in each feature module's <code>navigation/</code> directory:</p> <pre><code>// feature/home/navigation/HomeNavigation.kt\npackage dev.atick.feature.home.navigation\n\nimport kotlinx.serialization.Serializable\n\n// Simple route without arguments\n@Serializable\ndata object Home\n\n// Route with required argument\n@Serializable\ndata class Item(val itemId: String?)\n\n// Navigation graph\n@Serializable\ndata object HomeNavGraph\n</code></pre> <p>Why use @Serializable?</p> <ul> <li>Kotlin Serialization automatically handles serialization/deserialization</li> <li>Type-safe argument passing with compile-time checking</li> <li>No manual string parsing or type conversion</li> <li>Supports complex types (enums, lists, custom classes)</li> </ul>"},{"location":"navigation/#route-organization-pattern-used-in-this-template","title":"Route Organization Pattern (Used in This Template)","text":"<p>Each feature module has a <code>navigation/</code> directory with a single file defining all routes:</p> <ul> <li><code>feature/auth/navigation/</code> - Contains <code>AuthNavigation.kt</code> defining <code>AuthNavGraph</code>, <code>SignIn</code>,   <code>SignUp</code></li> <li><code>feature/home/navigation/</code> - Contains <code>HomeNavigation.kt</code> defining <code>HomeNavGraph</code>, <code>Home</code>, <code>Item</code></li> <li><code>feature/profile/navigation/</code> - Contains <code>ProfileNavigation.kt</code> defining <code>Profile</code></li> </ul> <p>Example from this template:</p> <pre><code>// feature/auth/navigation/AuthNavigation.kt\npackage dev.atick.feature.auth.navigation\n\nimport kotlinx.serialization.Serializable\n\n@Serializable\ndata object AuthNavGraph\n\n@Serializable\ndata object SignIn\n\n@Serializable\ndata object SignUp\n</code></pre>"},{"location":"navigation/#simple-navigation","title":"Simple Navigation","text":""},{"location":"navigation/#navcontroller-extension","title":"NavController Extension","text":"<p>Create extension functions for type-safe navigation in the same file as route definitions:</p> <pre><code>// feature/profile/navigation/ProfileNavigation.kt\nfun NavController.navigateToProfileScreen(navOptions: NavOptions? = null) {\n    navigate(Profile, navOptions)\n}\n</code></pre> <p>Example from this template:</p> <pre><code>// feature/auth/navigation/AuthNavigation.kt\nfun NavController.navigateToSignInScreen(navOptions: NavOptions? = null) {\n    navigate(SignIn, navOptions)\n}\n\nfun NavController.navigateToSignUpScreen(navOptions: NavOptions? = null) {\n    navigate(SignUp, navOptions)\n}\n</code></pre> <p>Benefits:</p> <ul> <li>Centralized navigation logic</li> <li>Consistent API across features</li> <li>Easy to find all navigation entry points</li> <li>Supports NavOptions for advanced behavior</li> </ul>"},{"location":"navigation/#graph-builder-extension","title":"Graph Builder Extension","text":"<p>Create extension functions to register screens:</p> <pre><code>// feature/profile/navigation/ProfileNavigation.kt\nfun NavGraphBuilder.profileScreen(\n    onShowSnackbar: suspend (String, SnackbarAction, Throwable?) -&gt; Boolean\n) {\n    composable&lt;Profile&gt; {\n        ProfileScreen(\n            onShowSnackbar = onShowSnackbar\n        )\n    }\n}\n</code></pre> <p>Example from this template:</p> <pre><code>// feature/auth/navigation/AuthNavigation.kt\nfun NavGraphBuilder.signInScreen(\n    onSignUpClick: () -&gt; Unit,\n    onShowSnackbar: suspend (String, SnackbarAction, Throwable?) -&gt; Boolean,\n) {\n    composable&lt;SignIn&gt; {\n        SignInScreen(\n            onSignUpClick = onSignUpClick,\n            onShowSnackbar = onShowSnackbar,\n        )\n    }\n}\n</code></pre>"},{"location":"navigation/#navhost-setup-template-pattern","title":"NavHost Setup (Template Pattern)","text":"<p>This template uses a centralized <code>JetpackNavHost</code> composable:</p> <pre><code>// app/src/main/kotlin/dev/atick/compose/navigation/NavHost.kt\n@Composable\nfun JetpackNavHost(\n    appState: JetpackAppState,\n    onShowSnackbar: suspend (String, SnackbarAction, Throwable?) -&gt; Boolean,\n    modifier: Modifier = Modifier,\n) {\n    val navController = appState.navController\n    val startDestination =\n        if (appState.isUserLoggedIn) HomeNavGraph::class else AuthNavGraph::class\n\n    NavHost(\n        navController = navController,\n        startDestination = startDestination,\n        modifier = modifier,\n    ) {\n        authNavGraph(\n            nestedNavGraphs = {\n                signInScreen(\n                    onSignUpClick = navController::navigateToSignUpScreen,\n                    onShowSnackbar = onShowSnackbar,\n                )\n                signUpScreen(\n                    onSignInClick = navController::navigateToSignInScreen,\n                    onShowSnackbar = onShowSnackbar,\n                )\n            },\n        )\n        homeNavGraph(\n            nestedNavGraphs = {\n                homeScreen(\n                    onJetpackClick = navController::navigateToItemScreen,\n                    onShowSnackbar = onShowSnackbar,\n                )\n                itemScreen(\n                    onBackClick = navController::popBackStack,\n                    onShowSnackbar = onShowSnackbar,\n                )\n            },\n        )\n        profileScreen(\n            onShowSnackbar = onShowSnackbar,\n        )\n    }\n}\n</code></pre> <p>Key Pattern: Conditional start destination based on authentication state.</p>"},{"location":"navigation/#navigation-with-arguments","title":"Navigation with Arguments","text":""},{"location":"navigation/#required-arguments","title":"Required Arguments","text":"<p>Pass required data via constructor parameters:</p> <pre><code>// Define route with required argument\n@Serializable\ndata class Item(val itemId: String?)\n\n// Navigation extension\nfun NavController.navigateToItemScreen(itemId: String?) {\n    navigate(Item(itemId)) { launchSingleTop = true }\n}\n\n// Screen registration - arguments are extracted automatically\nfun NavGraphBuilder.itemScreen(\n    onBackClick: () -&gt; Unit,\n    onShowSnackbar: suspend (String, SnackbarAction, Throwable?) -&gt; Boolean,\n) {\n    composable&lt;Item&gt; {\n        ItemScreen(\n            onBackClick = onBackClick,\n            onShowSnackbar = onShowSnackbar,\n        )\n    }\n}\n</code></pre> <p>In the Route/Screen composable, access arguments via the ViewModel:</p> <pre><code>// feature/home/ui/item/ItemScreen.kt\n@Composable\nfun ItemScreen(\n    onBackClick: () -&gt; Unit,\n    onShowSnackbar: suspend (String, SnackbarAction, Throwable?) -&gt; Boolean,\n    viewModel: ItemViewModel = hiltViewModel()\n) {\n    // ViewModel automatically receives itemId via SavedStateHandle\n    val uiState by viewModel.uiState.collectAsStateWithLifecycle()\n\n    StatefulComposable(\n        state = uiState,\n        onShowSnackbar = onShowSnackbar\n    ) { screenData -&gt;\n        // UI implementation\n    }\n}\n</code></pre> <p>In the ViewModel, access arguments via SavedStateHandle:</p> <pre><code>@HiltViewModel\nclass ItemViewModel @Inject constructor(\n    savedStateHandle: SavedStateHandle,\n    private val repository: JetpackRepository\n) : ViewModel() {\n    // Navigation arguments are automatically available in SavedStateHandle\n    private val itemId: String? = savedStateHandle.toRoute&lt;Item&gt;().itemId\n\n    // Use itemId to load data\n    init {\n        loadItem(itemId)\n    }\n}\n</code></pre>"},{"location":"navigation/#optional-arguments","title":"Optional Arguments","text":"<p>Use default parameter values for optional arguments:</p> <pre><code>@Serializable\ndata class ArticleDetail(\n    val articleId: String,\n    val scrollToComments: Boolean = false,\n    val highlightCommentId: String? = null\n)\n\n// Navigation with optional arguments\nfun NavController.navigateToArticleDetail(\n    articleId: String,\n    scrollToComments: Boolean = false,\n    highlightCommentId: String? = null,\n    navOptions: NavOptions? = null\n) {\n    navigate(\n        ArticleDetail(\n            articleId = articleId,\n            scrollToComments = scrollToComments,\n            highlightCommentId = highlightCommentId\n        ),\n        navOptions\n    )\n}\n\n// Usage\nnavController.navigateToArticleDetail(\"article-123\") // Use defaults\nnavController.navigateToArticleDetail(\n    articleId = \"article-123\",\n    scrollToComments = true,\n    highlightCommentId = \"comment-456\"\n)\n</code></pre>"},{"location":"navigation/#complex-types","title":"Complex Types","text":"<p>Kotlin Serialization supports complex argument types:</p> <pre><code>// Enum arguments\nenum class FilterType {\n    ALL, FAVORITES, ARCHIVED\n}\n\n@Serializable\ndata class ArticleList(\n    val filter: FilterType = FilterType.ALL\n)\n\n// List arguments (use @Serializable-compatible types)\n@Serializable\ndata class MultiSelect(\n    val selectedIds: List&lt;String&gt; = emptyList()\n)\n\n// Custom serializable types\n@Serializable\ndata class DateRange(\n    val startDate: String, // Use ISO 8601 format\n    val endDate: String\n)\n\n@Serializable\ndata class Reports(\n    val dateRange: DateRange\n)\n</code></pre>"},{"location":"navigation/#nested-navigation-graphs","title":"Nested Navigation Graphs","text":""},{"location":"navigation/#template-pattern-for-nested-graphs","title":"Template Pattern for Nested Graphs","text":"<p>This template uses a specific pattern for nested navigation graphs:</p> <pre><code>// feature/auth/navigation/AuthNavigation.kt\nfun NavGraphBuilder.authNavGraph(\n    nestedNavGraphs: NavGraphBuilder.() -&gt; Unit,\n) {\n    navigation&lt;AuthNavGraph&gt;(startDestination = SignIn) {\n        nestedNavGraphs()\n    }\n}\n</code></pre> <p>Key Pattern:</p> <ul> <li>The graph builder accepts a lambda (<code>nestedNavGraphs</code>) that defines child screens</li> <li>This allows the NavHost to control which screens are included in the graph</li> </ul>"},{"location":"navigation/#using-nested-graphs","title":"Using Nested Graphs","text":"<p>Include nested graphs in the main NavHost:</p> <pre><code>// app/src/main/kotlin/dev/atick/compose/navigation/NavHost.kt\nNavHost(\n    navController = navController,\n    startDestination = startDestination,\n    modifier = modifier,\n) {\n    authNavGraph(\n        nestedNavGraphs = {\n            signInScreen(\n                onSignUpClick = navController::navigateToSignUpScreen,\n                onShowSnackbar = onShowSnackbar,\n            )\n            signUpScreen(\n                onSignInClick = navController::navigateToSignInScreen,\n                onShowSnackbar = onShowSnackbar,\n            )\n        },\n    )\n    homeNavGraph(\n        nestedNavGraphs = {\n            homeScreen(/* ... */)\n            itemScreen(/* ... */)\n        },\n    )\n    profileScreen(/* ... */)\n}\n</code></pre>"},{"location":"navigation/#navigating-to-nested-graphs","title":"Navigating to Nested Graphs","text":"<p>Navigate to the root of a nested graph:</p> <pre><code>// Navigate to HomeNavGraph extension\nfun NavController.navigateToHomeNavGraph(navOptions: NavOptions? = null) {\n    navigate(HomeNavGraph, navOptions)\n}\n\n// Navigate directly to a specific screen in the graph\nnavController.navigateToItemScreen(\"item-123\")\n</code></pre>"},{"location":"navigation/#conditional-start-destination","title":"Conditional Start Destination","text":"<p>This template demonstrates conditional navigation based on authentication:</p> <pre><code>val startDestination =\n    if (appState.isUserLoggedIn) HomeNavGraph::class else AuthNavGraph::class\n\nNavHost(\n    navController = navController,\n    startDestination = startDestination,\n    modifier = modifier,\n) {\n    // ...\n}\n</code></pre>"},{"location":"navigation/#adaptive-navigation-bottom-bar-navigation-rail-drawer","title":"Adaptive Navigation (Bottom Bar / Navigation Rail / Drawer)","text":""},{"location":"navigation/#navigationsuitescaffold-pattern","title":"NavigationSuiteScaffold Pattern","text":"<p>This template uses NavigationSuiteScaffold for adaptive navigation that automatically switches between:</p> <ul> <li>Bottom navigation bar (compact screens)</li> <li>Navigation rail (medium screens)</li> <li>Navigation drawer (expanded screens)</li> </ul>"},{"location":"navigation/#top-level-destinations","title":"Top-Level Destinations","text":"<p>Define top-level destinations in an enum:</p> <pre><code>// app/src/main/kotlin/dev/atick/compose/navigation/TopLevelDestination.kt\nenum class TopLevelDestination(\n    val selectedIcon: ImageVector,\n    val unselectedIcon: ImageVector,\n    @StringRes val iconTextId: Int,\n    @StringRes val titleTextId: Int,\n    val route: KClass&lt;*&gt;,\n) {\n    HOME(\n        selectedIcon = Icons.Filled.Home,\n        unselectedIcon = Icons.Outlined.Home,\n        iconTextId = R.string.home,\n        titleTextId = R.string.home,\n        route = Home::class,\n    ),\n    PROFILE(\n        selectedIcon = Icons.Filled.Person,\n        unselectedIcon = Icons.Outlined.Person,\n        iconTextId = R.string.profile,\n        titleTextId = R.string.profile,\n        route = Profile::class,\n    ),\n}\n</code></pre>"},{"location":"navigation/#jetpackappstate-pattern","title":"JetpackAppState Pattern","text":"<p>Centralize navigation logic in an app state holder:</p> <pre><code>// app/src/main/kotlin/dev/atick/compose/ui/JetpackAppState.kt\n@Stable\nclass JetpackAppState(\n    val isUserLoggedIn: Boolean,\n    val navController: NavHostController,\n    // ...\n) {\n    val currentDestination: NavDestination?\n        @Composable get() = /* ... */\n\n    val currentTopLevelDestination: TopLevelDestination?\n        @Composable get() = TopLevelDestination.entries.firstOrNull { topLevelDestination -&gt;\n            currentDestination?.hasRoute(route = topLevelDestination.route) == true\n        }\n\n    val topLevelDestinations: List&lt;TopLevelDestination&gt; = TopLevelDestination.entries\n\n    fun navigateToTopLevelDestination(topLevelDestination: TopLevelDestination) {\n        val topLevelNavOptions = navOptions {\n            popUpTo(navController.graph.findStartDestination().id) {\n                saveState = true\n            }\n            launchSingleTop = true\n            restoreState = true\n        }\n\n        when (topLevelDestination) {\n            TopLevelDestination.HOME -&gt; navController.navigateToHomeNavGraph(topLevelNavOptions)\n            TopLevelDestination.PROFILE -&gt; navController.navigateToProfileScreen(topLevelNavOptions)\n        }\n    }\n}\n</code></pre>"},{"location":"navigation/#navigationsuitescaffold-setup","title":"NavigationSuiteScaffold Setup","text":"<pre><code>// app/src/main/kotlin/dev/atick/compose/ui/JetpackApp.kt\nJetpackNavigationSuiteScaffold(\n    navigationSuiteItems = {\n        appState.topLevelDestinations.forEach { destination -&gt;\n            val selected = currentDestination.isTopLevelDestinationInHierarchy(destination)\n\n            item(\n                selected = selected,\n                onClick = { appState.navigateToTopLevelDestination(destination) },\n                icon = {\n                    Icon(\n                        imageVector = destination.unselectedIcon,\n                        contentDescription = null,\n                    )\n                },\n                selectedIcon = {\n                    Icon(\n                        imageVector = destination.selectedIcon,\n                        contentDescription = null,\n                    )\n                },\n                label = { Text(stringResource(destination.iconTextId)) }\n            )\n        }\n    },\n    windowAdaptiveInfo = windowAdaptiveInfo,\n) {\n    JetpackScaffold(\n        appState = appState,\n        snackbarHostState = snackbarHostState,\n        onTopAppBarActionClick = onTopAppBarActionClick,\n        modifier = modifier,\n    )\n}\n</code></pre> <p>Benefits:</p> <ul> <li>Automatically adapts to different screen sizes</li> <li>Consistent navigation UX across device types</li> <li>Single source of truth for navigation items</li> <li>Built-in state preservation</li> </ul>"},{"location":"navigation/#conditional-navigation-ui","title":"Conditional Navigation UI","text":"<p>Show navigation only for top-level destinations:</p> <pre><code>if (appState.currentTopLevelDestination == null) {\n    // No navigation UI (e.g., auth screens, detail screens)\n    JetpackScaffold(/* ... */)\n    return\n}\n\n// Show NavigationSuiteScaffold for top-level destinations\nJetpackNavigationSuiteScaffold(/* ... */)\n</code></pre>"},{"location":"navigation/#back-stack-management","title":"Back Stack Management","text":""},{"location":"navigation/#understanding-the-back-stack","title":"Understanding the Back Stack","text":"<p>The back stack is a LIFO (Last In, First Out) stack of destinations:</p> <pre><code>[Home] \u2192 [Profile] \u2192 [Item] \u2192 [Detail]  \u2190 Current\n</code></pre>"},{"location":"navigation/#navigating-up","title":"Navigating Up","text":"<p>Go back one step in the back stack:</p> <pre><code>// In your composable\nonBackClick = { navController.popBackStack() }\n\n// Or use navigateUp() for proper up navigation\nonBackClick = { navController.navigateUp() }\n</code></pre> <p>Example from this template:</p> <pre><code>// feature/home/navigation/HomeNavigation.kt\nitemScreen(\n    onBackClick = navController::popBackStack,\n    onShowSnackbar = onShowSnackbar,\n)\n</code></pre>"},{"location":"navigation/#pop-to-destination","title":"Pop to Destination","text":"<p>Remove destinations until reaching a specific one:</p> <pre><code>// Pop back to Home, removing all intermediate screens\nnavController.navigate(Home) {\n    popUpTo(Home) {\n        inclusive = true // Include Home itself in the pop\n    }\n}\n</code></pre>"},{"location":"navigation/#top-level-navigation-pattern","title":"Top-Level Navigation Pattern","text":"<p>This template uses a consistent pattern for top-level navigation:</p> <pre><code>fun navigateToTopLevelDestination(topLevelDestination: TopLevelDestination) {\n    val topLevelNavOptions = navOptions {\n        // Pop up to the start destination to avoid stack buildup\n        popUpTo(navController.graph.findStartDestination().id) {\n            saveState = true\n        }\n        // Avoid multiple copies of the same destination\n        launchSingleTop = true\n        // Restore state when re-selecting a previously selected item\n        restoreState = true\n    }\n\n    when (topLevelDestination) {\n        TopLevelDestination.HOME -&gt; navController.navigateToHomeNavGraph(topLevelNavOptions)\n        TopLevelDestination.PROFILE -&gt; navController.navigateToProfileScreen(topLevelNavOptions)\n    }\n}\n</code></pre> <p>Key aspects:</p> <ul> <li><code>saveState = true</code>: Preserves screen state when navigating away</li> <li><code>launchSingleTop = true</code>: Prevents duplicate destinations</li> <li><code>restoreState = true</code>: Restores saved state when returning</li> </ul>"},{"location":"navigation/#single-top-launch-mode","title":"Single Top Launch Mode","text":"<p>Avoid duplicate destinations in the stack:</p> <pre><code>navController.navigate(Profile) {\n    launchSingleTop = true // Don't add if already on top\n}\n</code></pre> <p>Example from this template:</p> <pre><code>fun NavController.navigateToItemScreen(itemId: String?) {\n    navigate(Item(itemId)) { launchSingleTop = true }\n}\n</code></pre>"},{"location":"navigation/#back-press-handling","title":"Back Press Handling","text":"<p>Handle back press with <code>BackHandler</code>:</p> <pre><code>@Composable\nfun UnsavedChangesScreen(\n    onNavigateBack: () -&gt; Unit,\n    viewModel: EditViewModel = hiltViewModel()\n) {\n    val hasUnsavedChanges by viewModel.hasUnsavedChanges.collectAsState()\n    var showDialog by remember { mutableStateOf(false) }\n\n    BackHandler(enabled = hasUnsavedChanges) {\n        showDialog = true\n    }\n\n    if (showDialog) {\n        AlertDialog(\n            onDismissRequest = { showDialog = false },\n            title = { Text(\"Unsaved Changes\") },\n            text = { Text(\"You have unsaved changes. Are you sure you want to leave?\") },\n            confirmButton = {\n                TextButton(\n                    onClick = {\n                        showDialog = false\n                        onNavigateBack()\n                    }\n                ) {\n                    Text(\"Leave\")\n                }\n            },\n            dismissButton = {\n                TextButton(onClick = { showDialog = false }) {\n                    Text(\"Stay\")\n                }\n            }\n        )\n    }\n\n    // Screen content...\n}\n</code></pre>"},{"location":"navigation/#navigation-testing","title":"Navigation Testing","text":""},{"location":"navigation/#testing-navigation-actions","title":"Testing Navigation Actions","text":"<p>Test that navigation happens correctly:</p> <pre><code>@OptIn(ExperimentalTestApi::class)\nclass HomeNavigationTest {\n\n    @get:Rule\n    val composeTestRule = createAndroidComposeRule&lt;ComponentActivity&gt;()\n\n    private lateinit var navController: TestNavHostController\n\n    @Before\n    fun setup() {\n        composeTestRule.setContent {\n            navController = TestNavHostController(LocalContext.current).apply {\n                navigatorProvider.addNavigator(ComposeNavigator())\n            }\n\n            NavHost(navController = navController, startDestination = Home) {\n                homeScreen(\n                    onJetpackClick = { itemId -&gt;\n                        navController.navigateToItemScreen(itemId)\n                    },\n                    onShowSnackbar = { _, _, _ -&gt; true }\n                )\n\n                itemScreen(\n                    onBackClick = { navController.popBackStack() },\n                    onShowSnackbar = { _, _, _ -&gt; true }\n                )\n            }\n        }\n    }\n\n    @Test\n    fun navigateToItem_updatesCurrentDestination() {\n        // Navigate to item\n        composeTestRule.runOnUiThread {\n            navController.navigateToItemScreen(\"item-123\")\n        }\n\n        // Verify current destination\n        composeTestRule.runOnUiThread {\n            val currentRoute = navController.currentBackStackEntry?.toRoute&lt;Item&gt;()\n            assertEquals(\"item-123\", currentRoute?.itemId)\n        }\n    }\n\n    @Test\n    fun clickBackButton_navigatesUp() {\n        // Navigate to item\n        composeTestRule.runOnUiThread {\n            navController.navigateToItemScreen(\"item-123\")\n        }\n\n        // Click back button\n        composeTestRule.onNodeWithContentDescription(\"Back\").performClick()\n\n        // Verify navigation\n        composeTestRule.runOnUiThread {\n            val currentRoute = navController.currentBackStackEntry?.destination?.hasRoute&lt;Home&gt;()\n            assertTrue(currentRoute == true)\n        }\n    }\n}\n</code></pre>"},{"location":"navigation/#testing-back-stack","title":"Testing Back Stack","text":"<p>Test back stack behavior:</p> <pre><code>@Test\nfun backStack_preservesState() {\n    val navController = TestNavHostController(\n        ApplicationProvider.getApplicationContext()\n    ).apply {\n        navigatorProvider.addNavigator(ComposeNavigator())\n    }\n\n    // Navigate through several screens\n    navController.navigate(Home)\n    navController.navigate(Profile)\n    navController.navigate(Settings)\n\n    // Verify back stack size\n    assertEquals(3, navController.backQueue.size)\n\n    // Pop back\n    navController.popBackStack()\n\n    // Verify current destination\n    val currentRoute = navController.currentBackStackEntry?.destination?.hasRoute&lt;Profile&gt;()\n    assertTrue(currentRoute == true)\n}\n</code></pre>"},{"location":"navigation/#common-patterns","title":"Common Patterns","text":""},{"location":"navigation/#conditional-navigation","title":"Conditional Navigation","text":"<p>Navigate based on state:</p> <pre><code>@Composable\nfun HomeRoute(\n    onShowSnackbar: suspend (String, SnackbarAction, Throwable?) -&gt; Boolean,\n    onNavigateToAuth: () -&gt; Unit,\n    viewModel: HomeViewModel = hiltViewModel()\n) {\n    val isAuthenticated by viewModel.isAuthenticated.collectAsStateWithLifecycle()\n\n    LaunchedEffect(isAuthenticated) {\n        if (!isAuthenticated) {\n            onNavigateToAuth()\n        }\n    }\n\n    // Rest of the screen...\n}\n</code></pre>"},{"location":"navigation/#navigation-after-async-operation","title":"Navigation After Async Operation","text":"<p>Navigate after an async operation completes:</p> <pre><code>@Composable\nfun CreateArticleRoute(\n    onShowSnackbar: suspend (String, SnackbarAction, Throwable?) -&gt; Boolean,\n    onNavigateToDetail: (String) -&gt; Unit,\n    viewModel: CreateArticleViewModel = hiltViewModel()\n) {\n    val uiState by viewModel.uiState.collectAsStateWithLifecycle()\n\n    // Navigate when article is created\n    LaunchedEffect(uiState.data.createdArticleId) {\n        uiState.data.createdArticleId?.let { articleId -&gt;\n            onNavigateToDetail(articleId)\n        }\n    }\n\n    StatefulComposable(\n        state = uiState,\n        onShowSnackbar = onShowSnackbar\n    ) { screenData -&gt;\n        CreateArticleScreen(\n            screenData = screenData,\n            onSubmit = viewModel::createArticle\n        )\n    }\n}\n</code></pre>"},{"location":"navigation/#accessing-navigation-arguments-in-viewmodel","title":"Accessing Navigation Arguments in ViewModel","text":"<p>Use <code>SavedStateHandle.toRoute&lt;T&gt;()</code> to access navigation arguments:</p> <pre><code>@HiltViewModel\nclass ItemViewModel @Inject constructor(\n    savedStateHandle: SavedStateHandle,\n    private val repository: JetpackRepository\n) : ViewModel() {\n    // Extract navigation arguments\n    private val itemId: String? = savedStateHandle.toRoute&lt;Item&gt;().itemId\n\n    private val _uiState = MutableStateFlow(UiState(ItemScreenData()))\n    val uiState = _uiState.asStateFlow()\n\n    init {\n        loadItem(itemId)\n    }\n\n    private fun loadItem(itemId: String?) {\n        _uiState.updateStateWith {\n            repository.getItem(itemId)\n        }\n    }\n}\n</code></pre>"},{"location":"navigation/#best-practices","title":"Best Practices","text":""},{"location":"navigation/#dos","title":"Do's","text":"<p>Use type-safe navigation</p> <pre><code>// Good: Type-safe\nnavController.navigate(Item(itemId = \"123\"))\n\n// Avoid: String-based routes\nnavController.navigate(\"item/123\")\n</code></pre> <p>Create navigation extensions</p> <pre><code>// Centralize navigation logic\nfun NavController.navigateToItem(itemId: String?) {\n    navigate(Item(itemId = itemId)) { launchSingleTop = true }\n}\n</code></pre> <p>Separate Route and Screen composables</p> <pre><code>// Route: Handles ViewModel and navigation callbacks\n@Composable\nfun ItemScreen(\n    onBackClick: () -&gt; Unit,\n    onShowSnackbar: suspend (String, SnackbarAction, Throwable?) -&gt; Boolean,\n    viewModel: ItemViewModel = hiltViewModel()\n) {\n    val uiState by viewModel.uiState.collectAsStateWithLifecycle()\n\n    StatefulComposable(uiState, onShowSnackbar) { screenData -&gt;\n        ItemScreenContent(screenData, onBackClick)\n    }\n}\n\n// Screen content: Pure UI, no navigation knowledge\n@Composable\nprivate fun ItemScreenContent(\n    screenData: ItemScreenData,\n    onBackClick: () -&gt; Unit\n) {\n    // UI only\n}\n</code></pre> <p>Use JetpackAppState pattern for top-level navigation</p> <pre><code>// Centralize navigation state and logic\nclass JetpackAppState(\n    val navController: NavHostController,\n    // ...\n) {\n    fun navigateToTopLevelDestination(destination: TopLevelDestination) {\n        // Consistent navigation logic\n    }\n}\n</code></pre> <p>Use NavOptions for complex navigation</p> <pre><code>navController.navigate(Home) {\n    popUpTo(Login) { inclusive = true }\n    launchSingleTop = true\n}\n</code></pre> <p>Pass callbacks, not NavController</p> <pre><code>// Good: Pass specific callbacks\nfun NavGraphBuilder.itemScreen(\n    onBackClick: () -&gt; Unit,\n    onShowSnackbar: suspend (String, SnackbarAction, Throwable?) -&gt; Boolean\n) {\n    composable&lt;Item&gt; {\n        ItemScreen(onBackClick, onShowSnackbar)\n    }\n}\n\n// Avoid: Passing NavController\nfun NavGraphBuilder.itemScreen(navController: NavController) {}\n</code></pre>"},{"location":"navigation/#donts","title":"Don'ts","text":"<p>Don't pass NavController to Screen composables</p> <pre><code>// Bad: Screen shouldn't know about NavController\n@Composable\nfun ItemScreen(navController: NavController) {\n}\n\n// Good: Use callbacks\n@Composable\nfun ItemScreen(onBackClick: () -&gt; Unit) {\n}\n</code></pre> <p>Don't use string-based routes</p> <pre><code>// Avoid\ncomposable(\"item/{itemId}\") { }\n\n// Use type-safe routes instead\ncomposable&lt;Item&gt; { }\n</code></pre> <p>Don't navigate in ViewModels</p> <pre><code>// Bad: ViewModel shouldn't know about navigation\nclass ItemViewModel(private val navController: NavController) : ViewModel() {\n    fun onBackClick() {\n        navController.navigateUp()\n    }\n}\n\n// Good: Use events or rely on callbacks from composables\nclass ItemViewModel : ViewModel() {\n    // ViewModel focuses on business logic only\n    // Navigation is handled by composables via callbacks\n}\n</code></pre> <p>Don't forget state preservation for top-level navigation</p> <pre><code>// Avoid: Loses state when switching tabs\nnavController.navigate(Profile)\n\n// Use: Preserves state\nnavController.navigate(Profile) {\n    popUpTo(navController.graph.findStartDestination().id) {\n        saveState = true\n    }\n    launchSingleTop = true\n    restoreState = true\n}\n</code></pre>"},{"location":"navigation/#troubleshooting","title":"Troubleshooting","text":""},{"location":"navigation/#common-issues","title":"Common Issues","text":""},{"location":"navigation/#issue-arguments-not-accessible-in-viewmodel","title":"Issue: Arguments not accessible in ViewModel","text":"<p>Problem: Navigation arguments are null in ViewModel.</p> <p>Solution:</p> <pre><code>// Use SavedStateHandle.toRoute&lt;T&gt;() to extract arguments\n@HiltViewModel\nclass ItemViewModel @Inject constructor(\n    savedStateHandle: SavedStateHandle,\n    private val repository: JetpackRepository\n) : ViewModel() {\n    // Extract route arguments\n    private val itemId: String? = savedStateHandle.toRoute&lt;Item&gt;().itemId\n}\n</code></pre>"},{"location":"navigation/#issue-back-stack-not-clearing","title":"Issue: Back stack not clearing","text":"<p>Problem: Back button doesn't behave as expected.</p> <p>Solution:</p> <pre><code>// Clear specific destinations\nnavController.navigate(Home) {\n    popUpTo(Login) {\n        inclusive = true\n    }\n}\n\n// Clear entire back stack\nnavController.navigate(Home) {\n    popUpTo(navController.graph.id) {\n        inclusive = true\n    }\n}\n</code></pre>"},{"location":"navigation/#issue-nested-graph-not-found","title":"Issue: Nested graph not found","text":"<p>Problem: Can't navigate to screens within nested graph.</p> <p>Solution:</p> <pre><code>// Ensure nested graph is registered in NavHost\nNavHost(navController = navController, startDestination = startDestination) {\n    authNavGraph(\n        nestedNavGraphs = {\n            signInScreen(/* ... */)\n            signUpScreen(/* ... */)\n        }\n    )\n    homeNavGraph(\n        nestedNavGraphs = {\n            homeScreen(/* ... */)\n            itemScreen(/* ... */)\n        }\n    )\n}\n</code></pre>"},{"location":"navigation/#issue-state-not-preserved-in-bottom-navigation","title":"Issue: State not preserved in bottom navigation","text":"<p>Problem: Screen state is lost when switching tabs.</p> <p>Solution:</p> <pre><code>// Enable state saving in NavOptions\nnavController.navigate(destination) {\n    popUpTo(navController.graph.findStartDestination().id) {\n        saveState = true\n    }\n    restoreState = true\n    launchSingleTop = true\n}\n</code></pre>"},{"location":"navigation/#issue-navigation-ui-showing-on-non-top-level-screens","title":"Issue: Navigation UI showing on non-top-level screens","text":"<p>Problem: Bottom bar or navigation rail visible on detail screens.</p> <p>Solution:</p> <pre><code>// Check currentTopLevelDestination in JetpackApp\nif (appState.currentTopLevelDestination == null) {\n    // No navigation UI for auth screens, detail screens, etc.\n    JetpackScaffold(/* ... */)\n    return\n}\n\n// Show NavigationSuiteScaffold only for top-level destinations\nJetpackNavigationSuiteScaffold(/* ... */)\n</code></pre>"},{"location":"navigation/#summary","title":"Summary","text":"<p>This guide covered:</p> <ul> <li>Type-safe navigation with Kotlin Serialization</li> <li>Navigation patterns used in this template</li> <li>Simple and complex navigation with arguments</li> <li>Nested navigation graphs (template pattern)</li> <li>Adaptive navigation with NavigationSuiteScaffold</li> <li>JetpackAppState pattern for centralized navigation</li> <li>Back stack management</li> <li>Navigation testing strategies</li> <li>Common navigation patterns</li> <li>Best practices specific to this template</li> <li>Troubleshooting common issues</li> </ul> <p>Key Takeaways:</p> <ol> <li>Always use type-safe navigation with <code>@Serializable</code> routes</li> <li>Follow the template's nested graph pattern with <code>nestedNavGraphs</code> lambda</li> <li>Use JetpackAppState for centralized top-level navigation logic</li> <li>Use NavigationSuiteScaffold for adaptive navigation UI</li> <li>Access navigation arguments in ViewModel via <code>SavedStateHandle.toRoute&lt;T&gt;()</code></li> <li>Pass callbacks to composables, never NavController</li> <li>Use conditional start destination for auth flows</li> <li>Preserve state with saveState/restoreState for top-level navigation</li> </ol>"},{"location":"navigation/#further-reading","title":"Further Reading","text":""},{"location":"navigation/#concept-guides","title":"Concept Guides","text":"<ul> <li>Architecture Overview - Understand where navigation fits in the architecture</li> <li>State Management - Learn how to pass state through navigation</li> <li>Adding Features - Step-by-step guide including navigation setup</li> <li>Quick Reference - Navigation patterns cheat sheet</li> </ul>"},{"location":"navigation/#module-documentation","title":"Module Documentation","text":"<ul> <li>App Module - Main app navigation setup and JetpackAppState</li> <li>Feature Auth Module - Example of authentication navigation flow</li> <li>Feature Home Module - Example of nested navigation graph</li> </ul>"},{"location":"performance/","title":"Performance Optimizations","text":"<p>This guide covers various performance optimization features available in the project.</p>"},{"location":"performance/#compose-compiler-metrics","title":"Compose Compiler Metrics","text":"<p>The project includes built-in support for Compose compiler metrics to help optimize your composables.</p> <p>Check the <code>gradle.properties</code> file to ensure the following:</p> <pre><code>enableComposeCompilerMetrics=true\nenableComposeCompilerReports=true\n</code></pre> <p>This configuration will generate detailed reports in:</p> <ul> <li><code>build/&lt;module&gt;/compose-metrics</code>: Composition metrics</li> <li><code>build/&lt;module&gt;/compose-reports</code>: Compiler reports</li> </ul>"},{"location":"performance/#using-the-reports","title":"Using the Reports","text":"<ol> <li>Skippability Report: Shows which composables can't skip recomposition</li> <li>Events Report: Details composition events</li> <li>Metrics Report: Performance metrics for each composable</li> </ol>"},{"location":"performance/#optimizing-composables","title":"Optimizing Composables","text":"<p>Use the reports to identify and fix recomposition issues:</p> <pre><code>// Bad: Class not marked as stable\ndata class UiState(\n    val mutableList: MutableList&lt;String&gt; // Unstable type\n)\n\n// Good: Stable class with immutable properties\n@Immutable\ndata class UiState(\n    val list: List&lt;String&gt; // Immutable type\n)\n</code></pre> <p>Common optimizations:</p> <pre><code>// Mark data classes as stable\n@Stable\ndata class YourData(...)\n\n// Use immutable collections\nval items: ImmutableList&lt;Item&gt;\n\n// Remember expensive computations\nval filteredList = remember(items) {\n    items.filter { ... }\n}\n</code></pre> <p>Tip</p> <p>Use <code>@Immutable</code> for classes that never change and <code>@Stable</code> for classes whose properties may change but maintain identity.</p>"},{"location":"performance/#lazylist-optimization","title":"LazyList Optimization","text":"<p>The project uses <code>LazyVerticalStaggeredGrid</code> in the home screen (see <code>feature/home/src/main/kotlin/dev/atick/feature/home/ui/home/HomeScreen.kt:104</code>). Here are best practices for LazyList components.</p>"},{"location":"performance/#use-stable-keys","title":"Use Stable Keys","text":"<p>Always provide stable, unique keys for list items:</p> <pre><code>// \u2705 Good: Stable unique keys (as used in HomeScreen.kt)\nLazyVerticalStaggeredGrid(\n    columns = StaggeredGridCells.Adaptive(300.dp),\n    contentPadding = PaddingValues(16.dp),\n    state = state,\n) {\n    items(items = jetpacks, key = { it.id }) { jetpack -&gt;\n        JetpackCard(jetpack = jetpack)\n    }\n}\n\n// \u274c Bad: No keys or unstable keys\nLazyColumn {\n    items(items) { item -&gt;  // Missing key\n        ItemCard(item)\n    }\n}\n\n// \u274c Bad: Using index as key (unstable when items change order)\nLazyColumn {\n    itemsIndexed(items) { index, item -&gt;\n        key(index) {  // Index changes when items reorder\n            ItemCard(item)\n        }\n    }\n}\n</code></pre> <p>Tip</p> <p>Keys enable Compose to track items across recompositions, reducing unnecessary recompositions and preserving item state.</p>"},{"location":"performance/#content-type-for-mixed-lists","title":"Content Type for Mixed Lists","text":"<p>For lists with different item types, use <code>contentType</code> to optimize composition:</p> <pre><code>LazyColumn {\n    items(\n        items = mixedItems,\n        key = { it.id },\n        contentType = { it.type }  // Groups similar items for composition optimization\n    ) { item -&gt;\n        when (item) {\n            is HeaderItem -&gt; HeaderCard(item)\n            is ContentItem -&gt; ContentCard(item)\n            is AdItem -&gt; AdCard(item)\n        }\n    }\n}\n</code></pre>"},{"location":"performance/#avoid-heavy-computations-in-item-composables","title":"Avoid Heavy Computations in Item Composables","text":"<p>Move computations outside the item scope or use <code>remember</code>:</p> <pre><code>// \u2705 Good: Computation cached with remember\n@Composable\nfun ItemCard(item: Item) {\n    val formattedDate = remember(item.timestamp) {\n        formatDate(item.timestamp)  // Expensive formatting cached\n    }\n\n    Text(formattedDate)\n}\n\n// \u274c Bad: Computation runs on every recomposition\n@Composable\nfun ItemCard(item: Item) {\n    Text(formatDate(item.timestamp))  // Runs every time\n}\n</code></pre>"},{"location":"performance/#image-loading-best-practices","title":"Image Loading Best Practices","text":"<p>This template uses Coil for image loading (see <code>core/network/src/main/kotlin/dev/atick/core/network/di/coil/CoilModule.kt</code> and <code>core/ui/src/main/kotlin/dev/atick/core/ui/components/DynamicAsyncImage.kt</code>).</p>"},{"location":"performance/#coil-configuration","title":"Coil Configuration","text":"<p>The project provides an <code>ImageLoader</code> through Hilt in <code>CoilModule.kt</code>:</p> <pre><code>@Provides\n@Singleton\nfun provideImageLoader(\n    okHttpCallFactory: Call.Factory,\n    @ApplicationContext application: Context,\n): ImageLoader = ImageLoader.Builder(application)\n        .callFactory(okHttpCallFactory)\n        .components {\n            add(SvgDecoder.Factory())  // SVG support\n        }\n        .respectCacheHeaders(false)  // Assumes versioned URLs\n        .apply {\n            if (BuildConfig.DEBUG) {\n                logger(DebugLogger())\n            }\n        }\n        .build()\n</code></pre> <p>The <code>App</code> class implements <code>ImageLoaderFactory</code> to provide this loader:</p> <pre><code>@HiltAndroidApp\nclass App : Application(), ImageLoaderFactory {\n    @Inject\n    lateinit var imageLoader: dagger.Lazy&lt;ImageLoader&gt;\n\n    override fun newImageLoader(): ImageLoader = imageLoader.get()\n}\n</code></pre>"},{"location":"performance/#using-dynamicasyncimage","title":"Using DynamicAsyncImage","text":"<p>The template provides a <code>DynamicAsyncImage</code> component in <code>core/ui</code> that handles:</p> <ul> <li>Loading state: Displays <code>JetpackLoadingWheel</code> while loading</li> <li>Error handling: Falls back to placeholder image on load failure</li> <li>Theme integration: Applies tint color from <code>LocalTintTheme</code></li> <li>Preview mode: Shows placeholder in Android Studio preview</li> </ul> <pre><code>DynamicAsyncImage(\n    imageUrl = \"https://example.com/avatar.jpg\",\n    contentDescription = \"User avatar\",\n    placeholder = painterResource(R.drawable.ic_placeholder),\n    modifier = Modifier\n        .size(80.dp)\n        .clip(CircleShape),\n)\n</code></pre>"},{"location":"performance/#custom-image-loading-with-asyncimage","title":"Custom Image Loading with AsyncImage","text":"<p>For custom loading behavior, use Coil's <code>AsyncImage</code> directly:</p> <pre><code>@Composable\nfun UserAvatar(\n    imageUrl: String,\n    modifier: Modifier = Modifier\n) {\n    AsyncImage(\n        model = ImageRequest.Builder(LocalContext.current)\n            .data(imageUrl)\n            .crossfade(true)\n            .build(),\n        contentDescription = \"User avatar\",\n        contentScale = ContentScale.Crop,\n        modifier = modifier.size(48.dp)\n    )\n}\n</code></pre>"},{"location":"performance/#memory-leak-prevention","title":"Memory Leak Prevention","text":"<p>Common sources of memory leaks in Android apps and how to prevent them.</p>"},{"location":"performance/#avoid-leaked-viewmodels","title":"Avoid Leaked ViewModels","text":"<p>ViewModels should never hold references to Activities, Fragments, or Views:</p> <pre><code>// \u274c Bad: Context leak\nclass HomeViewModel(\n    private val context: Context  // Leaked if Activity context\n) : ViewModel()\n\n// \u2705 Good: Use Application context or dependency injection (as used in this template)\n@HiltViewModel\nclass HomeViewModel @Inject constructor(\n    private val repository: HomeRepository\n) : ViewModel()\n</code></pre>"},{"location":"performance/#lifecycle-aware-flow-collection","title":"Lifecycle-Aware Flow Collection","text":"<p>Always use <code>collectAsStateWithLifecycle</code> in Composables (as used throughout the template):</p> <pre><code>@Composable\nfun HomeScreen(\n    homeViewModel: HomeViewModel = hiltViewModel(),\n) {\n    // \u2705 Good: Lifecycle-aware collection (used in all feature screens)\n    val uiState by homeViewModel.uiState.collectAsStateWithLifecycle()\n\n    // \u274c Bad: Collects even when screen not visible\n    // val uiState by viewModel.uiState.collectAsState()\n}\n</code></pre>"},{"location":"performance/#cancel-coroutines-properly","title":"Cancel Coroutines Properly","text":"<p>Always use <code>viewModelScope</code> for ViewModel coroutines (as used in this template):</p> <pre><code>class HomeViewModel : ViewModel() {\n    // \u2705 Good: Automatically cancelled when ViewModel cleared\n    fun loadData() {\n        viewModelScope.launch {\n            repository.fetchData()\n        }\n    }\n\n    // \u274c Bad: GlobalScope never cancelled\n    fun loadDataBad() {\n        GlobalScope.launch {\n            repository.fetchData()  // Leaked coroutine\n        }\n    }\n}\n</code></pre>"},{"location":"performance/#workmanager-and-hilt","title":"WorkManager and Hilt","text":"<p>When using WorkManager with Hilt, use <code>HiltWorker</code> (as implemented in <code>sync/src/main/kotlin/dev/atick/sync/worker/SyncWorker.kt</code>):</p> <pre><code>@HiltWorker\nclass SyncWorker @AssistedInject constructor(\n    @Assisted context: Context,\n    @Assisted params: WorkerParameters,\n    private val repository: SyncRepository  // Injected, no leak\n) : CoroutineWorker(context, params) {\n    override suspend fun doWork(): Result {\n        return repository.sync()\n    }\n}\n</code></pre>"},{"location":"performance/#r8-and-proguard-optimization","title":"R8 and ProGuard Optimization","text":""},{"location":"performance/#project-structure-for-obfuscation","title":"Project Structure for Obfuscation","text":"<p>The project follows a consistent pattern for data models to simplify ProGuard/R8 rules:</p> <pre><code>- `feature/your-feature/model/` - Models kept unobfuscated\n- `core/network/model/` - Data models kept unobfuscated\n</code></pre>"},{"location":"performance/#proguard-and-consumer-rules","title":"ProGuard and Consumer Rules","text":"<p>If your app works in <code>debug</code> build but not in <code>release</code> build that typically indicates obfuscation issues. In that case you need to add or edit the proguard rules. These can be found in <code>&lt;module&gt;/proguard-rules.pro</code> or <code>&lt;module&gt;/consumer-rules.pro</code> files. For example:</p> <pre><code># Keep all models\n-keep class **.model.** { *; }\n\n# Keep Kotlinx Serialization\n-keepattributes *Annotation*, InnerClasses\n-dontnote kotlinx.serialization.AnnotationsKt\n</code></pre> <p>Note</p> <p>The project's model organization makes it easy to keep data models unobfuscated while allowing safe obfuscation of implementation classes.</p>"},{"location":"performance/#startup-optimization","title":"Startup Optimization","text":"<p>Reducing app startup time improves user experience and metrics.</p>"},{"location":"performance/#lazy-initialization","title":"Lazy Initialization","text":"<p>Defer non-critical initialization (as implemented in <code>App.kt:40</code>):</p> <pre><code>@HiltAndroidApp\nclass App : Application() {\n    override fun onCreate() {\n        super.onCreate()\n\n        // Debug logging initialized only in debug builds\n        if (BuildConfig.DEBUG) Timber.plant(Timber.DebugTree())\n\n        // Critical components initialized through Hilt\n        // Non-critical initialization deferred or lazy-loaded\n    }\n}\n</code></pre>"},{"location":"performance/#optimize-dependency-injection","title":"Optimize Dependency Injection","text":"<p>Hilt creates the dependency graph at startup. Use <code>@Binds</code> instead of <code>@Provides</code> when possible (as used throughout this template):</p> <pre><code>// \u2705 Good: @Binds is more efficient (used in data/src/main/kotlin/dev/atick/data/di/RepositoryModule.kt)\n@Module\n@InstallIn(SingletonComponent::class)\nabstract class RepositoryModule {\n    @Binds\n    abstract fun bindHomeRepository(impl: HomeRepositoryImpl): HomeRepository\n}\n\n// \u274c Less efficient: @Provides requires more codegen\n@Module\n@InstallIn(SingletonComponent::class)\nobject RepositoryModule {\n    @Provides\n    fun provideRepository(impl: RepositoryImpl): Repository = impl\n}\n</code></pre>"},{"location":"performance/#gradle-build-optimization","title":"Gradle Build Optimization","text":""},{"location":"performance/#build-scan","title":"Build Scan","text":"<p>The project includes Gradle Enterprise build scan support (see <code>settings.gradle.kts</code>):</p> <pre><code>plugins {\n    id(\"com.gradle.develocity\") version (\"3.19.1\")\n}\n\ndevelocity {\n    buildScan {\n        publishing.onlyIf { !System.getenv(\"CI\").isNullOrEmpty() }\n        termsOfUseUrl.set(\"https://gradle.com/help/legal-terms-of-use\")\n        termsOfUseAgree.set(\"yes\")\n    }\n}\n</code></pre> <p>Use build scans to:</p> <ul> <li>Identify slow tasks</li> <li>Find configuration issues</li> <li>Optimize dependency resolution</li> </ul>"},{"location":"performance/#multi-module-build-optimization","title":"Multi-Module Build Optimization","text":"<p>Take advantage of the project's modular structure:</p> <ol> <li> <p>Make Module: Instead of rebuilding the entire project, use Make Module:</p> <ul> <li>Android Studio: Right-click module \u2192 Make Module</li> <li>Command Line: <code>./gradlew :module:name:assembleDebug</code></li> </ul> </li> <li> <p>Parallel Execution: Enabled in <code>gradle.properties</code>:    <pre><code>org.gradle.parallel=true\n</code></pre></p> </li> <li> <p>Configuration Caching: Already enabled for supported tasks</p> </li> </ol> <p>Tip</p> <p>When working on a feature, use Make Module on just that feature's module to significantly reduce build time.</p>"},{"location":"performance/#baseline-profiles","title":"Baseline Profiles","text":"<p>Note</p> <p>Baseline profile support is coming soon to improve app startup performance.</p>"},{"location":"performance/#planned-implementation","title":"Planned Implementation","text":"<pre><code>// build.gradle.kts\nandroidApplication {\n    baselineProfile {\n        automaticGenerationDuringBuild = true\n    }\n}\n</code></pre> <p>This will include:</p> <ul> <li>Startup trace collection</li> <li>Critical user path optimization</li> <li>Ahead-of-time compilation for key paths</li> </ul>"},{"location":"performance/#firebase-performance-monitoring","title":"Firebase Performance Monitoring","text":"<p>This template includes Firebase Performance Monitoring setup through the Firebase convention plugin (see <code>build-logic/convention/src/main/kotlin/dev/atick/convention/firebase/FirebaseConventionPlugin.kt</code>):</p> <pre><code>class FirebaseConventionPlugin : Plugin&lt;Project&gt; {\n    override fun apply(target: Project) {\n        with(target) {\n            with(pluginManager) {\n                apply(\"com.google.firebase.firebase-perf\")\n            }\n\n            dependencies {\n                \"implementation\"(libs.findLibrary(\"firebase.perf\").get())\n            }\n        }\n    }\n}\n</code></pre> <p>This gives you automatic monitoring of:</p> <ul> <li>Network requests</li> <li>App startup time</li> <li>Screen render time</li> <li>Frozen frames</li> </ul> <p>You can also add custom traces:</p> <pre><code>FirebasePerformance.getInstance().newTrace(\"custom_operation\").apply {\n    start()\n    // Your code here\n    stop()\n}\n</code></pre> <p>Tip</p> <p>Use the Firebase Console to view performance metrics and identify bottlenecks in your app.</p>"},{"location":"performance/#profiling-and-monitoring","title":"Profiling and Monitoring","text":""},{"location":"performance/#android-studio-profilers","title":"Android Studio Profilers","text":"<p>Use Android Studio's built-in profilers:</p> <ol> <li> <p>CPU Profiler: Identify expensive operations</p> <ul> <li>Run \u2192 Profile 'app'</li> <li>Record CPU activity during critical operations</li> <li>Look for long-running methods</li> </ul> </li> <li> <p>Memory Profiler: Detect memory issues</p> <ul> <li>Monitor memory allocation during scrolling</li> <li>Take heap dumps to find leaked objects</li> <li>Check for unnecessary object creation</li> </ul> </li> <li> <p>Layout Inspector: Analyze compose hierarchy</p> <ul> <li>Tools \u2192 Layout Inspector</li> <li>Check recomposition counts</li> <li>Identify unnecessary recompositions</li> </ul> </li> </ol> <p>Important</p> <p>Always profile your app's performance using Android Studio's CPU Profiler and Layout Inspector before and after optimizations to ensure they're effective.</p>"},{"location":"performance/#further-reading","title":"Further Reading","text":"<ul> <li>Useful Tips &amp; Tricks: Get useful tips for development and debugging</li> <li>CI/CD Setup: Set up continuous integration and deployment for the project</li> <li>Publishing to Play Store: Learn how to publish your app to the Google Play Store</li> </ul>"},{"location":"philosophy/","title":"Design Philosophy","text":"<p>This project prioritizes pragmatic simplicity over theoretical purity, making conscious trade-offs that favor maintainability and readability over absolute correctness or flexibility.</p>"},{"location":"philosophy/#core-principles","title":"Core Principles","text":""},{"location":"philosophy/#1-pragmatic-simplicity","title":"1. Pragmatic Simplicity","text":"<p>We favor straightforward, understandable solutions over complex but theoretically \"pure\" ones. This means:</p> <ul> <li>Using direct state management approaches</li> <li>Minimizing layers when possible</li> <li>Keeping code readable and debuggable</li> </ul>"},{"location":"philosophy/#2-centralized-state-management","title":"2. Centralized State Management","text":""},{"location":"philosophy/#uistate-wrapper","title":"UiState Wrapper","text":"<p>All UI state is wrapped in a consistent structure:</p> <pre><code>data class UiState&lt;T : Any&gt;(\n    val data: T,\n    val loading: Boolean = false,\n    val error: OneTimeEvent&lt;Throwable?&gt; = OneTimeEvent(null)\n)\n</code></pre>"},{"location":"philosophy/#statefulcomposable-pattern","title":"StatefulComposable Pattern","text":"<p>Instead of implementing error and loading states individually for each screen, we handle these centrally:</p> <pre><code>@Composable\nfun &lt;T : Any&gt; StatefulComposable(\n    state: UiState&lt;T&gt;,\n    onShowSnackbar: suspend (String, SnackbarAction, Throwable?) -&gt; Boolean,\n    content: @Composable (T) -&gt; Unit\n) {\n    // Centralized loading and error handling\n    content(state.data)\n}\n</code></pre> <p>Note</p> <p>This approach trades some flexibility for consistency and reduced boilerplate.</p>"},{"location":"philosophy/#3-direct-viewmodels","title":"3. Direct ViewModels","text":"<p>We opt for a direct approach to state management in ViewModels:</p> <pre><code>class AuthViewModel @Inject constructor(\n    private val authRepository: AuthRepository\n) : ViewModel() {\n    private val _uiState = MutableStateFlow(UiState(AuthScreenData()))\n    val uiState = _uiState.asStateFlow()\n\n    fun updateEmail(email: String) {\n        _uiState.updateState {\n            copy(\n                email = TextFiledData(\n                    value = email,\n                    errorMessage = email.validateEmail()\n                )\n            )\n        }\n    }\n}\n</code></pre> <p>Trade-offs Made:</p> <ul> <li>\u2705 Readability: State changes are explicit and easy to trace</li> <li>\u2705 Debuggability: Direct state mutations are easier to debug</li> <li>\u2705 Simplicity: Easier to manage multiple UI events</li> <li>\u274c Purity: Less adherence to functional programming principles</li> </ul>"},{"location":"philosophy/#4-error-handling","title":"4. Error Handling","text":"<p>We use a consistent error handling approach throughout the app:</p> <ol> <li> <p>Repository Layer: Uses <code>Result</code> type</p> <pre><code>suspend fun getData(): Result&lt;Data&gt; = suspendRunCatching {\n   dataSource.getData()\n}\n</code></pre> </li> <li> <p>ViewModel Layer: Converts to <code>OneTimeEvent</code></p> <pre><code>viewModelScope.launch {\n   repository.getData()\n       .onSuccess { data -&gt;\n           _uiState.updateState { copy(data = data) }\n       }\n       .onFailure { error -&gt;\n           _uiState.updateState {\n               copy(error = OneTimeEvent(error))\n           }\n       }\n}\n</code></pre> </li> <li> <p>UI Layer: Handled by <code>StatefulComposable</code></p> </li> </ol> <p>Tip</p> <p>This standardized approach makes error handling predictable across the entire application.</p>"},{"location":"philosophy/#5-state-updates","title":"5. State Updates","text":"<p>We provide extension functions for common state update patterns:</p> <pre><code>// Regular state updates\n_uiState.updateState {\n    copy(value = newValue)\n}\n\n// Async operations with loading state\n_uiState.updateStateWith {\n    repository.someAsyncOperation()\n}\n</code></pre>"},{"location":"philosophy/#6-feature-organization","title":"6. Feature Organization","text":"<p>Each feature is self-contained and follows a consistent structure:</p> <ul> <li><code>feature/auth/</code> - Authentication feature module</li> <li><code>navigation/</code> - Navigation-related code</li> <li><code>ui/</code> - UI components and ViewModels</li> <li><code>model/</code> - Feature-specific models</li> </ul>"},{"location":"philosophy/#conscious-trade-offs","title":"Conscious Trade-offs","text":"<p>Our design philosophy makes several conscious trade-offs:</p> <ol> <li> <p>Simplicity vs. Flexibility</p> <ul> <li>We choose simpler solutions even if they're less flexible</li> <li>Custom solutions are added only when really needed</li> </ul> </li> <li> <p>Convention vs. Configuration</p> <ul> <li>We favor strong conventions over configuration options</li> <li>This reduces decision fatigue but may limit customization</li> </ul> </li> <li> <p>Pragmatism vs. Purity</p> <ul> <li>We prioritize practical solutions over theoretical purity</li> <li>This may mean occasionally breaking \"clean\" architecture rules</li> </ul> </li> <li> <p>Consistency vs. Optimization</p> <ul> <li>We prefer consistent patterns across the codebase</li> <li>This might mean using the same solution even when a specialized one might be marginally better</li> </ul> </li> </ol> <p>Important</p> <p>These patterns are guidelines, not rules. The goal is to make the codebase more maintainable and easier to understand, not to restrict flexibility where it's truly needed.</p>"},{"location":"philosophy/#benefits-of-this-approach","title":"Benefits of This Approach","text":"<ol> <li> <p>Reduced Cognitive Load</p> <ul> <li>Developers can predict where to find things</li> <li>Common patterns reduce decision fatigue</li> </ul> </li> <li> <p>Easier Onboarding</p> <ul> <li>New team members can quickly understand the codebase</li> <li>Consistent patterns make learning curve smoother</li> </ul> </li> <li> <p>Better Maintainability</p> <ul> <li>Common patterns make code more predictable</li> <li>Centralized handling reduces bugs</li> </ul> </li> <li> <p>Improved Debugging</p> <ul> <li>State changes are explicit and traceable</li> <li>Error handling is consistent and predictable</li> </ul> </li> </ol>"},{"location":"philosophy/#when-to-break-these-rules","title":"When to Break These Rules","text":"<p>While these patterns serve well for most cases, consider alternatives when:</p> <ol> <li>A feature has unique error/loading UI requirements</li> <li>Performance optimizations are crucial</li> <li>Complex business logic demands more separation</li> <li>Third-party integration requires different patterns</li> </ol> <p>Tip</p> <p>When deviating from these patterns, document your reasoning to help other developers understand the context of your decisions.</p>"},{"location":"philosophy/#summary","title":"Summary","text":"<p>This template's design philosophy prioritizes:</p> <ul> <li>Pragmatic simplicity over theoretical purity</li> <li>Centralized state management with UiState and StatefulComposable</li> <li>Direct, explicit state updates for readability and debuggability</li> <li>Consistent error handling across all layers</li> <li>Strong conventions over flexible configuration</li> </ul> <p>These trade-offs favor maintainability, readability, and easier onboarding at the cost of some flexibility.</p>"},{"location":"philosophy/#further-reading","title":"Further Reading","text":"<ul> <li>Architecture Overview - Understand the two-layer architecture</li> <li>State Management - Deep dive into UiState and update functions</li> <li>Adding Features - Step-by-step guide applying these principles</li> </ul>"},{"location":"plugins/","title":"Convention Plugins","text":""},{"location":"plugins/#summary","title":"Summary","text":"<p>This guide explains the project's convention plugins system that centralizes build configuration in the <code>build-logic</code> directory. Learn about the five available plugins (Application, Library, UI Library, Dagger Hilt, Firebase), how to use them in your modules, and how to create custom convention plugins to avoid build configuration duplication.</p> <p>This project uses Gradle Convention Plugins to centralize common build logic and simplify module-level build files. These plugins are located in the <code>build-logic</code> directory.</p>"},{"location":"plugins/#available-plugins","title":"Available Plugins","text":""},{"location":"plugins/#1-application-plugin-devatickapplication","title":"1. Application Plugin (<code>dev.atick.application</code>)","text":"<p>Used for the main application module:</p> <ul> <li>Configures Android application defaults</li> <li>Sets up Compose</li> <li>Enables BuildConfig</li> <li>Configures Kotlin and Java versions</li> <li>Enables Kotlin context parameters (<code>-Xcontext-parameters</code>)</li> <li>Sets up Compose compiler metrics and reports</li> </ul> <pre><code>plugins {\n    alias(libs.plugins.jetpack.application)\n}\n</code></pre>"},{"location":"plugins/#2-library-plugin-devaticklibrary","title":"2. Library Plugin (<code>dev.atick.library</code>)","text":"<p>Base plugin for Android library modules:</p> <ul> <li>Configures Android library defaults</li> <li>Sets up Kotlin</li> <li>Configures Java versions</li> <li>Enables KotlinX Serialization</li> </ul> <pre><code>plugins {\n    alias(libs.plugins.jetpack.library)\n}\n</code></pre>"},{"location":"plugins/#3-ui-library-plugin-devatickuilibrary","title":"3. UI Library Plugin (<code>dev.atick.ui.library</code>)","text":"<p>Extended library plugin for UI modules:</p> <ul> <li>Includes all Library Plugin features</li> <li>Enables Jetpack Compose</li> <li>Adds Material3 experimental opt-ins</li> <li>Enables Kotlin context parameters (<code>-Xcontext-parameters</code>)</li> </ul> <pre><code>plugins {\n    alias(libs.plugins.jetpack.ui.library)\n}\n</code></pre>"},{"location":"plugins/#4-dagger-hilt-plugin-devatickdaggerhilt","title":"4. Dagger Hilt Plugin (<code>dev.atick.dagger.hilt</code>)","text":"<p>Sets up Dagger Hilt in a module:</p> <ul> <li>Applies Hilt Android plugin</li> <li>Adds KSP for annotation processing</li> <li>Configures Hilt dependencies</li> </ul> <pre><code>plugins {\n    alias(libs.plugins.jetpack.dagger.hilt)\n}\n</code></pre>"},{"location":"plugins/#5-firebase-plugin-devatickfirebase","title":"5. Firebase Plugin (<code>dev.atick.firebase</code>)","text":"<p>Configures Firebase services:</p> <ul> <li>Sets up Firebase BoM</li> <li>Configures Analytics, Crashlytics, and Performance</li> <li>Applies necessary Google Services plugins</li> </ul> <pre><code>plugins {\n    alias(libs.plugins.jetpack.firebase)\n}\n</code></pre>"},{"location":"plugins/#using-the-plugins","title":"Using the Plugins","text":"<p>To use these plugins in your module's <code>build.gradle.kts</code>:</p> <pre><code>plugins {\n    alias(libs.plugins.jetpack.ui.library)\n    alias(libs.plugins.jetpack.dagger.hilt)\n    // Add other plugins as needed\n}\n</code></pre> <p>Note</p> <p>The plugins are already registered in the version catalog (<code>libs.versions.toml</code>), making them easily accessible across all modules.</p>"},{"location":"plugins/#creating-custom-plugins","title":"Creating Custom Plugins","text":"<p>To create your own convention plugin:</p> <ol> <li>Add your plugin class in <code>build-logic/convention/src/main/kotlin</code>:</li> </ol> <pre><code>class CustomConventionPlugin : Plugin&lt;Project&gt; {\n    override fun apply(target: Project) {\n        with(target) {\n            // Your plugin configuration here\n        }\n    }\n}\n</code></pre> <ol> <li>Register it in <code>build-logic/convention/build.gradle.kts</code>:</li> </ol> <pre><code>gradlePlugin {\n    plugins {\n        register(\"customPlugin\") {\n            id = \"dev.your.plugin.id\"\n            implementationClass = \"CustomConventionPlugin\"\n        }\n    }\n}\n</code></pre> <ol> <li>Add it to <code>libs.versions.toml</code>:</li> </ol> <pre><code>[plugins]\ncustom-plugin = { id = \"dev.your.plugin.id\" }\n</code></pre>"},{"location":"plugins/#plugin-development-tips","title":"Plugin Development Tips","text":"<ol> <li>Accessing Version Catalog:</li> </ol> <pre><code>val libs = extensions.getByType&lt;VersionCatalogsExtension&gt;().named(\"libs\")\nval version = libs.findVersion(\"your.version\").get()\n</code></pre> <ol> <li>Configuring Android Extensions:</li> </ol> <pre><code>extensions.configure&lt;LibraryExtension&gt; {\n    // Your configuration\n}\n</code></pre> <ol> <li>Adding Dependencies:</li> </ol> <pre><code>dependencies {\n    \"implementation\"(libs.findLibrary(\"library.name\").get())\n}\n</code></pre> <p>Tip</p> <p>Keep your plugins focused and single-purpose. Create new plugins for distinct functionality rather than overloading existing ones.</p>"},{"location":"plugins/#best-practices","title":"Best Practices","text":"<ol> <li> <p>Module Organization:</p> <ul> <li>Use <code>jetpack.application</code> for the app module</li> <li>Use <code>jetpack.ui.library</code> for feature modules with UI</li> <li>Use <code>jetpack.library</code> for core modules without UI</li> </ul> </li> <li> <p>Plugin Combinations:</p> </li> </ol> <pre><code>plugins {\n    alias(libs.plugins.jetpack.ui.library) // Base UI setup\n    alias(libs.plugins.jetpack.dagger.hilt) // Add Hilt support\n    alias(libs.plugins.jetpack.firebase) // Add Firebase if needed\n}\n</code></pre> <ol> <li> <p>Version Management:</p> <ul> <li>Keep versions in the version catalog</li> <li>Reference them in plugins using <code>libs.findVersion()</code></li> </ul> </li> </ol> <p>Warning</p> <p>Don't repeat plugin configurations in module-level build files. If you find yourself doing this, consider creating a new convention plugin instead.</p>"},{"location":"plugins/#further-reading","title":"Further Reading","text":"<ul> <li>Dependency Management - Version catalog management used by convention plugins</li> <li>Architecture Overview - Module structure and how plugins support it</li> <li>Adding New Features - Step-by-step guide that uses convention plugins</li> </ul>"},{"location":"quick-reference/","title":"Quick Reference","text":"<p>Quick reference guide for the most commonly used patterns, utilities, and functions in this template.</p>"},{"location":"quick-reference/#summary","title":"Summary","text":"<p>This quick reference provides:</p> <ul> <li>State Management - UiState wrapper, update functions, StatefulComposable pattern</li> <li>Navigation - Type-safe routes with Kotlin Serialization</li> <li>Dependency Injection - Hilt patterns, module setup, injected dispatchers</li> <li>Error Handling - suspendRunCatching in repositories, automatic error display</li> <li>Coroutines &amp; Threading - ViewModel scope, lifecycle-aware collection, context switching</li> <li>Common Extensions - StateFlow updates, Flow collection, context utilities</li> <li>Complete Example - End-to-end feature implementation</li> </ul> <p>For detailed explanations, see the full documentation.</p> <p>Note</p> <p>API documentation is available after running <code>./gradlew dokkaGeneratePublicationHtml</code>. The generated docs will be at <code>build/dokka/html/index.html</code> and can be deployed to <code>docs/api/</code> for viewing at <code>../api/index.html</code>.</p>"},{"location":"quick-reference/#table-of-contents","title":"Table of Contents","text":"<ul> <li>State Management</li> <li>Navigation</li> <li>Dependency Injection</li> <li>Error Handling</li> <li>Coroutines &amp; Threading</li> <li>Common Extensions</li> <li>Complete Example</li> <li>Quick Commands</li> </ul>"},{"location":"quick-reference/#state-management","title":"State Management","text":""},{"location":"quick-reference/#uistate-wrapper","title":"UiState Wrapper","text":"<p>All screen state is wrapped in <code>UiState&lt;T&gt;</code>:</p> <pre><code>data class UiState&lt;T : Any&gt;(\n    val data: T,\n    val loading: Boolean = false,\n    val error: OneTimeEvent&lt;Throwable?&gt; = OneTimeEvent(null)\n)\n</code></pre> <p>Initialize in ViewModel:</p> <pre><code>private val _uiState = MutableStateFlow(UiState(YourScreenData()))\nval uiState = _uiState.asStateFlow()\n</code></pre>"},{"location":"quick-reference/#state-update-functions","title":"State Update Functions","text":"Function When to Use Returns Example <code>updateState</code> Synchronous updates (text input, toggles) Immediate <code>_uiState.updateState { copy(name = newName) }</code> <code>updateStateWith</code> Async operations returning new data <code>Result&lt;T&gt;</code> <code>_uiState.updateStateWith { repository.getData() }</code> <code>updateWith</code> Async operations returning Unit <code>Result&lt;Unit&gt;</code> <code>_uiState.updateWith { repository.saveData() }</code> <p>Quick Examples:</p> <pre><code>// Synchronous update\nfun updateName(name: String) {\n    _uiState.updateState {\n        copy(name = name)\n    }\n}\n\n// Async update with new data\nfun loadData() {\n    _uiState.updateStateWith {\n        repository.getData() // Returns Result&lt;ScreenData&gt;\n    }\n}\n\n// Async update without new data\nfun saveData() {\n    _uiState.updateWith {\n        repository.saveData() // Returns Result&lt;Unit&gt;\n    }\n}\n</code></pre>"},{"location":"quick-reference/#statefulcomposable-pattern","title":"StatefulComposable Pattern","text":"<p>Route Composable (with ViewModel):</p> <pre><code>@Composable\nfun FeatureRoute(\n    onShowSnackbar: suspend (String, SnackbarAction, Throwable?) -&gt; Boolean,\n    viewModel: FeatureViewModel = hiltViewModel()\n) {\n    val uiState by viewModel.uiState.collectAsStateWithLifecycle()\n\n    StatefulComposable(\n        state = uiState,\n        onShowSnackbar = onShowSnackbar\n    ) { screenData -&gt;\n        FeatureScreen(\n            screenData = screenData,\n            onAction = viewModel::handleAction\n        )\n    }\n}\n</code></pre> <p>Screen Composable (pure UI):</p> <pre><code>@Composable\nfun FeatureScreen(\n    screenData: FeatureScreenData,\n    onAction: (FeatureAction) -&gt; Unit\n) {\n    // Pure UI only\n}\n</code></pre> <p>\ud83d\udcda Full API Documentation - See State Management guide for detailed UiState patterns</p> <p>Note</p> <p>Complete API documentation is available after running <code>./gradlew dokkaGeneratePublicationHtml</code>.</p>"},{"location":"quick-reference/#navigation","title":"Navigation","text":""},{"location":"quick-reference/#define-routes-with-kotlin-serialization","title":"Define Routes with Kotlin Serialization","text":"<pre><code>@Serializable\ndata object FeatureNavGraph\n\n@Serializable\ndata object Feature\n\n@Serializable\ndata class FeatureDetail(val id: String)\n</code></pre>"},{"location":"quick-reference/#navigation-extensions","title":"Navigation Extensions","text":"<p>Navigate to a destination:</p> <pre><code>fun NavController.navigateToFeature(navOptions: NavOptions? = null) {\n    navigate(Feature, navOptions)\n}\n\nfun NavController.navigateToFeatureDetail(id: String) {\n    navigate(FeatureDetail(id))\n}\n</code></pre> <p>Define screen in NavGraph:</p> <pre><code>fun NavGraphBuilder.featureScreen(\n    onShowSnackbar: suspend (String, SnackbarAction, Throwable?) -&gt; Boolean,\n    onNavigateToDetail: (String) -&gt; Unit\n) {\n    composable&lt;Feature&gt; {\n        FeatureRoute(\n            onShowSnackbar = onShowSnackbar,\n            onNavigateToDetail = onNavigateToDetail\n        )\n    }\n}\n</code></pre> <p>Using in Navigation Setup:</p> <pre><code>NavHost(navController, startDestination = Feature) {\n    featureScreen(\n        onShowSnackbar = ::showSnackbar,\n        onNavigateToDetail = { id -&gt; navController.navigateToFeatureDetail(id) }\n    )\n}\n</code></pre>"},{"location":"quick-reference/#dependency-injection","title":"Dependency Injection","text":""},{"location":"quick-reference/#hilt-viewmodel","title":"Hilt ViewModel","text":"<pre><code>@HiltViewModel\nclass FeatureViewModel @Inject constructor(\n    private val repository: FeatureRepository\n) : ViewModel()\n</code></pre>"},{"location":"quick-reference/#repository-binding","title":"Repository Binding","text":"<pre><code>@Module\n@InstallIn(SingletonComponent::class)\nabstract class RepositoryModule {\n    @Binds\n    @Singleton\n    abstract fun bindFeatureRepository(\n        impl: FeatureRepositoryImpl\n    ): FeatureRepository\n}\n</code></pre>"},{"location":"quick-reference/#injected-dispatchers","title":"Injected Dispatchers","text":"<p>Always use injected dispatchers:</p> <pre><code>class DataSourceImpl @Inject constructor(\n    @IoDispatcher private val ioDispatcher: CoroutineDispatcher\n) {\n    suspend fun fetchData() = withContext(ioDispatcher) {\n        // IO operation\n    }\n}\n</code></pre> <p>Available Dispatchers:</p> Qualifier Use Case <code>@IoDispatcher</code> IO operations (network, database, file) <code>@DefaultDispatcher</code> CPU-intensive work <code>@MainDispatcher</code> UI updates"},{"location":"quick-reference/#error-handling","title":"Error Handling","text":""},{"location":"quick-reference/#repository-layer-suspendruncatching","title":"Repository Layer - suspendRunCatching","text":"<p>Always use <code>suspendRunCatching</code> in repositories:</p> <pre><code>class FeatureRepositoryImpl @Inject constructor(\n    private val networkDataSource: NetworkDataSource,\n    @IoDispatcher private val ioDispatcher: CoroutineDispatcher\n) : FeatureRepository {\n\n    override suspend fun getData(): Result&lt;Data&gt; = suspendRunCatching {\n        withContext(ioDispatcher) {\n            networkDataSource.getData()\n        }\n    }\n}\n</code></pre> <p>Why not <code>runCatching</code>? Standard <code>runCatching</code> catches <code>CancellationException</code>, which breaks coroutine cancellation. <code>suspendRunCatching</code> re-throws it.</p>"},{"location":"quick-reference/#viewmodel-layer","title":"ViewModel Layer","text":"<p>Errors are automatically handled by <code>updateStateWith</code>/<code>updateWith</code>:</p> <pre><code>fun loadData() {\n    _uiState.updateStateWith {\n        repository.getData() // Error automatically captured\n    }\n}\n</code></pre>"},{"location":"quick-reference/#ui-layer","title":"UI Layer","text":"<p><code>StatefulComposable</code> automatically displays errors via snackbar:</p> <pre><code>StatefulComposable(\n    state = uiState,\n    onShowSnackbar = onShowSnackbar\n) { screenData -&gt;\n    // Errors shown automatically\n}\n</code></pre>"},{"location":"quick-reference/#coroutines-threading","title":"Coroutines &amp; Threading","text":""},{"location":"quick-reference/#common-patterns","title":"Common Patterns","text":"<p>ViewModel Scope:</p> <pre><code>viewModelScope.launch {\n    // Coroutine automatically cancelled when ViewModel is cleared\n}\n</code></pre> <p>Collect State with Lifecycle:</p> <pre><code>val uiState by viewModel.uiState.collectAsStateWithLifecycle()\n</code></pre> <p>Switch Context for IO:</p> <pre><code>suspend fun loadFromDatabase() = withContext(ioDispatcher) {\n    database.query()\n}\n</code></pre> <p>Timeout Operations:</p> <pre><code>suspend fun connectWithTimeout(): Device {\n    return suspendCoroutineWithTimeout(30.seconds) { continuation -&gt;\n        device.connect { result -&gt;\n            continuation.resume(result)\n        }\n    }\n}\n</code></pre>"},{"location":"quick-reference/#common-extensions","title":"Common Extensions","text":""},{"location":"quick-reference/#stateflow-extensions","title":"StateFlow Extensions","text":"<pre><code>// Update state synchronously\n_uiState.updateState { copy(value = newValue) }\n\n// Update state with async operation returning new data\n_uiState.updateStateWith { repository.getData() }\n\n// Update state with async operation returning Unit\n_uiState.updateWith { repository.saveData() }\n</code></pre>"},{"location":"quick-reference/#flow-extensions","title":"Flow Extensions","text":"<pre><code>// Collect in ViewModel\nviewModelScope.launch {\n    repository.observeData().collect { data -&gt;\n        _uiState.update { it.copy(data = data) }\n    }\n}\n\n// Collect in Composable (lifecycle-aware)\nval data by remember { repository.observeData() }\n    .collectAsStateWithLifecycle(initialValue = emptyList())\n</code></pre>"},{"location":"quick-reference/#context-extensions","title":"Context Extensions","text":"<pre><code>// Using injected dispatcher\nsuspend fun loadData() = withContext(ioDispatcher) {\n    // IO work here\n}\n</code></pre>"},{"location":"quick-reference/#complete-example-feature-implementation","title":"Complete Example: Feature Implementation","text":""},{"location":"quick-reference/#1-define-screen-data","title":"1. Define Screen Data","text":"<pre><code>data class ProfileScreenData(\n    val name: String = \"\",\n    val email: String = \"\",\n    val avatarUrl: String? = null\n)\n</code></pre>"},{"location":"quick-reference/#2-create-viewmodel","title":"2. Create ViewModel","text":"<pre><code>@HiltViewModel\nclass ProfileViewModel @Inject constructor(\n    private val repository: ProfileRepository\n) : ViewModel() {\n    private val _uiState = MutableStateFlow(UiState(ProfileScreenData()))\n    val uiState = _uiState.asStateFlow()\n\n    init {\n        loadProfile()\n    }\n\n    fun loadProfile() {\n        _uiState.updateStateWith {\n            repository.getProfile()\n        }\n    }\n\n    fun updateName(name: String) {\n        _uiState.updateState {\n            copy(name = name)\n        }\n    }\n\n    fun saveProfile() {\n        _uiState.updateWith {\n            repository.saveProfile(this)\n        }\n    }\n}\n</code></pre>"},{"location":"quick-reference/#3-create-repository","title":"3. Create Repository","text":"<pre><code>class ProfileRepositoryImpl @Inject constructor(\n    private val networkDataSource: NetworkDataSource,\n    @IoDispatcher private val ioDispatcher: CoroutineDispatcher\n) : ProfileRepository {\n\n    override suspend fun getProfile(): Result&lt;ProfileScreenData&gt; = suspendRunCatching {\n        withContext(ioDispatcher) {\n            networkDataSource.getProfile().toScreenData()\n        }\n    }\n\n    override suspend fun saveProfile(data: ProfileScreenData): Result&lt;Unit&gt; = suspendRunCatching {\n        withContext(ioDispatcher) {\n            networkDataSource.saveProfile(data.toNetwork())\n        }\n    }\n}\n</code></pre>"},{"location":"quick-reference/#4-create-ui","title":"4. Create UI","text":"<pre><code>@Composable\nfun ProfileRoute(\n    onShowSnackbar: suspend (String, SnackbarAction, Throwable?) -&gt; Boolean,\n    viewModel: ProfileViewModel = hiltViewModel()\n) {\n    val uiState by viewModel.uiState.collectAsStateWithLifecycle()\n\n    StatefulComposable(\n        state = uiState,\n        onShowSnackbar = onShowSnackbar\n    ) { screenData -&gt;\n        ProfileScreen(\n            screenData = screenData,\n            onNameChange = viewModel::updateName,\n            onSave = viewModel::saveProfile\n        )\n    }\n}\n\n@Composable\nfun ProfileScreen(\n    screenData: ProfileScreenData,\n    onNameChange: (String) -&gt; Unit,\n    onSave: () -&gt; Unit\n) {\n    Column {\n        TextField(\n            value = screenData.name,\n            onValueChange = onNameChange,\n            label = { Text(\"Name\") }\n        )\n        Button(onClick = onSave) {\n            Text(\"Save\")\n        }\n    }\n}\n</code></pre>"},{"location":"quick-reference/#5-setup-navigation","title":"5. Setup Navigation","text":"<pre><code>@Serializable\ndata object Profile\n\nfun NavController.navigateToProfile(navOptions: NavOptions? = null) {\n    navigate(Profile, navOptions)\n}\n\nfun NavGraphBuilder.profileScreen(\n    onShowSnackbar: suspend (String, SnackbarAction, Throwable?) -&gt; Boolean\n) {\n    composable&lt;Profile&gt; {\n        ProfileRoute(onShowSnackbar = onShowSnackbar)\n    }\n}\n</code></pre>"},{"location":"quick-reference/#further-reading","title":"Further Reading","text":"<ul> <li>Architecture Guide - Deep dive into architecture decisions</li> <li>Getting Started - Step-by-step setup guide</li> <li>Development Guide - Comprehensive development patterns</li> <li>State Management - Complete state management guide with detailed UiState   patterns</li> <li>Data Flow - Data flow patterns</li> <li>Navigation - Type-safe navigation deep dive</li> <li>Dependency Injection - Complete DI guide</li> <li>Troubleshooting - Common issues and solutions</li> <li>FAQ - Frequently asked questions</li> <li>Tips &amp; Tricks - Best practices and advanced techniques</li> </ul>"},{"location":"quick-reference/#quick-commands","title":"Quick Commands","text":""},{"location":"quick-reference/#build-run","title":"Build &amp; Run","text":"<pre><code># Build debug APK\n./gradlew assembleDebug\n\n# Install on device\n./gradlew installDebug\n\n# Clean build\n./gradlew clean build\n</code></pre>"},{"location":"quick-reference/#code-quality","title":"Code Quality","text":"<pre><code># Check formatting\n./gradlew spotlessCheck --init-script gradle/init.gradle.kts --no-configuration-cache\n\n# Auto-format\n./gradlew spotlessApply --init-script gradle/init.gradle.kts --no-configuration-cache\n</code></pre>"},{"location":"quick-reference/#documentation","title":"Documentation","text":"<pre><code># Generate API docs\n./gradlew dokkaGeneratePublicationHtml\n\n# View at: build/dokka/html/index.html\n</code></pre>"},{"location":"quick-reference/#need-help","title":"Need Help?","text":"<ul> <li>Check the full documentation for detailed guides</li> <li>Review the Troubleshooting Guide for common issues</li> <li>See the FAQ for frequently asked questions</li> <li>Open an issue on GitHub</li> </ul>"},{"location":"spotless/","title":"Spotless Linting Setup","text":""},{"location":"spotless/#summary","title":"Summary","text":"<p>This guide explains the project's code formatting and license header management using Spotless with ktlint. Learn how to check and apply formatting, customize copyright headers, configure IDE integration, and ensure your code passes CI checks. Always run <code>spotlessApply</code> before committing to avoid CI failures.</p> <p>This project uses Spotless for code formatting and license header management. Spotless is configured to work with Kotlin, Groovy, Gradle KTS files, and XML files.</p>"},{"location":"spotless/#features","title":"Features","text":"<p>The Spotless configuration includes:</p> <ul> <li>Kotlin formatting using ktlint</li> <li>Customizable formatting using <code>ktlint</code> and the <code>.editorconfig</code> file</li> <li>Custom Compose UI rules for better   Jetpack Compose code formatting</li> <li>License header management for all supported file types</li> <li>Gradle and XML file formatting</li> </ul>"},{"location":"spotless/#using-spotless","title":"Using Spotless","text":""},{"location":"spotless/#intellijandroid-studio-run-configurations","title":"IntelliJ/Android Studio Run Configurations","text":"<p>The project includes pre-configured run configurations in the <code>.run</code> directory:</p> <ol> <li> <p>Spotless Check: Verifies if all files conform to the formatting rules</p> <ul> <li>Run using: <code>./gradlew spotlessCheck</code></li> <li>Or use the \"Spotless Check\" run configuration in Android Studio</li> </ul> </li> <li> <p>Spotless Apply: Automatically formats all files according to the rules</p> <ul> <li>Run using: <code>./gradlew spotlessApply</code></li> <li>Or use the \"Spotless Apply\" run configuration in Android Studio</li> </ul> </li> </ol> <p>Tip</p> <p>Always run Spotless Apply before committing your changes to ensure consistent code formatting.</p>"},{"location":"spotless/#cicd-integration","title":"CI/CD Integration","text":"<p>The project's GitHub Actions workflow automatically runs <code>spotlessCheck</code> on pull requests. Your PR will fail if there are any formatting issues.</p>"},{"location":"spotless/#customizing-copyright-headers","title":"Customizing Copyright Headers","text":"<p>The project includes default copyright headers in the <code>spotless</code> directory:</p> <ul> <li><code>copyright.kt</code> - For Kotlin files</li> <li><code>copyright.gradle</code> - For Gradle files</li> <li><code>copyright.kts</code> - For Kotlin Script files</li> <li><code>copyright.xml</code> - For XML files</li> </ul> <p>To use your own copyright headers:</p> <ol> <li>Navigate to the <code>spotless</code> directory</li> <li>Replace the content of the copyright files with your own headers</li> <li>Maintain the proper file format for each type</li> </ol> <p>Example copyright header for Kotlin files:</p> <pre><code>/*\n * Copyright (c) 2024 Your Name/Organization\n * \n * Licensed under ...\n */\n</code></pre> <p>Note</p> <p>Make sure to update all copyright files to maintain consistency across different file types.</p>"},{"location":"spotless/#configuration-details","title":"Configuration Details","text":"<p>The Spotless configuration is defined in <code>gradle/init.gradle.kts</code> and includes:</p>"},{"location":"spotless/#kotlin-configuration","title":"Kotlin Configuration","text":"<pre><code>kotlin {\n    target(\"**/*.kt\")\n    targetExclude(\"**/build/**/*.kt\")\n    ktlint(ktlintVersion).editorConfigOverride(\n        mapOf(\n            \"android\" to \"true\",\n        ),\n    ).customRuleSets(\n        listOf(\n            \"io.nlopez.compose.rules:ktlint:0.4.16\",\n        ),\n    )\n    licenseHeaderFile(rootProject.file(\"spotless/copyright.kt\"))\n}\n</code></pre>"},{"location":"spotless/#other-file-types","title":"Other File Types","text":"<p>The configuration includes similar setups for:</p> <ul> <li>Groovy (Gradle) files</li> <li>Kotlin Script (<code>.kts</code>) files</li> <li>XML files</li> </ul> <p>Important</p> <p>The build task will fail if any files don't match the formatting rules. Always run <code>spotlessApply</code> if <code>spotlessCheck</code> fails.</p>"},{"location":"spotless/#best-practices","title":"Best Practices","text":"<ol> <li> <p>Pre-commit Hook: Consider setting up a pre-commit hook to run <code>spotlessApply</code>:    <pre><code>./gradlew spotlessApply\n</code></pre></p> </li> <li> <p>IDE Integration: Use the provided run configurations in Android Studio for easy access to    Spotless commands.</p> </li> <li> <p>Regular Checks: Run Spotless Check periodically during development, not just before commits.</p> </li> <li> <p>Copyright Updates: Remember to update copyright years and organization information in the    header files when necessary.</p> </li> </ol> <p>Tip</p> <p>If you're using Android Studio, you can bind the Spotless Apply run configuration to a keyboard shortcut for quick formatting.</p>"},{"location":"spotless/#further-reading","title":"Further Reading","text":"<ul> <li>GitHub CI/CD Setup - Continuous integration workflow that runs spotlessCheck</li> <li>Troubleshooting - Solutions for common Spotless formatting issues</li> <li>Convention Plugins - Build logic that configures Spotless</li> </ul>"},{"location":"state-management/","title":"State Management Deep Dive","text":"<p>This guide provides a comprehensive understanding of the state management pattern used in this Android starter template. The pattern centers around predictable, centralized state management using the <code>UiState</code> wrapper combined with specialized update functions.</p>"},{"location":"state-management/#table-of-contents","title":"Table of Contents","text":"<ol> <li>Core Concepts</li> <li>The UiState Wrapper</li> <li>Update Functions Explained</li> <li>Kotlin Context Parameters</li> <li>Complete Examples</li> <li>Advanced Patterns</li> <li>Anti-Patterns to Avoid</li> <li>Migration Guide</li> </ol>"},{"location":"state-management/#core-concepts","title":"Core Concepts","text":""},{"location":"state-management/#philosophy","title":"Philosophy","text":"<p>The state management pattern in this template follows these principles:</p> <ol> <li>Single Source of Truth: Each screen has exactly one <code>UiState&lt;ScreenData&gt;</code> that represents all    UI state</li> <li>Unidirectional Data Flow: Data flows from Repository \u2192 ViewModel \u2192 UI in one direction</li> <li>Automatic Loading &amp; Error Handling: Loading states and errors are handled automatically by    <code>UiState</code></li> <li>Predictable Updates: State updates follow consistent patterns using <code>updateState</code>,    <code>updateStateWith</code>, and <code>updateWith</code></li> <li>Type Safety: Compile-time guarantees through Kotlin's type system</li> </ol>"},{"location":"state-management/#architecture-layers","title":"Architecture Layers","text":"<pre><code>graph TB\n    subgraph UI[\"UI Layer (Compose)\"]\n        SC[StatefulComposable&lt;br/&gt;- Shows LoadingIndicator&lt;br/&gt;- Shows ErrorSnackbar&lt;br/&gt;- Renders Screen]\n    end\n\nsubgraph VM[\"ViewModel Layer (MVVM)\"]\nVML[ViewModel&lt;br/&gt;- _uiState: MutableStateFlow&lt;br/&gt;- uiState: StateFlow&lt;br/&gt;- updateState&amp;#40;&amp;#41;&lt;br/&gt;- updateStateWith&amp;#40;&amp;#41;&lt;br/&gt;- updateWith&amp;#40;&amp;#41;]\nend\n\nsubgraph Data[\"Data Layer (Repository)\"]\nRepo[Repository&lt;br/&gt;- suspendRunCatching &amp;#123; &amp;#125;&lt;br/&gt;- Flow&amp;lt;Data&amp;gt;]\nend\n\nUI --&gt;|UiState&amp;lt ;ScreenData&amp;gt ;|VM\nVM --&gt;|Result&amp;lt ;T&amp;gt ;|Data\n\nstyle UI fill:#e1f5ff, stroke: #01579b, stroke-width: 2px\nstyle VM fill: #fff3e0, stroke: #e65100,stroke-width: 2px\nstyle Data fill: #f3e5f5,stroke: #4a148c, stroke-width: 2px</code></pre>"},{"location":"state-management/#the-uistate-wrapper","title":"The UiState Wrapper","text":""},{"location":"state-management/#definition","title":"Definition","text":"<pre><code>data class UiState&lt;T : Any&gt;(\n    val data: T,\n    val loading: Boolean = false,\n    val error: OneTimeEvent&lt;Throwable?&gt; = OneTimeEvent(null)\n)\n</code></pre>"},{"location":"state-management/#purpose","title":"Purpose","text":"<p><code>UiState&lt;T&gt;</code> wraps your screen data (<code>T</code>) and adds:</p> <ul> <li><code>data: T</code>: The actual screen data (always available, even during loading/error)</li> <li><code>loading: Boolean</code>: Indicates if an async operation is in progress</li> <li><code>error: OneTimeEvent&lt;Throwable?&gt;</code>: One-time error events that won't re-trigger on   recomposition</li> </ul>"},{"location":"state-management/#why-use-uistate","title":"Why Use UiState?","text":"<p>Without UiState (Anti-pattern):</p> <pre><code>// \u274c Multiple state flows - complex and error-prone\nclass BadViewModel : ViewModel() {\n    private val _posts = MutableStateFlow&lt;List&lt;Post&gt;&gt;(emptyList())\n    val posts = _posts.asStateFlow()\n\n    private val _isLoading = MutableStateFlow(false)\n    val isLoading = _isLoading.asStateFlow()\n\n    private val _error = MutableStateFlow&lt;String?&gt;(null)\n    val error = _error.asStateFlow()\n\n    fun loadPosts() {\n        viewModelScope.launch {\n            _isLoading.value = true\n            _error.value = null\n            try {\n                _posts.value = repository.getPosts()\n            } catch (e: Exception) {\n                _error.value = e.message\n            } finally {\n                _isLoading.value = false\n            }\n        }\n    }\n}\n</code></pre> <p>With UiState (Correct pattern):</p> <pre><code>// \u2705 Single state flow - simple and predictable\ndata class PostsScreenData(\n    val posts: List&lt;Post&gt; = emptyList()\n)\n\nclass GoodViewModel @Inject constructor(\n    private val repository: PostsRepository\n) : ViewModel() {\n    private val _uiState = MutableStateFlow(UiState(PostsScreenData()))\n    val uiState = _uiState.asStateFlow()\n\n    fun loadPosts() {\n        _uiState.updateStateWith {\n            repository.getPosts().map { posts -&gt;\n                copy(posts = posts)\n            }\n        }\n    }\n}\n</code></pre>"},{"location":"state-management/#update-functions-explained","title":"Update Functions Explained","text":"<p>There are three update functions, each designed for a specific use case:</p> Function Use Case Returns New Data? Async? <code>updateState</code> Synchronous state changes No No <code>updateStateWith</code> Async operations that return new data Yes Yes <code>updateWith</code> Async operations without new data (side effects) No Yes"},{"location":"state-management/#1-updatestate-synchronous-updates","title":"1. updateState - Synchronous Updates","text":"<p>Use when: Updating state based on current data (no async operations)</p> <pre><code>/**\n * Synchronous state update function.\n * Use this when you need to update the screen data based on current state,\n * without performing any asynchronous operations.\n */\nfun updateValue(newValue: String) {\n    _uiState.updateState {\n        copy(searchQuery = newValue)\n    }\n}\n</code></pre> <p>Example - Form Input:</p> <pre><code>data class FormScreenData(\n    val name: String = \"\",\n    val email: String = \"\",\n    val isValid: Boolean = false\n)\n\nclass FormViewModel : ViewModel() {\n    private val _uiState = MutableStateFlow(UiState(FormScreenData()))\n    val uiState = _uiState.asStateFlow()\n\n    fun onNameChanged(name: String) {\n        _uiState.updateState {\n            copy(\n                name = name,\n                isValid = name.isNotBlank() &amp;&amp; email.isNotBlank()\n            )\n        }\n    }\n\n    fun onEmailChanged(email: String) {\n        _uiState.updateState {\n            copy(\n                email = email,\n                isValid = name.isNotBlank() &amp;&amp; email.isNotBlank()\n            )\n        }\n    }\n}\n</code></pre>"},{"location":"state-management/#2-updatestatewith-async-with-new-data","title":"2. updateStateWith - Async with New Data","text":"<p>Use when: Fetching data from repository/network and updating state with the result</p> <pre><code>/**\n * Async state update function that returns new data.\n * Use this when you need to perform an async operation (like fetching from repository)\n * and update the screen data with the result.\n */\nfun loadPosts() {\n    _uiState.updateStateWith {\n        repository.getPosts().map { posts -&gt;\n            copy(posts = posts)\n        }\n    }\n}\n</code></pre> <p>How it works:</p> <ol> <li>Sets <code>loading = true</code></li> <li>Executes your async block</li> <li>If success: Updates <code>data</code> with result, sets <code>loading = false</code></li> <li>If failure: Sets <code>error</code> with exception, keeps existing <code>data</code>, sets <code>loading = false</code></li> </ol> <p>Example - Loading User Profile:</p> <pre><code>data class ProfileScreenData(\n    val user: User? = null,\n    val followers: List&lt;User&gt; = emptyList()\n)\n\nclass ProfileViewModel @Inject constructor(\n    private val userRepository: UserRepository\n) : ViewModel() {\n    private val _uiState = MutableStateFlow(UiState(ProfileScreenData()))\n    val uiState = _uiState.asStateFlow()\n\n    fun loadProfile(userId: String) {\n        _uiState.updateStateWith {\n            userRepository.getUser(userId).map { user -&gt;\n                copy(user = user)\n            }\n        }\n    }\n\n    fun loadFollowers(userId: String) {\n        _uiState.updateStateWith {\n            userRepository.getFollowers(userId).map { followers -&gt;\n                copy(followers = followers)\n            }\n        }\n    }\n}\n</code></pre>"},{"location":"state-management/#3-updatewith-async-without-new-data","title":"3. updateWith - Async without New Data","text":"<p>Use when: Performing async operations that don't return data (side effects like save, delete, update)</p> <pre><code>/**\n * Async operation without returning new data.\n * Use this when you need to perform a side effect (like saving to database)\n * that doesn't return new data to display.\n */\nfun savePost(post: Post) {\n    _uiState.updateWith {\n        repository.savePost(post)\n    }\n}\n</code></pre> <p>How it works:</p> <ol> <li>Sets <code>loading = true</code></li> <li>Executes your async block</li> <li>If success: Sets <code>loading = false</code> (data unchanged)</li> <li>If failure: Sets <code>error</code> with exception, sets <code>loading = false</code></li> </ol> <p>Example - Saving Settings:</p> <pre><code>data class SettingsScreenData(\n    val darkMode: Boolean = false,\n    val notifications: Boolean = true\n)\n\nclass SettingsViewModel @Inject constructor(\n    private val settingsRepository: SettingsRepository\n) : ViewModel() {\n    private val _uiState = MutableStateFlow(UiState(SettingsScreenData()))\n    val uiState = _uiState.asStateFlow()\n\n    fun toggleDarkMode() {\n        _uiState.updateState {\n            copy(darkMode = !darkMode)\n        }\n        _uiState.updateWith {\n            settingsRepository.saveDarkMode(uiState.value.data.darkMode)\n        }\n    }\n\n    fun deleteAccount() {\n        _uiState.updateWith {\n            settingsRepository.deleteAccount()\n        }\n    }\n}\n</code></pre>"},{"location":"state-management/#kotlin-context-parameters","title":"Kotlin Context Parameters","text":""},{"location":"state-management/#what-are-context-parameters","title":"What Are Context Parameters?","text":"<p>Kotlin 2.0 introduces context parameters - a way to implicitly pass context to functions without explicitly declaring parameters. This template uses context parameters in the update functions to access <code>viewModelScope</code>.</p>"},{"location":"state-management/#traditional-approach-before-context-parameters","title":"Traditional Approach (Before Context Parameters)","text":"<pre><code>// \u274c Old way - must pass viewModelScope explicitly\nfun &lt;T : Any&gt; MutableStateFlow&lt;UiState&lt;T&gt;&gt;.updateStateWith(\n    viewModelScope: CoroutineScope,  // Explicit parameter\n    transform: suspend T.() -&gt; Result&lt;T&gt;\n) {\n    viewModelScope.launch {\n        // ...\n    }\n}\n\n// Usage - verbose\n_uiState.updateStateWith(viewModelScope) {\n    repository.getData()\n}\n</code></pre>"},{"location":"state-management/#with-context-parameters-current-implementation","title":"With Context Parameters (Current Implementation)","text":"<pre><code>// \u2705 New way - viewModelScope is implicit\ncontext(ViewModel)  // Context parameter declaration\nfun &lt;T : Any&gt; MutableStateFlow&lt;UiState&lt;T&gt;&gt;.updateStateWith(\n    transform: suspend T.() -&gt; Result&lt;T&gt;\n) {\n    viewModelScope.launch {  // Accessed from context\n        // ...\n    }\n}\n\n// Usage - clean and concise\n_uiState.updateStateWith {\n    repository.getData()\n}\n</code></pre>"},{"location":"state-management/#how-it-works","title":"How It Works","text":"<ol> <li>Declaration: <code>context(ViewModel)</code> declares that this function requires a <code>ViewModel</code> context</li> <li>Access: Inside the function, you can access <code>viewModelScope</code> from the <code>ViewModel</code> context</li> <li>Invocation: When calling from a <code>ViewModel</code> class, the context is automatically provided</li> </ol>"},{"location":"state-management/#benefits","title":"Benefits","text":"<ul> <li>Cleaner API: No need to pass <code>viewModelScope</code> every time</li> <li>Type Safety: Compiler enforces that function is only called from <code>ViewModel</code></li> <li>Reduced Boilerplate: Less repetitive code</li> </ul>"},{"location":"state-management/#compiler-flag","title":"Compiler Flag","text":"<p>To use context parameters, the project enables the feature via compiler flag:</p> <pre><code>// In build-logic/convention/../KotlinLibraryConventionPlugin.kt\nkotlinOptions {\n    freeCompilerArgs = freeCompilerArgs + listOf(\n        \"-Xcontext-receivers\",      // Old name\n        \"-Xcontext-parameters\"      // New name in Kotlin 2.0+\n    )\n}\n</code></pre>"},{"location":"state-management/#complete-examples","title":"Complete Examples","text":""},{"location":"state-management/#example-1-posts-list-screen","title":"Example 1: Posts List Screen","text":"<pre><code>// 1. Define screen data\ndata class PostsScreenData(\n    val posts: List&lt;Post&gt; = emptyList(),\n    val searchQuery: String = \"\",\n    val selectedFilter: FilterType = FilterType.ALL\n)\n\n// 2. Create ViewModel\n@HiltViewModel\nclass PostsViewModel @Inject constructor(\n    private val postsRepository: PostsRepository\n) : ViewModel() {\n    private val _uiState = MutableStateFlow(UiState(PostsScreenData()))\n    val uiState = _uiState.asStateFlow()\n\n    init {\n        loadPosts()\n    }\n\n    // Load posts (async with new data)\n    fun loadPosts() {\n        _uiState.updateStateWith {\n            postsRepository.observePosts().first().map { posts -&gt;\n                copy(posts = posts.filter(selectedFilter))\n            }\n        }\n    }\n\n    // Update search query (synchronous)\n    fun onSearchQueryChanged(query: String) {\n        _uiState.updateState {\n            copy(searchQuery = query)\n        }\n    }\n\n    // Change filter (synchronous + reload)\n    fun onFilterChanged(filter: FilterType) {\n        _uiState.updateState {\n            copy(selectedFilter = filter)\n        }\n        loadPosts()\n    }\n\n    // Delete post (async without new data)\n    fun deletePost(postId: String) {\n        _uiState.updateWith {\n            postsRepository.deletePost(postId)\n        }\n    }\n}\n\n// 3. Create UI\n@Composable\nfun PostsRoute(\n    onShowSnackbar: suspend (String, SnackbarAction, Throwable?) -&gt; Boolean,\n    viewModel: PostsViewModel = hiltViewModel()\n) {\n    val uiState by viewModel.uiState.collectAsStateWithLifecycle()\n\n    StatefulComposable(\n        state = uiState,\n        onShowSnackbar = onShowSnackbar\n    ) { screenData -&gt;\n        PostsScreen(\n            posts = screenData.posts,\n            searchQuery = screenData.searchQuery,\n            onSearchQueryChanged = viewModel::onSearchQueryChanged,\n            onFilterChanged = viewModel::onFilterChanged,\n            onDeletePost = viewModel::deletePost\n        )\n    }\n}\n\n@Composable\nprivate fun PostsScreen(\n    posts: List&lt;Post&gt;,\n    searchQuery: String,\n    onSearchQueryChanged: (String) -&gt; Unit,\n    onFilterChanged: (FilterType) -&gt; Unit,\n    onDeletePost: (String) -&gt; Unit\n) {\n    Column {\n        SearchBar(\n            query = searchQuery,\n            onQueryChange = onSearchQueryChanged\n        )\n        FilterChips(onFilterChanged = onFilterChanged)\n        LazyColumn {\n            items(posts) { post -&gt;\n                PostCard(\n                    post = post,\n                    onDelete = { onDeletePost(post.id) }\n                )\n            }\n        }\n    }\n}\n</code></pre>"},{"location":"state-management/#example-2-form-with-validation","title":"Example 2: Form with Validation","text":"<pre><code>// 1. Define screen data\ndata class SignUpScreenData(\n    val email: String = \"\",\n    val password: String = \"\",\n    val confirmPassword: String = \"\",\n    val emailError: String? = null,\n    val passwordError: String? = null,\n    val isFormValid: Boolean = false\n)\n\n// 2. Create ViewModel\n@HiltViewModel\nclass SignUpViewModel @Inject constructor(\n    private val authRepository: AuthRepository\n) : ViewModel() {\n    private val _uiState = MutableStateFlow(UiState(SignUpScreenData()))\n    val uiState = _uiState.asStateFlow()\n\n    fun onEmailChanged(email: String) {\n        _uiState.updateState {\n            copy(\n                email = email,\n                emailError = validateEmail(email),\n                isFormValid = isValid(email, password, confirmPassword)\n            )\n        }\n    }\n\n    fun onPasswordChanged(password: String) {\n        _uiState.updateState {\n            copy(\n                password = password,\n                passwordError = validatePassword(password, confirmPassword),\n                isFormValid = isValid(email, password, confirmPassword)\n            )\n        }\n    }\n\n    fun onConfirmPasswordChanged(confirmPassword: String) {\n        _uiState.updateState {\n            copy(\n                confirmPassword = confirmPassword,\n                passwordError = validatePassword(password, confirmPassword),\n                isFormValid = isValid(email, password, confirmPassword)\n            )\n        }\n    }\n\n    fun signUp() {\n        _uiState.updateWith {\n            authRepository.signUp(email, password)\n        }\n    }\n\n    private fun validateEmail(email: String): String? {\n        return if (email.isBlank()) \"Email is required\"\n        else if (!android.util.Patterns.EMAIL_ADDRESS.matcher(email).matches())\n            \"Invalid email format\"\n        else null\n    }\n\n    private fun validatePassword(password: String, confirmPassword: String): String? {\n        return when {\n            password.isBlank() -&gt; \"Password is required\"\n            password.length &lt; 8 -&gt; \"Password must be at least 8 characters\"\n            password != confirmPassword -&gt; \"Passwords do not match\"\n            else -&gt; null\n        }\n    }\n\n    private fun SignUpScreenData.isValid(\n        email: String,\n        password: String,\n        confirmPassword: String\n    ): Boolean {\n        return validateEmail(email) == null &amp;&amp;\n                validatePassword(password, confirmPassword) == null\n    }\n}\n</code></pre>"},{"location":"state-management/#advanced-patterns","title":"Advanced Patterns","text":""},{"location":"state-management/#pattern-1-multiple-async-operations","title":"Pattern 1: Multiple Async Operations","text":"<p>Sequential async operations:</p> <pre><code>fun loadUserData(userId: String) {\n    _uiState.updateStateWith {\n        // Load user first\n        userRepository.getUser(userId).flatMap { user -&gt;\n            // Then load their posts\n            postsRepository.getUserPosts(userId).map { posts -&gt;\n                copy(user = user, posts = posts)\n            }\n        }\n    }\n}\n</code></pre> <p>Parallel async operations:</p> <pre><code>fun loadDashboard(userId: String) {\n    _uiState.updateStateWith {\n        // Load both in parallel\n        val userDeferred = async { userRepository.getUser(userId) }\n        val statsDeferred = async { statsRepository.getStats(userId) }\n\n        // Wait for both\n        val user = userDeferred.await().getOrThrow()\n        val stats = statsDeferred.await().getOrThrow()\n\n        Result.success(copy(user = user, stats = stats))\n    }\n}\n</code></pre>"},{"location":"state-management/#pattern-2-partial-loading-states","title":"Pattern 2: Partial Loading States","text":"<p>When you need fine-grained loading indicators:</p> <pre><code>data class DashboardScreenData(\n    val user: User? = null,\n    val posts: List&lt;Post&gt; = emptyList(),\n    val isLoadingPosts: Boolean = false,\n    val isLoadingUser: Boolean = false\n)\n\nclass DashboardViewModel : ViewModel() {\n    private val _uiState = MutableStateFlow(UiState(DashboardScreenData()))\n    val uiState = _uiState.asStateFlow()\n\n    fun loadUser() {\n        viewModelScope.launch {\n            _uiState.update { it.copy(data = it.data.copy(isLoadingUser = true)) }\n\n            userRepository.getUser().onSuccess { user -&gt;\n                _uiState.updateState {\n                    copy(user = user, isLoadingUser = false)\n                }\n            }.onFailure { error -&gt;\n                _uiState.update {\n                    it.copy(\n                        data = it.data.copy(isLoadingUser = false),\n                        error = OneTimeEvent(error)\n                    )\n                }\n            }\n        }\n    }\n\n    fun loadPosts() {\n        viewModelScope.launch {\n            _uiState.update { it.copy(data = it.data.copy(isLoadingPosts = true)) }\n\n            postsRepository.getPosts().onSuccess { posts -&gt;\n                _uiState.updateState {\n                    copy(posts = posts, isLoadingPosts = false)\n                }\n            }.onFailure { error -&gt;\n                _uiState.update {\n                    it.copy(\n                        data = it.data.copy(isLoadingPosts = false),\n                        error = OneTimeEvent(error)\n                    )\n                }\n            }\n        }\n    }\n}\n</code></pre>"},{"location":"state-management/#pattern-3-optimistic-updates","title":"Pattern 3: Optimistic Updates","text":"<p>Update UI immediately, rollback on failure:</p> <pre><code>fun likePost(post: Post) {\n    // Optimistic update\n    val originalLikeStatus = post.isLiked\n    _uiState.updateState {\n        copy(\n            posts = posts.map {\n                if (it.id == post.id) it.copy(isLiked = !it.isLiked)\n                else it\n            }\n        )\n    }\n\n    // Try to save to server\n    viewModelScope.launch {\n        postsRepository.toggleLike(post.id).onFailure {\n            // Rollback on failure\n            _uiState.updateState {\n                copy(\n                    posts = posts.map {\n                        if (it.id == post.id) it.copy(isLiked = originalLikeStatus)\n                        else it\n                    }\n                )\n            }\n            _uiState.update {\n                it.copy(error = OneTimeEvent(Exception(\"Failed to like post\")))\n            }\n        }\n    }\n}\n</code></pre>"},{"location":"state-management/#anti-patterns-to-avoid","title":"Anti-Patterns to Avoid","text":""},{"location":"state-management/#anti-pattern-1-multiple-stateflows","title":"\u274c Anti-Pattern 1: Multiple StateFlows","text":"<pre><code>// \u274c DON'T: Manage multiple state flows\nclass BadViewModel : ViewModel() {\n    private val _posts = MutableStateFlow&lt;List&lt;Post&gt;&gt;(emptyList())\n    val posts = _posts.asStateFlow()\n\n    private val _loading = MutableStateFlow(false)\n    val loading = _loading.asStateFlow()\n\n    private val _error = MutableStateFlow&lt;String?&gt;(null)\n    val error = _error.asStateFlow()\n}\n\n// \u2705 DO: Use single UiState\nclass GoodViewModel : ViewModel() {\n    private val _uiState = MutableStateFlow(UiState(PostsScreenData()))\n    val uiState = _uiState.asStateFlow()\n}\n</code></pre>"},{"location":"state-management/#anti-pattern-2-manual-loading-management","title":"\u274c Anti-Pattern 2: Manual Loading Management","text":"<pre><code>// \u274c DON'T: Manually manage loading states\nfun loadPosts() {\n    viewModelScope.launch {\n        _uiState.update { it.copy(loading = true) }\n        try {\n            val posts = repository.getPosts().getOrThrow()\n            _uiState.update {\n                it.copy(\n                    data = it.data.copy(posts = posts),\n                    loading = false\n                )\n            }\n        } catch (e: Exception) {\n            _uiState.update {\n                it.copy(\n                    loading = false,\n                    error = OneTimeEvent(e)\n                )\n            }\n        }\n    }\n}\n\n// \u2705 DO: Use updateStateWith - handles loading automatically\nfun loadPosts() {\n    _uiState.updateStateWith {\n        repository.getPosts().map { posts -&gt;\n            copy(posts = posts)\n        }\n    }\n}\n</code></pre>"},{"location":"state-management/#anti-pattern-3-nullable-data","title":"\u274c Anti-Pattern 3: Nullable Data","text":"<pre><code>// \u274c DON'T: Use nullable data in UiState\ndata class BadScreenData(\n    val user: User? = null  // Nullable - forces null checks everywhere\n)\n\n// \u2705 DO: Provide sensible defaults\ndata class GoodScreenData(\n    val user: User = User.EMPTY,  // Non-null with empty state\n    val hasLoadedUser: Boolean = false  // Explicit flag if needed\n)\n</code></pre>"},{"location":"state-management/#anti-pattern-4-direct-repository-calls-in-ui","title":"\u274c Anti-Pattern 4: Direct Repository Calls in UI","text":"<pre><code>// \u274c DON'T: Call repository directly from composables\n@Composable\nfun BadScreen(repository: PostsRepository) {\n    val posts = repository.observePosts()\n        .collectAsStateWithLifecycle(emptyList())\n    // UI rendering\n}\n\n// \u2705 DO: Call through ViewModel\n@Composable\nfun GoodRoute(viewModel: PostsViewModel = hiltViewModel()) {\n    val uiState by viewModel.uiState.collectAsStateWithLifecycle()\n\n    StatefulComposable(state = uiState) { screenData -&gt;\n        GoodScreen(posts = screenData.posts)\n    }\n}\n</code></pre>"},{"location":"state-management/#migration-guide","title":"Migration Guide","text":""},{"location":"state-management/#from-livedata-to-stateflow-uistate","title":"From LiveData to StateFlow + UiState","text":"<p>Before (LiveData):</p> <pre><code>class OldViewModel : ViewModel() {\n    private val _posts = MutableLiveData&lt;List&lt;Post&gt;&gt;()\n    val posts: LiveData&lt;List&lt;Post&gt;&gt; = _posts\n\n    private val _loading = MutableLiveData(false)\n    val loading: LiveData&lt;Boolean&gt; = _loading\n\n    fun loadPosts() {\n        _loading.value = true\n        viewModelScope.launch {\n            try {\n                _posts.value = repository.getPosts()\n            } finally {\n                _loading.value = false\n            }\n        }\n    }\n}\n</code></pre> <p>After (StateFlow + UiState):</p> <pre><code>data class PostsScreenData(\n    val posts: List&lt;Post&gt; = emptyList()\n)\n\nclass NewViewModel @Inject constructor(\n    private val repository: PostsRepository\n) : ViewModel() {\n    private val _uiState = MutableStateFlow(UiState(PostsScreenData()))\n    val uiState = _uiState.asStateFlow()\n\n    fun loadPosts() {\n        _uiState.updateStateWith {\n            repository.getPosts().map { posts -&gt;\n                copy(posts = posts)\n            }\n        }\n    }\n}\n</code></pre>"},{"location":"state-management/#from-sealed-class-state-to-uistate","title":"From Sealed Class State to UiState","text":"<p>Before (Sealed Class):</p> <pre><code>sealed class ScreenState {\n    object Loading : ScreenState()\n    data class Success(val data: List&lt;Post&gt;) : ScreenState()\n    data class Error(val message: String) : ScreenState()\n}\n\nclass OldViewModel : ViewModel() {\n    private val _state = MutableStateFlow&lt;ScreenState&gt;(ScreenState.Loading)\n    val state = _state.asStateFlow()\n\n    fun loadPosts() {\n        _state.value = ScreenState.Loading\n        viewModelScope.launch {\n            _state.value = try {\n                ScreenState.Success(repository.getPosts())\n            } catch (e: Exception) {\n                ScreenState.Error(e.message ?: \"Unknown error\")\n            }\n        }\n    }\n}\n</code></pre> <p>After (UiState):</p> <pre><code>data class PostsScreenData(\n    val posts: List&lt;Post&gt; = emptyList()\n)\n\nclass NewViewModel @Inject constructor(\n    private val repository: PostsRepository\n) : ViewModel() {\n    private val _uiState = MutableStateFlow(UiState(PostsScreenData()))\n    val uiState = _uiState.asStateFlow()\n\n    fun loadPosts() {\n        _uiState.updateStateWith {\n            repository.getPosts().map { posts -&gt;\n                copy(posts = posts)\n            }\n        }\n    }\n}\n</code></pre>"},{"location":"state-management/#summary","title":"Summary","text":"<p>Key Takeaways:</p> <ol> <li>Use <code>UiState&lt;T&gt;</code> wrapper - Centralizes loading, error, and data state</li> <li>Choose the right update function:<ul> <li><code>updateState</code> for synchronous updates</li> <li><code>updateStateWith</code> for async operations returning data</li> <li><code>updateWith</code> for async side effects</li> </ul> </li> <li>Context parameters make API cleaner - No need to pass <code>viewModelScope</code></li> <li>StatefulComposable handles UI boilerplate - Automatic loading and error display</li> <li>Single source of truth - One <code>StateFlow&lt;UiState&lt;ScreenData&gt;&gt;</code> per screen</li> </ol>"},{"location":"state-management/#further-reading","title":"Further Reading","text":""},{"location":"state-management/#concept-guides","title":"Concept Guides","text":"<ul> <li>Quick Reference - Cheat sheet for state management patterns</li> <li>Architecture Overview - Understand the two-layer architecture</li> <li>Adding Features - Step-by-step implementation guide</li> <li>Navigation Deep Dive - Learn how navigation integrates with state</li> </ul>"},{"location":"state-management/#module-documentation","title":"Module Documentation","text":"<ul> <li>Core UI Module - State management utilities and UiState wrapper</li> <li>Data Layer Module - Repository patterns and data flow</li> <li>Feature Modules - Examples of state management in practice</li> </ul>"},{"location":"state-management/#api-documentation","title":"API Documentation","text":"<ul> <li> <code>StatefulComposable.kt</code> -   Stateful composable implementation</li> </ul>"},{"location":"tips/","title":"Tips and Tricks","text":"<p>Get the most out of this template with these useful tips and features organized by category.</p>"},{"location":"tips/#ui-layer-tips","title":"UI Layer Tips","text":""},{"location":"tips/#pre-built-components","title":"Pre-built Components","text":"<p>The <code>core:ui/components</code> directory contains pre-built Material3 composables ready to use:</p> <pre><code>// Buttons\nJetpackButton(onClick = {})\nJetpackOutlinedButton(onClick = {})\nJetpackTextButton(onClick = {})\nJetpackIconToggleButton(checked = isChecked, onCheckedChange = {})\nJetpackExtendedFab(text = \"Create\", icon = Icons.Default.Add, onClick = {})\n\n// Input\nJetpackTextField(value = \"\", onValueChange = {})\n\n// Selection\nJetpackFilterChip(selected = isSelected, onClick = {}, label = { Text(\"Filter\") })\nJetpackTag(followed = isFollowed, onClick = {}, text = \"Topic\")\nJetpackToggleOptions(options = listOf(\"Light\", \"Dark\"), selectedIndex = 0, onOptionSelected = {})\n\n// Navigation\nJetpackNavigationSuiteScaffold(...)  // Adaptive: bottom bar/rail/drawer\nJetpackNavigationBar(...)            // Bottom navigation\nJetpackNavigationRail(...)           // Side navigation\nJetpackTab(...)                      // Individual tab\nJetpackTabRow(...)                   // Tab container\n\n// Display\nJetpackLoadingWheel(contentDesc = \"\")\nJetpackOverlayLoadingWheel(contentDesc = \"\")\nDynamicAsyncImage(imageUrl = url, contentDescription = \"\")\nDividerWithText(text = \"OR\")\n\n// Layout\nAppBackground(modifier = Modifier)\nAppGradientBackground(gradientColors = gradientColors)\nSwipeToDismiss(onDelete = {})\n\n// App bars\nJetpackTopAppBar(...)\n</code></pre> <p>Tip</p> <p>Always use these pre-built components instead of creating new ones. They provide consistent styling across your app and can be modified centrally in <code>core:ui</code>.</p>"},{"location":"tips/#theming-system","title":"Theming System","text":"<p>The <code>core:ui/theme</code> directory provides a complete theming system with Material3 support:</p> <pre><code>// Apply custom theme with dynamic color support\nJetpackTheme(\n    darkTheme = isDarkTheme,\n    disableDynamicTheming = false  // Enable Material You dynamic colors\n) {\n    // Your content\n}\n\n// Use decorative backgrounds\nAppGradientBackground(\n    gradientColors = GradientColors()  // Automatic theme-aware gradient\n) {\n    // Your content\n}\n</code></pre>"},{"location":"tips/#composable-previews","title":"Composable Previews","text":"<p>Use the provided multi-preview annotations for efficient UI development:</p> <pre><code>@Composable\n@PreviewThemes     // Preview in both light and dark themes\n@PreviewDevices    // Preview on different device sizes\nfun YourComposablePreview() {\n    JetpackTheme {\n        YourComposable()\n    }\n}\n</code></pre> <p>Preview devices include: - Phone (360\u00d7640dp @ 480dpi) - Landscape (640\u00d7360dp @ 480dpi) - Foldable (673\u00d7841dp @ 480dpi) - Tablet (1280\u00d7800dp @ 480dpi)</p> <p>Preview themes: Light and Dark modes</p> <p>Combining both annotations generates 8 previews (4 devices \u00d7 2 themes) automatically!</p>"},{"location":"tips/#state-management-utilities","title":"State Management Utilities","text":"<p>The template provides helper functions for managing UI state in ViewModels:</p> <pre><code>@HiltViewModel\nclass FeatureViewModel @Inject constructor(\n    private val repository: FeatureRepository\n) : ViewModel() {\n    private val _uiState = MutableStateFlow(UiState(FeatureScreenData()))\n    val uiState = _uiState.asStateFlow()\n\n    // Synchronous state updates (no loading indicator)\n    fun updateName(name: String) {\n        _uiState.updateState {\n            copy(name = name)\n        }\n    }\n\n    // Async operations that return new data (automatic loading + error handling)\n    fun loadData() {\n        _uiState.updateStateWith {\n            repository.getData()  // Returns Result&lt;FeatureScreenData&gt;\n        }\n    }\n\n    // Async operations that perform actions (automatic loading + error handling)\n    fun saveData() {\n        _uiState.updateWith {\n            repository.saveData(this)  // Returns Result&lt;Unit&gt;\n        }\n    }\n}\n</code></pre> <p>Helper functions: - <code>updateState { }</code> - Synchronous updates (text input, toggles, local state) - <code>updateStateWith { }</code> - Async operations returning new data (load, refresh, search) - <code>updateWith { }</code> - Async operations performing actions (save, delete, send)</p> <p>Note</p> <p>These functions use Kotlin's context parameters. The ViewModel scope is automatically available - you never need to pass it explicitly.</p>"},{"location":"tips/#automatic-error-handling","title":"Automatic Error Handling","text":"<p>Use <code>StatefulComposable</code> to automatically handle loading states and errors:</p> <pre><code>@Composable\nfun FeatureRoute(\n    onShowSnackbar: suspend (String, SnackbarAction, Throwable?) -&gt; Boolean,\n    viewModel: FeatureViewModel = hiltViewModel()\n) {\n    val uiState by viewModel.uiState.collectAsStateWithLifecycle()\n\n    StatefulComposable(\n        state = uiState,\n        onShowSnackbar = onShowSnackbar\n    ) { screenData -&gt;\n        FeatureScreen(\n            screenData = screenData,\n            onAction = viewModel::handleAction\n        )\n    }\n}\n</code></pre> <p>What StatefulComposable does: - Displays your content based on current data - Shows overlay loading indicator when <code>loading = true</code> - Automatically displays errors via snackbar - Includes \"Report\" button that logs errors to Firebase Crashlytics</p> <p>Tip</p> <p>This pattern enforces clean separation: Route composable manages state collection, Screen composable is pure UI with no ViewModel dependency.</p>"},{"location":"tips/#data-layer-tips","title":"Data Layer Tips","text":""},{"location":"tips/#string-validation-extensions","title":"String Validation Extensions","text":"<p>The <code>core:android</code> module provides validation utilities in <code>StringExtensions.kt</code>:</p> <pre><code>// Email validation\nemail.isEmailValid()  // Uses Android's Patterns.EMAIL_ADDRESS\n\n// Password validation (8-20 chars, at least 1 digit, 1 lowercase letter)\npassword.isPasswordValid()\n\n// Full name validation (at least 2 parts, letters only)\nname.isValidFullName()\n</code></pre> <p>Usage example:</p> <pre><code>// In a ViewModel - validate user input\nfun validateEmail(email: String): Boolean {\n    return email.isEmailValid()\n}\n\n// In a Composable - show error state\nvar email by remember { mutableStateOf(\"\") }\n\nOutlinedTextField(\n    value = email,\n    onValueChange = { email = it },\n    isError = email.isNotEmpty() &amp;&amp; !email.isEmailValid(),\n    label = { Text(\"Email\") }\n)\n</code></pre> <p>Note</p> <p>All validation functions are null-safe - they return <code>false</code> for null or empty strings.</p>"},{"location":"tips/#ide-productivity-tips","title":"IDE Productivity Tips","text":""},{"location":"tips/#secrets-management","title":"Secrets Management","text":"<p>The template includes the <code>gradle-secrets-plugin</code> for secure credentials management:</p> <pre><code># local.properties (git-ignored)\nAPI_KEY=your_actual_api_key\nAPI_SECRET=your_actual_secret\n</code></pre> <pre><code># secrets.defaults.properties (version controlled)\nAPI_KEY=dummy_api_key\nAPI_SECRET=dummy_secret\n</code></pre> <p>Access secrets as <code>BuildConfig</code> fields:</p> <pre><code>val apiKey = BuildConfig.apiKey\n</code></pre> <p>Tip</p> <p>Use <code>secrets.defaults.properties</code> to provide dummy values for CI/CD environments while keeping sensitive data in <code>local.properties</code>.</p>"},{"location":"tips/#documentation-generation","title":"Documentation Generation","text":"<p>The template comes with Dokka configured for API documentation generation:</p> <pre><code># Generate API documentation\n./gradlew dokkaGeneratePublicationHtml\n\n# The generated docs will be available at:\n# build/dokka/html/index.html\n</code></pre> <p>MkDocs is also configured for guide documentation:</p> <pre><code># Install MkDocs (once)\npip install mkdocs mkdocs-material\n\n# Serve documentation locally\nmkdocs serve\n\n# View at http://localhost:8000\n</code></pre> <p>Note</p> <p>If you're using GitHub, documentation is automatically generated and published through the <code>.github/workflows/docs.yml</code> workflow.</p>"},{"location":"tips/#multilingual-support","title":"Multilingual Support","text":"<p>Automatic locale configuration is enabled in <code>app/build.gradle.kts</code>:</p> <pre><code>androidResources {\n    generateLocaleConfig = true\n}\n</code></pre> <p>Locale preferences are saved and applied automatically via <code>AndroidManifest.xml</code>:</p> <pre><code>&lt;service\n    android:name=\"androidx.appcompat.app.AppLocalesMetadataHolderService\"\n    android:enabled=\"false\"\n    android:exported=\"false\"&gt;\n    &lt;meta-data\n        android:name=\"autoStoreLocales\"\n        android:value=\"true\" /&gt;\n&lt;/service&gt;\n</code></pre> <p>This automatically: - Generates <code>LocaleConfig</code> from your string resource files - Saves user's language preference - Applies saved locale on app restart</p> <p>Read more: Android App Languages Guide</p>"},{"location":"tips/#performance-tips","title":"Performance Tips","text":""},{"location":"tips/#image-loading-optimization","title":"Image Loading Optimization","text":"<p>Use <code>DynamicAsyncImage</code> for all remote images - it's optimized with Coil:</p> <pre><code>DynamicAsyncImage(\n    imageUrl = user.avatarUrl,\n    contentDescription = \"User avatar\",\n    modifier = Modifier.size(48.dp)\n)\n</code></pre> <p>Built-in optimizations (from <code>CoilModule.kt</code>): - Automatic disk caching - Memory caching - Crossfade animations - Placeholder and error handling - Respect dark theme (no-ops color filter on dark backgrounds)</p> <p>Tip</p> <p>For more image loading optimization techniques, see the Performance Guide.</p>"},{"location":"tips/#loading-state-best-practices","title":"Loading State Best Practices","text":"<p>Leverage the centralized loading patterns:</p> <pre><code>// Overlay loading (blocks interaction)\nif (state.loading) {\n    JetpackOverlayLoadingWheel(contentDesc = \"Loading data\")\n}\n\n// Inline loading (doesn't block)\nif (isRefreshing) {\n    JetpackLoadingWheel(contentDesc = \"Refreshing\")\n}\n</code></pre> <p>Note</p> <p><code>StatefulComposable</code> automatically handles overlay loading based on <code>UiState.loading</code>. Use inline loading for pull-to-refresh or partial screen updates.</p>"},{"location":"tips/#best-practices","title":"Best Practices","text":""},{"location":"tips/#component-usage","title":"Component Usage","text":"<ol> <li>Use Pre-built Components</li> <li>Leverage components in <code>core:ui/components</code></li> <li>Maintain consistent styling across the app</li> <li> <p>Centralize design system changes</p> </li> <li> <p>Follow the State Management Pattern</p> </li> <li>Route composable \u2192 manages ViewModel + state collection</li> <li>Screen composable \u2192 pure UI with data + event callbacks</li> <li> <p>Use <code>StatefulComposable</code> for automatic loading/error handling</p> </li> <li> <p>Validation</p> </li> <li>Use built-in validation extensions (<code>isEmailValid</code>, <code>isPasswordValid</code>)</li> <li>Show validation errors inline with <code>isError</code> parameter</li> <li>Validate on input change, not just on submit</li> </ol>"},{"location":"tips/#documentation","title":"Documentation","text":"<ol> <li>Keep KDoc Updated</li> <li>Document all public APIs with KDoc comments</li> <li>Use Dokka to generate API documentation</li> <li> <p>Leverage automated docs workflow on GitHub</p> </li> <li> <p>Use Module READMEs</p> </li> <li>Each module has a README explaining its purpose</li> <li>Module READMEs appear in Dokka output</li> <li> <p>Keep them focused on module architecture</p> </li> <li> <p>Secrets Management</p> </li> <li>Store sensitive data in <code>local.properties</code> (git-ignored)</li> <li>Provide defaults in <code>secrets.defaults.properties</code></li> <li>Use <code>BuildConfig</code> fields for compile-time configuration</li> </ol> <p>Tip</p> <p>Explore the <code>core</code> modules thoroughly - they contain many utilities that can save you time and ensure consistency across your app.</p>"},{"location":"tips/#git-workflow-tips","title":"Git Workflow Tips","text":""},{"location":"tips/#commit-message-convention","title":"Commit Message Convention","text":"<p>This project follows the Conventional Commits standard:</p> <pre><code>&lt;type&gt;(&lt;scope&gt;): &lt;description&gt;\n\n[optional body]\n\n[optional footer]\n</code></pre> <p>Commit Types: - <code>feat</code> - New feature for the user - <code>fix</code> - Bug fix - <code>docs</code> - Documentation changes - <code>refactor</code> - Code change that neither fixes a bug nor adds a feature - <code>test</code> - Adding or updating tests - <code>chore</code> - Maintenance tasks, dependency updates - <code>style</code> - Code style changes (formatting, missing semi-colons, etc.) - <code>perf</code> - Performance improvements</p> <p>Examples:</p> <pre><code># Feature addition\nfeat(auth): add password reset functionality\n\n# Bug fix\nfix(home): resolve crash on empty data\n\n# Documentation update\ndocs: update repository pattern guide\n\n# Refactoring\nrefactor(ui): simplify state management utilities\n</code></pre> <p>Tip</p> <p>Following Conventional Commits enables automatic changelog generation and semantic versioning.</p>"},{"location":"tips/#pre-commit-workflow","title":"Pre-commit Workflow","text":"<p>Always run these commands before committing:</p> <pre><code># 1. Format code with Spotless\n./gradlew spotlessApply\n\n# 2. Build to check for compilation errors\n./gradlew build\n\n# 3. Stage and commit with conventional commit message\ngit add .\ngit commit -m \"docs: update tips documentation\"\n</code></pre> <p>Important</p> <p>The CI workflow runs <code>spotlessCheck</code> on pull requests. Your PR will fail if code is not properly formatted.</p>"},{"location":"tips/#git-ignore-configuration","title":"Git Ignore Configuration","text":"<p>The <code>.gitignore</code> is pre-configured to exclude: - Build artifacts (<code>build/</code>, <code>*.apk</code>) - Local configuration (<code>local.properties</code>, <code>keystore.properties</code>) - IDE files (<code>.idea/</code>, <code>*.iml</code>) - Firebase config (<code>google-services.json</code>) - Keystore files (<code>*.jks</code>, <code>*.keystore</code>) - AI tool configs (<code>.claude/</code>, <code>.gemini/</code>)</p> <p>Warning</p> <p>Never commit <code>keystore.properties</code>, keystore files, or production <code>google-services.json</code> to version control.</p>"},{"location":"tips/#android-studio-productivity","title":"Android Studio Productivity","text":""},{"location":"tips/#ide-run-configurations","title":"IDE Run Configurations","text":"<p>The project includes pre-configured run configurations in the <code>.run</code> directory:</p> <p>Spotless Check (<code>Spotless Check.run.xml</code>) - Verifies if all files conform to formatting rules - Run from toolbar or with <code>./gradlew spotlessCheck</code></p> <p>Spotless Apply (<code>Spotless Apply.run.xml</code>) - Automatically formats all files - Run from toolbar or with <code>./gradlew spotlessApply</code> - Always run before committing</p> <p>Generate Docs (<code>Generate Docs.run.xml</code>) - Generates Dokka HTML documentation - Run from toolbar or with <code>./gradlew dokkaGeneratePublicationHtml</code></p> <p>Signing Report (<code>Signing Report.run.xml</code>) - Displays SHA-1 fingerprint for Firebase setup - Run from toolbar or with <code>./gradlew signingReport</code></p> <p>Tip</p> <p>Bind frequently-used run configurations to keyboard shortcuts for faster access. Go to Settings \u2192 Keymap \u2192 External Tools.</p>"},{"location":"tips/#editorconfig-integration","title":"EditorConfig Integration","text":"<p>The project includes <code>.editorconfig</code> for consistent code style:</p> <pre><code>[*.{kt,kts}]\nij_kotlin_allow_trailing_comma=true\nij_kotlin_allow_trailing_comma_on_call_site=true\nktlint_function_naming_ignore_when_annotated_with=Composable, Test\n</code></pre> <p>Features: - Trailing commas enabled for cleaner diffs - Composable functions exempt from standard naming rules - Automatic ktlint configuration for Spotless</p> <p>Note</p> <p>Android Studio automatically applies EditorConfig settings. No additional setup required.</p>"},{"location":"tips/#debugging-tips","title":"Debugging Tips","text":""},{"location":"tips/#leakcanary-memory-leak-detection","title":"LeakCanary Memory Leak Detection","text":"<p>LeakCanary is automatically included in debug builds:</p> <pre><code>// app/build.gradle.kts\ndebugImplementation(libs.leakcanary.android)\n</code></pre> <p>What it does: - Automatically detects memory leaks in debug builds - Shows notification when leaks are found - Provides detailed leak trace in the app</p> <p>Usage: 1. Run debug build on device/emulator 2. Use the app normally 3. LeakCanary notifies you if it detects leaks 4. Tap notification to view leak trace 5. Fix the leak based on the trace information</p> <p>Tip</p> <p>LeakCanary only runs in debug builds - zero overhead in release builds.</p>"},{"location":"tips/#compose-preview-optimization","title":"Compose Preview Optimization","text":"<p>Use multi-preview annotations for efficient preview generation:</p> <pre><code>@Composable\n@PreviewThemes     // Generates 2 previews (light + dark)\n@PreviewDevices    // Generates 4 previews (phone, landscape, foldable, tablet)\nfun YourComposablePreview() {\n    JetpackTheme {\n        YourComposable()\n    }\n}\n</code></pre> <p>Combining both annotations generates 8 previews (4 devices \u00d7 2 themes) automatically!</p> <p>Tip</p> <p>In Android Studio, use \"Pin\" to keep specific previews visible while editing for instant visual feedback.</p>"},{"location":"tips/#build-performance","title":"Build Performance","text":"<p>Enable Gradle parallel execution in <code>gradle.properties</code>:</p> <pre><code>org.gradle.parallel=true\norg.gradle.caching=true\n</code></pre> <p>Use build cache:</p> <pre><code># Clean build with cache\n./gradlew clean build --build-cache\n\n# Check what tasks are cached\n./gradlew build --scan\n</code></pre> <p>Note</p> <p>These settings are already configured in the template's <code>gradle.properties</code>.</p>"},{"location":"tips/#module-documentation","title":"Module Documentation","text":"<ul> <li>Core UI Module - UI components, state management utilities, and theming</li> <li>Core Android Module - Android utilities, extensions, and DI qualifiers</li> <li>Core Network Module - Network utilities and HTTP client configuration</li> <li>Data Layer - Repository patterns and data source management</li> <li>Sync Module - Background synchronization with WorkManager</li> </ul>"},{"location":"tips/#concept-guides","title":"Concept Guides","text":"<ul> <li>State Management Guide - Deep dive into state patterns and best practices</li> <li>Components Guide - Comprehensive guide to all available components</li> <li>Performance Optimization - Performance best practices and optimization techniques</li> <li>Quick Reference - Cheat sheet for common patterns and utilities</li> <li>Navigation Deep Dive - Type-safe navigation patterns and implementation</li> <li>Architecture Overview - Two-layer architecture and design decisions</li> <li>Dependency Injection - Hilt setup and patterns</li> </ul>"},{"location":"troubleshooting/","title":"Troubleshooting Guide","text":"<p>This guide helps you resolve common issues when working with this Android starter template.</p>"},{"location":"troubleshooting/#build-errors","title":"Build Errors","text":""},{"location":"troubleshooting/#gradle-sync-failures","title":"Gradle Sync Failures","text":""},{"location":"troubleshooting/#jdk-version-mismatch","title":"JDK Version Mismatch","text":"<p>Error:</p> <pre><code>Jetpack requires JDK 17+ but it is currently using JDK 11.\nJava Home: [/path/to/jdk-11]\n</code></pre> <p>Solution:</p> <ol> <li>Install JDK 21 (required by this template)</li> <li>Configure Android Studio to use JDK 21:<ul> <li>File \u2192 Project Structure \u2192 SDK Location \u2192 Gradle Settings</li> <li>Set Gradle JDK to version 21</li> </ul> </li> <li>Verify in <code>settings.gradle.kts</code>:    <pre><code>check(JavaVersion.current().isCompatibleWith(JavaVersion.VERSION_17))\n</code></pre></li> </ol> <p>References:</p> <ul> <li>settings.gradle.kts:88-94</li> <li>Android Studio JDK Configuration</li> </ul>"},{"location":"troubleshooting/#repository-access-issues","title":"Repository Access Issues","text":"<p>Error:</p> <pre><code>Could not resolve com.google.firebase:firebase-bom:34.4.0\n</code></pre> <p>Solution:</p> <ol> <li>Check <code>settings.gradle.kts</code> repository configuration:    <pre><code>repositories {\n    google {\n        content {\n            includeGroupByRegex(\"com\\\\.google.*\")\n        }\n    }\n    mavenCentral()\n}\n</code></pre></li> <li>Verify internet connection</li> <li>Clear Gradle cache:    <pre><code>./gradlew clean --refresh-dependencies\n</code></pre></li> <li>Check if behind a corporate proxy (configure in <code>gradle.properties</code>)</li> </ol> <p>References:</p> <ul> <li>settings.gradle.kts:32-44</li> </ul>"},{"location":"troubleshooting/#version-catalog-issues","title":"Version Catalog Issues","text":"<p>Error:</p> <pre><code>Could not resolve libs.androidx.core.ktx\n</code></pre> <p>Solution:</p> <ol> <li>Ensure <code>gradle/libs.versions.toml</code> exists and is valid</li> <li>Check version catalog syntax:    <pre><code>[libraries]\nandroidx-core-ktx = { group = \"androidx.core\", name = \"core-ktx\", version.ref = \"androidxCore\" }\n</code></pre></li> <li>Verify version references exist in <code>[versions]</code> section</li> <li>Sync project with Gradle files</li> </ol> <p>References:</p> <ul> <li>gradle/libs.versions.toml</li> </ul>"},{"location":"troubleshooting/#kspkapt-errors","title":"KSP/Kapt Errors","text":""},{"location":"troubleshooting/#hilt-compilation-errors","title":"Hilt Compilation Errors","text":"<p>Error:</p> <pre><code>[Dagger/MissingBinding] Cannot be provided without an @Inject constructor or an @Provides-annotated method\n</code></pre> <p>Solution:</p> <ol> <li>Verify Hilt plugin is applied in module's <code>build.gradle.kts</code>:    <pre><code>plugins {\n    alias(libs.plugins.jetpack.dagger.hilt)\n}\n</code></pre></li> <li>Check if class is annotated properly:    <pre><code>@HiltViewModel\nclass MyViewModel @Inject constructor(...)\n</code></pre></li> <li>Ensure repository has <code>@Binds</code> or <code>@Provides</code> in a Hilt module</li> <li>Clean and rebuild:    <pre><code>./gradlew clean build\n</code></pre></li> </ol> <p>References:</p> <ul> <li>build-logic/convention/src/main/kotlin/DaggerHiltConventionPlugin.kt</li> <li>See Dependency Injection Guide</li> </ul>"},{"location":"troubleshooting/#room-database-compilation-errors","title":"Room Database Compilation Errors","text":"<p>Error:</p> <pre><code>error: Cannot find setter for field\n</code></pre> <p>Solution:</p> <ol> <li>Ensure entity class properties match DAO query column names</li> <li>Add <code>@ColumnInfo</code> annotation if database column name differs:    <pre><code>@Entity\ndata class MyEntity(\n    @ColumnInfo(name = \"user_id\") val userId: String\n)\n</code></pre></li> <li>Verify <code>@PrimaryKey</code> is present</li> <li>Clean and rebuild project</li> </ol> <p>References:</p> <ul> <li>core/room/src/main/kotlin/dev/atick/core/room/</li> </ul>"},{"location":"troubleshooting/#dependency-resolution-issues","title":"Dependency Resolution Issues","text":""},{"location":"troubleshooting/#duplicate-class-errors","title":"Duplicate Class Errors","text":"<p>Error:</p> <pre><code>Duplicate class kotlin.collections.CollectionsKt found in modules\n</code></pre> <p>Solution:</p> <ol> <li>Check for conflicting dependency versions in <code>gradle/libs.versions.toml</code></li> <li>Use BOM (Bill of Materials) for consistent versioning:    <pre><code>implementation(platform(libs.firebase.bom))\n</code></pre></li> <li>Exclude transitive dependencies if needed:    <pre><code>implementation(libs.some.library) {\n    exclude(group = \"org.jetbrains.kotlin\", module = \"kotlin-stdlib\")\n}\n</code></pre></li> </ol> <p>References:</p> <ul> <li>gradle/libs.versions.toml</li> <li>build-logic/convention/src/main/kotlin/FirebaseConventionPlugin.kt:35</li> </ul>"},{"location":"troubleshooting/#configuration-cache-warnings","title":"Configuration Cache Warnings","text":"<p>Error:</p> <pre><code>Configuration cache problems found in this build\n</code></pre> <p>Solution:</p> <ol> <li>This is expected due to google-services plugin (see gradle.properties:28)</li> <li>Warning mode is configured intentionally:    <pre><code>org.gradle.configuration-cache.problems=warn\n</code></pre></li> <li>Build will complete successfully - these are warnings, not errors</li> <li>Reference    issue: google/play-services-plugins#246</li> </ol> <p>References:</p> <ul> <li>gradle.properties:24-28</li> </ul>"},{"location":"troubleshooting/#runtime-errors","title":"Runtime Errors","text":""},{"location":"troubleshooting/#application-crashes-on-startup","title":"Application Crashes on Startup","text":""},{"location":"troubleshooting/#firebase-initialization-failure","title":"Firebase Initialization Failure","text":"<p>Error (Logcat):</p> <pre><code>java.lang.IllegalStateException: Default FirebaseApp is not initialized\n</code></pre> <p>Solution:</p> <ol> <li>Verify <code>google-services.json</code> exists in <code>app/</code> directory</li> <li>Check Firebase plugin is applied in <code>app/build.gradle.kts</code>:    <pre><code>plugins {\n    alias(libs.plugins.jetpack.firebase)\n}\n</code></pre></li> <li>Ensure <code>google-services</code> plugin is applied (happens automatically via convention plugin)</li> <li>If using custom <code>google-services.json</code>:<ul> <li>Verify package name matches <code>applicationId</code> in <code>build.gradle.kts</code></li> <li>Check Firebase project configuration in Firebase Console</li> </ul> </li> </ol> <p>References:</p> <ul> <li>app/build.gradle.kts:30</li> <li>build-logic/convention/src/main/kotlin/FirebaseConventionPlugin.kt:30</li> <li>Firebase Setup Guide</li> </ul>"},{"location":"troubleshooting/#hilt-injection-failures","title":"Hilt Injection Failures","text":"<p>Error (Logcat):</p> <pre><code>java.lang.RuntimeException: Unable to create application:\njava.lang.IllegalStateException: Hilt entry point not found\n</code></pre> <p>Solution:</p> <ol> <li>Verify <code>Application</code> class is annotated with <code>@HiltAndroidApp</code>:    <pre><code>@HiltAndroidApp\nclass JetpackApplication : Application()\n</code></pre></li> <li>Check activities are annotated with <code>@AndroidEntryPoint</code>:    <pre><code>@AndroidEntryPoint\nclass MainActivity : ComponentActivity()\n</code></pre></li> <li>Ensure ViewModel uses <code>@HiltViewModel</code>:    <pre><code>@HiltViewModel\nclass MyViewModel @Inject constructor(...) : ViewModel()\n</code></pre></li> <li>Clean and rebuild project</li> </ol> <p>References:</p> <ul> <li>app/src/main/kotlin/dev/atick/compose/JetpackApplication.kt</li> <li>app/src/main/kotlin/dev/atick/compose/ui/MainActivity.kt</li> </ul>"},{"location":"troubleshooting/#navigation-errors","title":"Navigation Errors","text":""},{"location":"troubleshooting/#navigation-destination-not-found","title":"Navigation Destination Not Found","text":"<p>Error (Logcat):</p> <pre><code>java.lang.IllegalArgumentException: Navigation destination that matches request NavDeepLinkRequest cannot be found\n</code></pre> <p>Solution:</p> <ol> <li>Verify destination is defined in navigation graph:    <pre><code>@Serializable\ndata object MyDestination\n\nfun NavGraphBuilder.myScreen(...) {\n    composable&lt;MyDestination&gt; { ... }\n}\n</code></pre></li> <li>Ensure navigation graph is added to <code>NavHost</code>:    <pre><code>NavHost(...) {\n    myScreen(...)\n}\n</code></pre></li> <li>Check if using correct navigation route type</li> <li>Verify nested graphs have correct start destination</li> </ol> <p>References:</p> <ul> <li>app/src/main/kotlin/dev/atick/compose/navigation/</li> <li>Navigation Deep Dive</li> </ul>"},{"location":"troubleshooting/#navigation-argument-serialization-errors","title":"Navigation Argument Serialization Errors","text":"<p>Error (Logcat):</p> <pre><code>kotlinx.serialization.SerializationException: Serializer for class 'MyData' is not found\n</code></pre> <p>Solution:</p> <ol> <li>Add <code>@Serializable</code> annotation to data class:    <pre><code>@Serializable\ndata class MyDestination(val id: String, val data: MyData)\n\n@Serializable\ndata class MyData(val name: String)\n</code></pre></li> <li>Ensure Kotlin serialization plugin is applied:    <pre><code>plugins {\n    alias(libs.plugins.kotlin.serialization)\n}\n</code></pre></li> <li>For custom types, provide custom serializer</li> </ol> <p>References:</p> <ul> <li>Navigation Deep Dive</li> </ul>"},{"location":"troubleshooting/#backstack-issues","title":"Backstack Issues","text":"<p>Problem: Unexpected backstack behavior (duplicate screens, can't go back, wrong screen when pressing back)</p> <p>Solution:</p> <ol> <li>For \"pop to specific destination\", use <code>popUpTo</code> with <code>inclusive</code>:    <pre><code>navController.navigate(Home) {\n    popUpTo(Login) { inclusive = true }  // Remove Login from backstack\n}\n</code></pre></li> <li>For \"single instance\" screens (like Home), use <code>launchSingleTop</code>:    <pre><code>navController.navigate(Home) {\n    launchSingleTop = true\n    restoreState = true\n}\n</code></pre></li> <li>For bottom navigation, use proper state restoration:    <pre><code>navController.navigate(destination) {\n    popUpTo(navController.graph.findStartDestination().id) {\n        saveState = true\n    }\n    launchSingleTop = true\n    restoreState = true\n}\n</code></pre></li> <li>To clear entire backstack and start fresh:    <pre><code>navController.navigate(Home) {\n    popUpTo(0) { inclusive = true }  // Clear all backstack\n}\n</code></pre></li> <li>Debug backstack state:    <pre><code>Timber.d(\"Backstack: ${navController.currentBackStack.value.map { it.destination.route }}\")\n</code></pre></li> </ol> <p>References:</p> <ul> <li>Navigation Deep Dive</li> <li>app/src/main/kotlin/dev/atick/compose/navigation/TopLevelNavigation.kt</li> </ul>"},{"location":"troubleshooting/#nested-navigation-graph-issues","title":"Nested Navigation Graph Issues","text":"<p>Problem: Nested graphs not working, start destination errors, or can't navigate to nested destinations</p> <p>Solution:</p> <ol> <li>Ensure nested graph has explicit start destination:    <pre><code>@Serializable\ndata object AuthNavGraph\n\n@Serializable\ndata object Login\n\nfun NavGraphBuilder.authNavGraph() {\n    navigation&lt;AuthNavGraph&gt;(startDestination = Login) {  // Must specify startDestination\n        composable&lt;Login&gt; { LoginRoute(...) }\n        composable&lt;Register&gt; { RegisterRoute(...) }\n    }\n}\n</code></pre></li> <li>Navigate to nested graph's start destination (not the graph itself):    <pre><code>// Wrong - can't navigate to graph\nnavController.navigate(AuthNavGraph)\n\n// Correct - navigate to start destination\nnavController.navigate(Login)\n</code></pre></li> <li>For deep links into nested graphs, ensure route hierarchy is correct:    <pre><code>// Nested graph route hierarchy: AuthNavGraph &gt; Login\ncomposable&lt;Login&gt;(\n    deepLinks = listOf(navDeepLink&lt;Login&gt;(basePath = \"app://auth/login\"))\n) { ... }\n</code></pre></li> <li>When popping from nested graph, pop to parent graph's destination:    <pre><code>navController.navigate(Home) {\n    popUpTo(AuthNavGraph) { inclusive = true }  // Remove entire auth flow\n}\n</code></pre></li> <li>Check if parent NavHost includes nested graph:    <pre><code>NavHost(...) {\n    authNavGraph()  // Must be called to register nested graph\n    homeNavGraph()\n}\n</code></pre></li> </ol> <p>References:</p> <ul> <li>Navigation Deep Dive</li> <li>app/src/main/kotlin/dev/atick/compose/navigation/JetpackNavHost.kt</li> </ul>"},{"location":"troubleshooting/#navigation-arguments-not-received","title":"Navigation Arguments Not Received","text":"<p>Problem: Arguments passed to destination are null or have default values instead of passed values</p> <p>Solution:</p> <ol> <li>Ensure destination parameter names match navigation arguments:    <pre><code>@Serializable\ndata class Profile(val userId: String)  // Parameter name must match\n\n// In composable\ncomposable&lt;Profile&gt; { backStackEntry -&gt;\n    val profile: Profile = backStackEntry.toRoute()\n    ProfileRoute(userId = profile.userId)  // Use parameter from route\n}\n</code></pre></li> <li>Verify arguments are passed when navigating:    <pre><code>// Wrong - missing argument\nnavController.navigate(Profile(\"\"))\n\n// Correct - pass actual argument\nnavController.navigate(Profile(userId = currentUserId))\n</code></pre></li> <li>For optional arguments, use nullable types or default values:    <pre><code>@Serializable\ndata class Profile(\n    val userId: String,\n    val tab: String? = null  // Optional argument with default\n)\n</code></pre></li> <li>Check for serialization issues (see \"Navigation Argument Serialization Errors\" above)</li> <li>Debug arguments:    <pre><code>composable&lt;Profile&gt; { backStackEntry -&gt;\n    val profile: Profile = backStackEntry.toRoute()\n    Timber.d(\"Received userId: ${profile.userId}\")\n    ProfileRoute(userId = profile.userId)\n}\n</code></pre></li> </ol> <p>References:</p> <ul> <li>Navigation Deep Dive</li> </ul>"},{"location":"troubleshooting/#state-management-issues","title":"State Management Issues","text":""},{"location":"troubleshooting/#state-not-updating-in-ui","title":"State Not Updating in UI","text":"<p>Problem: UI doesn't reflect ViewModel state changes</p> <p>Solution:</p> <ol> <li>Ensure using <code>collectAsStateWithLifecycle()</code> in composables:    <pre><code>val uiState by viewModel.uiState.collectAsStateWithLifecycle()\n</code></pre></li> <li>Verify ViewModel uses <code>MutableStateFlow</code>:    <pre><code>private val _uiState = MutableStateFlow(UiState(MyScreenData()))\nval uiState = _uiState.asStateFlow()\n</code></pre></li> <li>Use proper state update functions:    <pre><code>// Synchronous updates\n_uiState.updateState { copy(name = newName) }\n\n// Async operations with Result&lt;T&gt;\n_uiState.updateStateWith { repository.getData() }\n\n// Async operations with Result&lt;Unit&gt;\n_uiState.updateWith { repository.saveData() }\n</code></pre></li> </ol> <p>References:</p> <ul> <li>core/ui/src/main/kotlin/dev/atick/core/ui/utils/StatefulComposable.kt</li> <li>State Management Guide</li> </ul>"},{"location":"troubleshooting/#onetimeevent-not-consumed","title":"OneTimeEvent Not Consumed","text":"<p>Problem: Error messages or navigation events trigger multiple times</p> <p>Solution:</p> <ol> <li>Use <code>OneTimeEvent</code> wrapper for single-consumption events:    <pre><code>data class UiState&lt;T&gt;(\n    val data: T,\n    val error: OneTimeEvent&lt;Throwable?&gt; = OneTimeEvent(null)\n)\n</code></pre></li> <li>Consume event properly in UI:    <pre><code>StatefulComposable(\n    state = uiState,\n    onShowSnackbar = onShowSnackbar\n) { ... }\n</code></pre></li> <li><code>StatefulComposable</code> handles event consumption automatically</li> </ol> <p>References:</p> <ul> <li>core/android/src/main/kotlin/dev/atick/core/android/utils/OneTimeEvent.kt</li> <li>core/ui/src/main/kotlin/dev/atick/core/ui/utils/StatefulComposable.kt</li> </ul>"},{"location":"troubleshooting/#multiple-loading-states-simultaneously","title":"Multiple Loading States Simultaneously","text":"<p>Problem: Multiple loading indicators showing at once or loading state stuck</p> <p>Solution:</p> <ol> <li>Use single <code>UiState&lt;T&gt;</code> wrapper per screen (not multiple):    <pre><code>// Wrong - multiple loading states\ndata class ScreenData(\n    val data1Loading: Boolean,\n    val data2Loading: Boolean\n)\n\n// Correct - single loading state in UiState wrapper\ndata class ScreenData(\n    val data1: List&lt;Item&gt;,\n    val data2: List&lt;Item&gt;\n)\n// UiState&lt;ScreenData&gt; has single loading field\n</code></pre></li> <li>If truly need multiple loading states, manage them explicitly:    <pre><code>data class ScreenData(\n    val items: List&lt;Item&gt; = emptyList(),\n    val isRefreshing: Boolean = false  // Separate from main loading\n)\n</code></pre></li> <li>Ensure <code>updateStateWith</code> completes properly (sets loading = false)</li> <li>Check for exception swallowing that prevents loading state reset</li> </ol> <p>References:</p> <ul> <li>core/ui/src/main/kotlin/dev/atick/core/ui/utils/UiState.kt</li> <li>State Management Guide</li> </ul>"},{"location":"troubleshooting/#updatestatewith-not-working","title":"updateStateWith Not Working","text":"<p>Problem: <code>updateStateWith</code> or <code>updateWith</code> doesn't update state or shows compilation error</p> <p>Solution:</p> <ol> <li>Ensure Kotlin context parameters feature is enabled (already configured):    <pre><code>// In build.gradle.kts\nfreeCompilerArgs += \"-Xcontext-receivers\"\n</code></pre></li> <li>Verify you're calling from ViewModel (context parameters require ViewModel scope):    <pre><code>@HiltViewModel\nclass MyViewModel @Inject constructor() : ViewModel() {\n    fun loadData() {\n        _uiState.updateStateWith {  // Has implicit access to viewModelScope\n            repository.getData()\n        }\n    }\n}\n</code></pre></li> <li>For <code>updateStateWith</code>, repository must return <code>Result&lt;T&gt;</code>:    <pre><code>// Repository\noverride suspend fun getData(): Result&lt;Data&gt; = suspendRunCatching { ... }\n</code></pre></li> <li>For <code>updateWith</code>, repository must return <code>Result&lt;Unit&gt;</code>:    <pre><code>// Repository\noverride suspend fun saveData(): Result&lt;Unit&gt; = suspendRunCatching { ... }\n</code></pre></li> <li>If still issues, use explicit <code>viewModelScope.launch</code> as fallback</li> </ol> <p>References:</p> <ul> <li>core/ui/src/main/kotlin/dev/atick/core/ui/utils/StateFlowExtensions.kt</li> <li>State Management Guide</li> </ul>"},{"location":"troubleshooting/#lifecycle-issues","title":"Lifecycle Issues","text":""},{"location":"troubleshooting/#compose-recomposition-not-triggering","title":"Compose Recomposition Not Triggering","text":"<p>Problem: UI doesn't update even though state has changed</p> <p>Solution:</p> <ol> <li>Ensure using <code>collectAsStateWithLifecycle()</code> instead of <code>collectAsState()</code>:    <pre><code>// Wrong - doesn't respect lifecycle\nval uiState by viewModel.uiState.collectAsState()\n\n// Correct - lifecycle-aware collection\nval uiState by viewModel.uiState.collectAsStateWithLifecycle()\n</code></pre></li> <li>Verify state is immutable data class with <code>copy()</code> for updates:    <pre><code>data class ScreenData(val name: String)\n\n// Updates must create new instance\n_uiState.updateState { copy(name = newName) }\n</code></pre></li> <li>Check if accidentally mutating state instead of replacing it</li> <li>Ensure <code>StateFlow</code> is being used, not <code>Flow</code></li> </ol> <p>References:</p> <ul> <li>core/ui/src/main/kotlin/dev/atick/core/ui/extensions/LifecycleExtensions.kt</li> <li>feature/home/src/main/kotlin/dev/atick/feature/home/ui/home/HomeScreen.kt:68</li> </ul>"},{"location":"troubleshooting/#viewmodel-outliving-composable","title":"ViewModel Outliving Composable","text":"<p>Problem: ViewModel continues executing after screen is destroyed</p> <p>Solution:</p> <ol> <li>Always use <code>viewModelScope</code> for coroutines in ViewModel:    <pre><code>fun loadData() {\n    viewModelScope.launch {\n        // Automatically cancelled when ViewModel is cleared\n    }\n}\n</code></pre></li> <li>For background operations, use <code>updateStateWith</code> (uses context parameters):    <pre><code>fun loadData() {\n    _uiState.updateStateWith {  // Auto-uses viewModelScope\n        repository.getData()\n    }\n}\n</code></pre></li> <li>Never launch coroutines with <code>GlobalScope</code></li> <li>Verify ViewModel is scoped to navigation destination, not activity</li> </ol> <p>References:</p> <ul> <li>core/ui/src/main/kotlin/dev/atick/core/ui/utils/StateFlowExtensions.kt</li> <li>State Management Guide</li> </ul>"},{"location":"troubleshooting/#snackbar-showing-after-navigation","title":"Snackbar Showing After Navigation","text":"<p>Problem: Error snackbar appears after user has navigated away</p> <p>Solution:</p> <ol> <li>This is expected behavior when using <code>StatefulComposable</code></li> <li>To prevent, handle navigation before error occurs:    <pre><code>fun saveAndNavigate() {\n    viewModelScope.launch {\n        repository.save().onSuccess {\n            navigator.navigate(NextScreen)  // Navigate before error can trigger\n        }.onFailure {\n            _uiState.updateState { copy(error = OneTimeEvent(it)) }\n        }\n    }\n}\n</code></pre></li> <li>Or consume errors before navigation:    <pre><code>// In composable\nLaunchedEffect(saveSuccess) {\n    if (saveSuccess) {\n        navigator.navigate(NextScreen)\n    }\n}\n</code></pre></li> <li>Consider using navigation with result pattern if needed</li> </ol> <p>References:</p> <ul> <li>core/ui/src/main/kotlin/dev/atick/core/ui/utils/StatefulComposable.kt</li> <li>core/android/src/main/kotlin/dev/atick/core/android/utils/OneTimeEvent.kt</li> </ul>"},{"location":"troubleshooting/#activity-recreated-on-configuration-change","title":"Activity Recreated on Configuration Change","text":"<p>Problem: App state lost during rotation or configuration change</p> <p>Solution:</p> <ol> <li>ViewModels survive configuration changes automatically</li> <li>Ensure state is in ViewModel, not composable:    <pre><code>// Wrong - state lost on rotation\n@Composable\nfun MyScreen() {\n    var name by remember { mutableStateOf(\"\") }\n}\n\n// Correct - state survives rotation\n@HiltViewModel\nclass MyViewModel @Inject constructor() : ViewModel() {\n    private val _uiState = MutableStateFlow(UiState(ScreenData()))\n    val uiState = _uiState.asStateFlow()\n}\n</code></pre></li> <li>For non-ViewModel state that should persist, use <code>rememberSaveable</code>:    <pre><code>var searchQuery by rememberSaveable { mutableStateOf(\"\") }\n</code></pre></li> <li>Complex objects need custom Saver implementation</li> </ol> <p>References:</p> <ul> <li>State Management Guide</li> <li>feature/home/src/main/kotlin/dev/atick/feature/home/ui/home/HomeViewModel.kt</li> </ul>"},{"location":"troubleshooting/#firebase-issues","title":"Firebase Issues","text":""},{"location":"troubleshooting/#authentication-not-working","title":"Authentication Not Working","text":""},{"location":"troubleshooting/#google-sign-in-fails","title":"Google Sign-In Fails","text":"<p>Error:</p> <pre><code>com.google.android.gms.common.api.ApiException: 10:\n</code></pre> <p>Solution:</p> <ol> <li>Add SHA-1 fingerprint to Firebase Console:    <pre><code># Get debug SHA-1\n./gradlew signingReport\n</code></pre></li> <li>Copy SHA-1 from output under \"Variant: debug, Config: debug\"</li> <li>Add to Firebase Console:<ul> <li>Project Settings \u2192 Your apps \u2192 SHA certificate fingerprints</li> </ul> </li> <li>Download new <code>google-services.json</code> and replace in <code>app/</code></li> <li>Rebuild and reinstall app</li> </ol> <p>References:</p> <ul> <li>Firebase Setup Guide</li> <li>firebase/auth/src/main/kotlin/dev/atick/firebase/auth/data/AuthDataSource.kt</li> </ul>"},{"location":"troubleshooting/#credential-manager-not-found","title":"Credential Manager Not Found","text":"<p>Error (Logcat):</p> <pre><code>CredentialManager is not available\n</code></pre> <p>Solution:</p> <ol> <li>Ensure device/emulator runs Android 14+ or has Google Play Services</li> <li>For devices below Android 14, add Jetpack library:    <pre><code>implementation(libs.androidx.credentials)\nimplementation(libs.credentials.play.services.auth)\n</code></pre>    (Already included in template)</li> <li>Verify Google Play Services is up-to-date on device</li> </ol> <p>References:</p> <ul> <li>firebase/auth/src/main/kotlin/dev/atick/firebase/auth/data/AuthDataSource.kt</li> <li>gradle/libs.versions.toml:160-162</li> </ul>"},{"location":"troubleshooting/#firestore-permission-denied","title":"Firestore Permission Denied","text":"<p>Error (Logcat):</p> <pre><code>PERMISSION_DENIED: Missing or insufficient permissions\n</code></pre> <p>Solution:</p> <ol> <li>Check Firestore Security Rules in Firebase Console</li> <li>For development, use permissive rules (\u26a0\ufe0f not for production):    <pre><code>rules_version = '2';\nservice cloud.firestore {\n  match /databases/{database}/documents {\n    match /{document=**} {\n      allow read, write: if request.auth != null;\n    }\n  }\n}\n</code></pre></li> <li>For production, implement proper security rules</li> <li>Ensure user is authenticated before accessing Firestore</li> </ol> <p>References:</p> <ul> <li>firebase/firestore/src/main/kotlin/dev/atick/firebase/firestore/data/FirebaseDataSource.kt</li> <li>Firebase Setup Guide</li> </ul>"},{"location":"troubleshooting/#firebase-analytics-not-tracking","title":"Firebase Analytics Not Tracking","text":"<p>Problem: Events not appearing in Firebase Analytics console</p> <p>Solution:</p> <ol> <li>Verify Firebase Analytics is initialized (happens automatically with Firebase SDK)</li> <li>Check if Analytics logging is enabled:    <pre><code>// In debug builds, enable verbose logging\nFirebase.analytics.setAnalyticsCollectionEnabled(true)\n</code></pre></li> <li>For debug testing, enable debug mode via ADB:    <pre><code># Enable Analytics debug mode\nadb shell setprop debug.firebase.analytics.app dev.atick.compose\n\n# View events in real-time\nadb logcat -s FA\n</code></pre></li> <li>Check if events are being logged correctly:    <pre><code>Firebase.analytics.logEvent(\"button_click\") {\n    param(\"button_name\", \"login\")\n    param(\"screen_name\", \"auth\")\n}\n</code></pre></li> <li>Events may take 24 hours to appear in console (use DebugView for immediate feedback)</li> <li>Verify <code>google-services.json</code> has correct Analytics project configuration</li> </ol> <p>References:</p> <ul> <li>firebase/analytics/src/main/kotlin/dev/atick/firebase/analytics/AnalyticsLogger.kt</li> <li>Firebase Setup Guide</li> </ul>"},{"location":"troubleshooting/#crashlytics-not-reporting","title":"Crashlytics Not Reporting","text":"<p>Problem: Crashes not appearing in Firebase Crashlytics console</p> <p>Solution:</p> <ol> <li>Ensure Crashlytics is enabled in <code>build.gradle.kts</code>:    <pre><code>buildTypes {\n    release {\n        firebaseCrashlytics {\n            mappingFileUploadEnabled = true\n        }\n    }\n}\n</code></pre></li> <li>Verify Firebase Crashlytics plugin is applied (happens via <code>FirebaseConventionPlugin</code>)</li> <li>Check if Crashlytics is initialized:    <pre><code>// Crashlytics initializes automatically with Firebase SDK\nFirebase.crashlytics.setCrashlyticsCollectionEnabled(true)\n</code></pre></li> <li>For testing, force a crash:    <pre><code>Firebase.crashlytics.log(\"Test crash triggered\")\nthrow RuntimeException(\"Test crash\")\n</code></pre></li> <li>Crashes may take a few minutes to appear in console</li> <li>For release builds, ensure ProGuard mapping files are uploaded:    <pre><code>./gradlew assembleRelease\n# Mapping files automatically uploaded if mappingFileUploadEnabled = true\n</code></pre></li> <li>Check logcat for Crashlytics errors:    <pre><code>adb logcat -s FirebaseCrashlytics\n</code></pre></li> </ol> <p>References:</p> <ul> <li>firebase/analytics/src/main/kotlin/dev/atick/firebase/analytics/AnalyticsLogger.kt</li> <li>build-logic/convention/src/main/kotlin/FirebaseConventionPlugin.kt</li> <li>Firebase Setup Guide</li> </ul>"},{"location":"troubleshooting/#firebase-initialization-failures","title":"Firebase Initialization Failures","text":"<p>Problem: Firebase not initializing properly, causing crashes or missing functionality</p> <p>Solution:</p> <ol> <li>See detailed Firebase initialization troubleshooting in Runtime Errors \u2192 Application Crashes on    Startup \u2192 Firebase Initialization Failure (line 195)</li> <li>Quick checklist:<ul> <li>\u2705 <code>google-services.json</code> exists in <code>app/</code> directory</li> <li>\u2705 Firebase plugin applied via convention plugin</li> <li>\u2705 Package name matches <code>applicationId</code></li> <li>\u2705 Firebase project properly configured in console</li> </ul> </li> <li>For emulator testing, use Firebase Emulator Suite:    <pre><code>firebase emulators:start\n</code></pre></li> <li>Check Firebase SDK versions in <code>gradle/libs.versions.toml</code>:    <pre><code>[versions]\nfirebase-bom = \"34.4.0\"\n</code></pre></li> </ol> <p>References:</p> <ul> <li>app/build.gradle.kts:30</li> <li>build-logic/convention/src/main/kotlin/FirebaseConventionPlugin.kt</li> <li>Firebase Setup Guide</li> <li>See also: Runtime Errors \u2192 Firebase Initialization Failure (line 195)</li> </ul>"},{"location":"troubleshooting/#compose-issues","title":"Compose Issues","text":""},{"location":"troubleshooting/#recomposition-issues","title":"Recomposition Issues","text":""},{"location":"troubleshooting/#composable-not-recomposing","title":"Composable Not Recomposing","text":"<p>Problem: UI doesn't update when state changes</p> <p>Solution:</p> <ol> <li>Ensure using <code>collectAsStateWithLifecycle()</code> for Flow collection:    <pre><code>// Wrong - doesn't observe lifecycle\nval uiState by viewModel.uiState.collectAsState()\n\n// Correct - lifecycle-aware\nval uiState by viewModel.uiState.collectAsStateWithLifecycle()\n</code></pre></li> <li>Verify state is immutable and creates new instances:    <pre><code>// Wrong - mutating state\ndata.items.add(newItem)\n\n// Correct - creating new instance\n_uiState.updateState { copy(items = items + newItem) }\n</code></pre></li> <li>Check if using <code>remember</code> correctly:    <pre><code>// Wrong - doesn't recompose on state change\nval items = remember { mutableStateListOf&lt;Item&gt;() }\n\n// Correct - observes ViewModel state\nval uiState by viewModel.uiState.collectAsStateWithLifecycle()\n</code></pre></li> <li>For derived state, use <code>derivedStateOf</code>:    <pre><code>val filteredItems by remember {\n    derivedStateOf {\n        items.filter { it.isActive }\n    }\n}\n</code></pre></li> </ol> <p>References:</p> <ul> <li>core/ui/src/main/kotlin/dev/atick/core/ui/extensions/LifecycleExtensions.kt</li> <li>State Management Guide</li> <li>See also: Lifecycle Issues \u2192 Compose Recomposition Not Triggering (line 613)</li> </ul>"},{"location":"troubleshooting/#excessive-recomposition","title":"Excessive Recomposition","text":"<p>Problem: UI stutters or battery drains due to too frequent recomposition</p> <p>Solution:</p> <ol> <li>Use stable parameters in composables:    <pre><code>// Wrong - lambda recreated on every recomposition\nButton(onClick = { viewModel.loadData() })\n\n// Correct - stable reference\nButton(onClick = viewModel::loadData)\n</code></pre></li> <li>Mark data classes as stable when appropriate:    <pre><code>@Immutable\ndata class ScreenData(val items: List&lt;Item&gt;)\n</code></pre></li> <li>Use <code>key</code> parameter in lists to prevent unnecessary recomposition:    <pre><code>LazyColumn {\n    items(items = jetpacks, key = { it.id }) { jetpack -&gt;\n        JetpackCard(jetpack)\n    }\n}\n</code></pre></li> <li>Use <code>derivedStateOf</code> for computed values:    <pre><code>val filteredItems by remember {\n    derivedStateOf {\n        items.filter { it.isActive }\n    }\n}\n</code></pre></li> <li>Avoid reading state that doesn't affect UI:    <pre><code>// Wrong - unnecessary recomposition on timestamp change\nText(\"Updated: ${state.lastUpdateTimestamp}\")\n\n// Better - only show meaningful state\nText(\"Items: ${state.items.size}\")\n</code></pre></li> <li>Use Layout Inspector to identify recomposition hotspots:<ul> <li>Android Studio \u2192 View \u2192 Tool Windows \u2192 Layout Inspector</li> <li>Enable \"Show Recomposition Counts\"</li> </ul> </li> </ol> <p>References:</p> <ul> <li>Performance Guide</li> <li>See also: Memory Issues \u2192 Compose Recomposing Too Often (line 1295)</li> </ul>"},{"location":"troubleshooting/#compose-preview-issues","title":"Compose Preview Issues","text":""},{"location":"troubleshooting/#previews-not-rendering","title":"Previews Not Rendering","text":"<p>Problem: Compose previews don't render or show errors</p> <p>Solution:</p> <ol> <li>Ensure using Android Studio Hedgehog (2023.1.1) or newer</li> <li>Enable Compose Preview features:<ul> <li>Settings \u2192 Experimental \u2192 Compose</li> <li>Enable \"Live Edit of Literals\"</li> </ul> </li> <li>Verify preview annotations are correct:    <pre><code>@PreviewDevices\n@PreviewThemes\n@Composable\nprivate fun HomeScreenPreview() {\n    JetpackTheme {\n        HomeScreen(\n            screenData = HomeScreenData(),\n            onAction = {}\n        )\n    }\n}\n</code></pre></li> <li>Ensure preview composables are private (not public)</li> <li>Refresh preview (toolbar icon or Ctrl+Shift+F5 / Cmd+Shift+F5)</li> <li>If still failing, try:<ul> <li>Build \u2192 Refresh All Previews</li> <li>File \u2192 Invalidate Caches / Restart</li> <li>Clean and rebuild project</li> </ul> </li> </ol> <p>References:</p> <ul> <li>core/ui/src/main/kotlin/dev/atick/core/ui/utils/PreviewDevices.kt</li> <li>core/ui/src/main/kotlin/dev/atick/core/ui/utils/PreviewThemes.kt</li> <li>See also: Development Environment Issues \u2192 Compose Preview Not Working (line 1020)</li> </ul>"},{"location":"troubleshooting/#preview-shows-wrong-theme","title":"Preview Shows Wrong Theme","text":"<p>Problem: Preview doesn't reflect light/dark theme correctly</p> <p>Solution:</p> <ol> <li>Use <code>@PreviewThemes</code> annotation (includes both light and dark):    <pre><code>@PreviewThemes\n@Composable\nprivate fun MyScreenPreview() {\n    JetpackTheme {  // Theme wrapper required\n        MyScreen(...)\n    }\n}\n</code></pre></li> <li>For manual theme control, use <code>uiMode</code> parameter:    <pre><code>@Preview(uiMode = Configuration.UI_MODE_NIGHT_YES)\n@Composable\nprivate fun MyScreenDarkPreview() {\n    JetpackTheme {\n        MyScreen(...)\n    }\n}\n</code></pre></li> <li>Always wrap preview content in <code>JetpackTheme { }</code></li> <li>Check if using correct <code>@PreviewThemes</code> annotation:    <pre><code>// Correct - custom multi-preview annotation\n@PreviewThemes  // Defined in core/ui\n\n// Not - standard Preview\n@Preview(uiMode = Configuration.UI_MODE_NIGHT_YES)\n</code></pre></li> </ol> <p>References:</p> <ul> <li>core/ui/src/main/kotlin/dev/atick/core/ui/utils/PreviewThemes.kt</li> <li>core/ui/src/main/kotlin/dev/atick/core/ui/theme/Theme.kt</li> </ul>"},{"location":"troubleshooting/#preview-shows-hardcoded-data-instead-of-real-state","title":"Preview Shows Hardcoded Data Instead of Real State","text":"<p>Problem: Preview shows placeholder data, not actual ViewModel state</p> <p>Solution:</p> <ol> <li>This is expected behavior - previews should use fake data</li> <li>For preview data, create sample data objects:    <pre><code>@PreviewDevices\n@PreviewThemes\n@Composable\nprivate fun HomeScreenPreview() {\n    JetpackTheme {\n        HomeScreen(\n            screenData = HomeScreenData(\n                items = listOf(\n                    Item(id = \"1\", name = \"Preview Item 1\"),\n                    Item(id = \"2\", name = \"Preview Item 2\")\n                )\n            ),\n            onAction = {}  // No-op for preview\n        )\n    }\n}\n</code></pre></li> <li>For complex preview data, create preview data factories:    <pre><code>object PreviewData {\n    val sampleItems = listOf(\n        Item(id = \"1\", name = \"Item 1\"),\n        Item(id = \"2\", name = \"Item 2\")\n    )\n}\n\n@PreviewThemes\n@Composable\nprivate fun HomeScreenPreview() {\n    JetpackTheme {\n        HomeScreen(\n            screenData = HomeScreenData(items = PreviewData.sampleItems),\n            onAction = {}\n        )\n    }\n}\n</code></pre></li> <li>Never access ViewModel in preview composables</li> <li>This is why Screen composables are separated from Route composables</li> </ol> <p>References:</p> <ul> <li>State Management Guide</li> <li>feature/home/src/main/kotlin/dev/atick/feature/home/ui/home/HomeScreen.kt</li> </ul>"},{"location":"troubleshooting/#compose-performance-issues","title":"Compose Performance Issues","text":""},{"location":"troubleshooting/#lazylist-scrolling-lag","title":"LazyList Scrolling Lag","text":"<p>Problem: Scrolling through lists is janky or slow</p> <p>Solution:</p> <ol> <li>Always provide <code>key</code> parameter:    <pre><code>LazyColumn {\n    items(items = jetpacks, key = { it.id }) { jetpack -&gt;\n        JetpackCard(jetpack)\n    }\n}\n</code></pre></li> <li>Use <code>contentType</code> for heterogeneous lists:    <pre><code>items(\n    items = items,\n    key = { it.id },\n    contentType = { it.type }  // Helps Compose reuse compositions\n) { item -&gt;\n    when (item.type) {\n        \"header\" -&gt; HeaderItem(item)\n        \"content\" -&gt; ContentItem(item)\n    }\n}\n</code></pre></li> <li>Avoid heavy computations in item composables:    <pre><code>// Wrong - computation in composable\nJetpackCard(\n    jetpack = jetpack,\n    formattedDate = formatDate(jetpack.timestamp)  // Recomputed on every scroll\n)\n\n// Correct - computation in data layer\ndata class Jetpack(\n    val id: String,\n    val timestamp: Long,\n    val formattedDate: String  // Pre-computed\n)\n</code></pre></li> <li>Use <code>Modifier.drawWithCache</code> for custom drawing:    <pre><code>Modifier.drawWithCache {\n    val path = Path()  // Cached between recompositions\n    onDrawBehind { drawPath(path, color) }\n}\n</code></pre></li> <li>Check for image loading issues (see Memory Issues \u2192 Image Loading)</li> </ol> <p>References:</p> <ul> <li>feature/home/src/main/kotlin/dev/atick/feature/home/ui/home/HomeScreen.kt:104</li> <li>Performance Guide</li> <li>See also: Memory Issues \u2192 Large List Performance Issues (line 1250)</li> </ul>"},{"location":"troubleshooting/#compose-ui-jank-or-frame-drops","title":"Compose UI Jank or Frame Drops","text":"<p>Problem: UI animation stutters or drops frames</p> <p>Solution:</p> <ol> <li>Use <code>animateFloatAsState</code> for smooth animations:    <pre><code>val scale by animateFloatAsState(\n    targetValue = if (isPressed) 0.95f else 1f,\n    animationSpec = spring(dampingRatio = Spring.DampingRatioMediumBouncy)\n)\n</code></pre></li> <li>Avoid heavy operations during composition:    <pre><code>// Wrong - heavy operation in composition\nval result = heavyComputation(data)\n\n// Correct - use LaunchedEffect\nvar result by remember { mutableStateOf&lt;Result?&gt;(null) }\nLaunchedEffect(data) {\n    result = withContext(Dispatchers.Default) {\n        heavyComputation(data)\n    }\n}\n</code></pre></li> <li>Profile with Android Studio Profiler:<ul> <li>View \u2192 Tool Windows \u2192 Profiler</li> <li>Check CPU usage during jank</li> <li>Identify slow composables</li> </ul> </li> <li>Use Layout Inspector to check composition counts:<ul> <li>Enable \"Show Recomposition Counts\"</li> <li>Identify composables recomposing too frequently</li> </ul> </li> <li>Consider using <code>Modifier.graphicsLayer</code> for transform animations:    <pre><code>Modifier.graphicsLayer {\n    scaleX = scale\n    scaleY = scale\n}\n</code></pre></li> </ol> <p>References:</p> <ul> <li>Performance Guide</li> </ul>"},{"location":"troubleshooting/#compose-state-issues","title":"Compose State Issues","text":""},{"location":"troubleshooting/#remember-state-lost-on-recomposition","title":"remember State Lost on Recomposition","text":"<p>Problem: State stored with <code>remember</code> resets unexpectedly</p> <p>Solution:</p> <ol> <li>For configuration changes (rotation), use <code>rememberSaveable</code>:    <pre><code>// Wrong - lost on rotation\nvar searchQuery by remember { mutableStateOf(\"\") }\n\n// Correct - survives rotation\nvar searchQuery by rememberSaveable { mutableStateOf(\"\") }\n</code></pre></li> <li>For complex objects, provide custom Saver:    <pre><code>val customSaver = Saver&lt;CustomState, Bundle&gt;(\n    save = { state -&gt; Bundle().apply { putString(\"key\", state.value) } },\n    restore = { bundle -&gt; CustomState(bundle.getString(\"key\") ?: \"\") }\n)\n\nval state by rememberSaveable(stateSaver = customSaver) {\n    mutableStateOf(CustomState())\n}\n</code></pre></li> <li>For screen-level state, use ViewModel instead:    <pre><code>@HiltViewModel\nclass MyViewModel @Inject constructor() : ViewModel() {\n    private val _uiState = MutableStateFlow(UiState(ScreenData()))\n    val uiState = _uiState.asStateFlow()\n}\n</code></pre></li> </ol> <p>References:</p> <ul> <li>State Management Guide</li> </ul>"},{"location":"troubleshooting/#launchedeffect-runs-multiple-times","title":"LaunchedEffect Runs Multiple Times","text":"<p>Problem: <code>LaunchedEffect</code> executes more than expected</p> <p>Solution:</p> <ol> <li>Check key parameters - effect relaunches when keys change:    <pre><code>// Runs on every recomposition (Unit key never changes after first run)\nLaunchedEffect(Unit) {\n    // Runs once\n}\n\n// Runs every time userId changes\nLaunchedEffect(userId) {\n    loadUserData(userId)\n}\n</code></pre></li> <li>For one-time effects, use <code>Unit</code> or <code>true</code> as key:    <pre><code>LaunchedEffect(Unit) {\n    // Runs only once\n    analytics.logScreenView(\"home\")\n}\n</code></pre></li> <li>For multiple dependencies, use multiple keys:    <pre><code>LaunchedEffect(userId, categoryId) {\n    // Runs when either userId or categoryId changes\n    loadData(userId, categoryId)\n}\n</code></pre></li> <li>Avoid using mutable state as keys unless intended:    <pre><code>// Wrong - relaunches on every state change\nLaunchedEffect(uiState) {\n    // This is almost never what you want\n}\n\n// Correct - specific property\nLaunchedEffect(uiState.userId) {\n    loadUserData(uiState.userId)\n}\n</code></pre></li> </ol> <p>References:</p> <ul> <li>State Management Guide</li> </ul>"},{"location":"troubleshooting/#code-quality-issues","title":"Code Quality Issues","text":""},{"location":"troubleshooting/#spotless-formatting-errors","title":"Spotless Formatting Errors","text":""},{"location":"troubleshooting/#copyright-header-missing","title":"Copyright Header Missing","text":"<p>Error:</p> <pre><code>Step 'licenseHeaderFile' found problem in 'src/main/kotlin/MyFile.kt':\n  License header mismatch\n</code></pre> <p>Solution:</p> <ol> <li>Run Spotless Apply to auto-fix:    <pre><code>./gradlew spotlessApply --init-script gradle/init.gradle.kts --no-configuration-cache\n</code></pre></li> <li>Manually add copyright header from <code>spotless/copyright.kt</code>:    <pre><code>/*\n * Copyright 2023 Atick Faisal\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * ...\n */\n</code></pre></li> <li>For custom copyright, modify files in <code>spotless/</code> directory</li> </ol> <p>References:</p> <ul> <li>gradle/init.gradle.kts:47</li> <li>spotless/copyright.kt</li> <li>Spotless Setup Guide</li> </ul>"},{"location":"troubleshooting/#ktlint-violations","title":"Ktlint Violations","text":"<p>Error:</p> <pre><code>Step 'ktlint' found problem in 'MyFile.kt':\n  Exceeded max line length (120)\n</code></pre> <p>Solution:</p> <ol> <li>Run Spotless Apply to auto-fix most issues:    <pre><code>./gradlew spotlessApply --init-script gradle/init.gradle.kts --no-configuration-cache\n</code></pre></li> <li>For line length violations, break lines appropriately:    <pre><code>// Too long\nfun myFunction(param1: String, param2: String, param3: String, param4: String): Result&lt;Data&gt;\n\n// Fixed\nfun myFunction(\n    param1: String,\n    param2: String,\n    param3: String,\n    param4: String\n): Result&lt;Data&gt;\n</code></pre></li> <li>For Compose-specific violations, follow custom rules from <code>io.nlopez.compose.rules:ktlint</code></li> </ol> <p>References:</p> <ul> <li>gradle/init.gradle.kts:38-46</li> <li>.editorconfig</li> <li>Spotless Setup Guide</li> </ul>"},{"location":"troubleshooting/#ci-build-fails-on-spotless-check","title":"CI Build Fails on Spotless Check","text":"<p>Error (GitHub Actions):</p> <pre><code>Task :spotlessCheck FAILED\n</code></pre> <p>Solution:</p> <ol> <li>Run Spotless Check locally before pushing:    <pre><code>./gradlew spotlessCheck --init-script gradle/init.gradle.kts --no-configuration-cache\n</code></pre></li> <li>Fix issues with Spotless Apply:    <pre><code>./gradlew spotlessApply --init-script gradle/init.gradle.kts --no-configuration-cache\n</code></pre></li> <li>Commit and push fixes</li> <li>Best Practice: Set up pre-commit hook to run <code>spotlessApply</code></li> </ol> <p>References:</p> <ul> <li>.github/workflows/ci.yml:35-36</li> <li>Spotless Setup Guide</li> </ul>"},{"location":"troubleshooting/#development-environment-issues","title":"Development Environment Issues","text":""},{"location":"troubleshooting/#android-studio-setup-problems","title":"Android Studio Setup Problems","text":""},{"location":"troubleshooting/#compose-preview-not-working","title":"Compose Preview Not Working","text":"<p>Problem: Compose previews don't render or show errors</p> <p>Solution:</p> <ol> <li>Ensure using Android Studio Hedgehog or newer</li> <li>Enable Compose Preview:<ul> <li>Settings \u2192 Experimental \u2192 Compose</li> <li>Enable \"Live Edit of Literals\"</li> </ul> </li> <li>Verify preview annotations are correct:    <pre><code>@PreviewDevices\n@PreviewThemes\n@Composable\nprivate fun MyScreenPreview() {\n    JetpackTheme {\n        MyScreen(...)\n    }\n}\n</code></pre></li> <li>Refresh preview (toolbar icon or Ctrl+Shift+F5)</li> <li>If still failing, invalidate caches and restart</li> </ol> <p>References:</p> <ul> <li>core/ui/src/main/kotlin/dev/atick/core/ui/utils/PreviewDevices.kt</li> <li>core/ui/src/main/kotlin/dev/atick/core/ui/utils/PreviewThemes.kt</li> </ul>"},{"location":"troubleshooting/#gradle-build-too-slow","title":"Gradle Build Too Slow","text":"<p>Problem: Gradle builds take too long</p> <p>Solution:</p> <ol> <li>Verify Gradle daemon settings in <code>gradle.properties</code>:    <pre><code>org.gradle.jvmargs=-Xmx8g -XX:+HeapDumpOnOutOfMemoryError\norg.gradle.parallel=true\norg.gradle.caching=true\norg.gradle.configuration-cache=true\n</code></pre></li> <li>Enable build cache (already configured in template)</li> <li>Use <code>--no-configuration-cache</code> flag only when necessary</li> <li>Close unnecessary background processes</li> <li>Consider increasing heap size in <code>gradle.properties</code> if you have more RAM</li> </ol> <p>References:</p> <ul> <li>gradle.properties:10-28</li> </ul>"},{"location":"troubleshooting/#kspkapt-takes-too-long","title":"KSP/Kapt Takes Too Long","text":"<p>Problem: Annotation processing slow during builds</p> <p>Solution:</p> <ol> <li>Use KSP instead of Kapt (template already uses KSP for Hilt and Room)</li> <li>Verify KSP is being used:    <pre><code>dependencies {\n    \"ksp\"(libs.dagger.hilt.compiler)  // Not \"kapt\"\n}\n</code></pre></li> <li>Increase Gradle heap size if needed</li> <li>Close other IDEs/applications consuming memory</li> </ol> <p>References:</p> <ul> <li>build-logic/convention/src/main/kotlin/DaggerHiltConventionPlugin.kt:35</li> </ul>"},{"location":"troubleshooting/#emulator-issues","title":"Emulator Issues","text":""},{"location":"troubleshooting/#app-not-installing-on-emulator","title":"App Not Installing on Emulator","text":"<p>Problem: Installation fails or emulator not detected</p> <p>Solution:</p> <ol> <li>Verify emulator is running:    <pre><code>adb devices\n</code></pre></li> <li>If no devices listed, restart emulator</li> <li>If multiple devices, specify target:    <pre><code>./gradlew installDebug -Pandroid.device=emulator-5554\n</code></pre></li> <li>Clear app data and reinstall:    <pre><code>adb uninstall dev.atick.compose\n./gradlew installDebug\n</code></pre></li> <li>Check min SDK version matches emulator API level (minSdk: 24)</li> </ol> <p>References:</p> <ul> <li>gradle/libs.versions.toml:68</li> </ul>"},{"location":"troubleshooting/#build-configuration-issues","title":"Build Configuration Issues","text":""},{"location":"troubleshooting/#release-build-problems","title":"Release Build Problems","text":""},{"location":"troubleshooting/#keystore-not-found","title":"Keystore Not Found","text":"<p>Error:</p> <pre><code>keystore.properties file not found. Using debug key.\n</code></pre> <p>Solution:</p> <ol> <li>This is expected for debug builds and template usage</li> <li>For release builds, create <code>keystore.properties</code> in project root:    <pre><code>storePassword=your-store-password\nkeyPassword=your-key-password\nkeyAlias=your-key-alias\nstoreFile=your-keystore-file.jks\n</code></pre></li> <li>Generate keystore if needed:<ul> <li>Android Studio: Build \u2192 Generate Signed Bundle/APK</li> <li>Or use command line:   <pre><code>keytool -genkey -v -keystore release-keystore.jks \\\n  -keyalg RSA -keysize 2048 -validity 10000 -alias my-alias\n</code></pre></li> </ul> </li> <li>Place keystore in <code>app/</code> directory</li> </ol> <p>References:</p> <ul> <li>app/build.gradle.kts:25, 84-92</li> <li>Getting Started Guide</li> </ul>"},{"location":"troubleshooting/#proguardr8-errors","title":"ProGuard/R8 Errors","text":"<p>Error:</p> <pre><code>Missing class com.google.firebase.FirebaseApp\n</code></pre> <p>Solution:</p> <ol> <li>Add ProGuard rules in <code>app/proguard-rules.pro</code>:    <pre><code>-keep class com.google.firebase.** { *; }\n-keep class com.google.android.gms.** { *; }\n</code></pre></li> <li>For serialization issues, add:    <pre><code>-keepattributes *Annotation*, InnerClasses\n-dontnote kotlinx.serialization.AnnotationsKt\n</code></pre></li> <li>Test release builds thoroughly</li> <li>Check R8 full mode documentation if using</li> </ol> <p>References:</p> <ul> <li>app/proguard-rules.pro</li> <li>app/build.gradle.kts:94-97</li> </ul>"},{"location":"troubleshooting/#data-layer-issues","title":"Data Layer Issues","text":""},{"location":"troubleshooting/#repository-errors-not-handled","title":"Repository Errors Not Handled","text":"<p>Problem: Repository errors crash app instead of showing in UI</p> <p>Solution:</p> <ol> <li>Use <code>suspendRunCatching</code> in repositories:    <pre><code>override suspend fun getData(): Result&lt;Data&gt; = suspendRunCatching {\n    networkDataSource.getData()\n}\n</code></pre></li> <li>Use <code>updateStateWith</code> or <code>updateWith</code> in ViewModels:    <pre><code>fun loadData() {\n    _uiState.updateStateWith {\n        repository.getData()\n    }\n}\n</code></pre></li> <li><code>StatefulComposable</code> will automatically show errors via snackbar</li> </ol> <p>References:</p> <ul> <li>core/android/src/main/kotlin/dev/atick/core/android/utils/CoroutineUtils.kt</li> <li>State Management Guide</li> <li>Data Flow Guide</li> </ul>"},{"location":"troubleshooting/#room-database-migration-issues","title":"Room Database Migration Issues","text":"<p>Error (Logcat):</p> <pre><code>java.lang.IllegalStateException: Room cannot verify the data integrity\n</code></pre> <p>Solution:</p> <ol> <li>For development, use destructive migration:    <pre><code>Room.databaseBuilder(context, AppDatabase::class.java, \"database-name\")\n    .fallbackToDestructiveMigration()  // Development only\n    .build()\n</code></pre></li> <li>For production, implement proper migrations</li> <li>Bump database version number when schema changes</li> <li>Clear app data and reinstall for testing</li> </ol> <p>References:</p> <ul> <li>core/room/src/main/kotlin/dev/atick/core/room/di/DatabaseModule.kt</li> </ul>"},{"location":"troubleshooting/#workmanager-sync-issues","title":"WorkManager Sync Issues","text":""},{"location":"troubleshooting/#background-sync-not-running","title":"Background Sync Not Running","text":"<p>Problem: Sync operations don't execute</p> <p>Solution:</p> <ol> <li>Verify WorkManager is initialized in <code>Application.onCreate()</code>:    <pre><code>@HiltAndroidApp\nclass JetpackApplication : Application() {\n    override fun onCreate() {\n        super.onCreate()\n        Sync.initialize(context = this)\n    }\n}\n</code></pre></li> <li>Check WorkManager constraints are satisfied (network, battery, etc.)</li> <li>Verify worker is using <code>@HiltWorker</code> and <code>@AssistedInject</code>:    <pre><code>@HiltWorker\nclass SyncWorker @AssistedInject constructor(\n    @Assisted appContext: Context,\n    @Assisted workerParams: WorkerParameters,\n    ...\n) : CoroutineWorker(appContext, workerParams)\n</code></pre></li> <li>Check logs for WorkManager errors:    <pre><code>adb logcat -s WM-WorkerWrapper\n</code></pre></li> </ol> <p>References:</p> <ul> <li>sync/src/main/kotlin/dev/atick/sync/utils/Sync.kt</li> <li>sync/src/main/kotlin/dev/atick/sync/workers/SyncWorker.kt</li> <li>app/src/main/kotlin/dev/atick/compose/JetpackApplication.kt</li> </ul>"},{"location":"troubleshooting/#memory-issues","title":"Memory Issues","text":""},{"location":"troubleshooting/#leakcanary-detecting-leaks","title":"LeakCanary Detecting Leaks","text":"<p>Problem: LeakCanary reports memory leaks</p> <p>Solution:</p> <ol> <li>Check ViewModel lifecycle - ensure not storing Activity/Context</li> <li>Verify Flow collection uses lifecycle-aware collectors:    <pre><code>val uiState by viewModel.uiState.collectAsStateWithLifecycle()\n</code></pre></li> <li>Cancel coroutines properly in repositories</li> <li>Don't hold references to composables in ViewModel</li> <li>For known library leaks, suppress in LeakCanary config</li> <li>Disable LeakCanary in release builds (already configured)</li> </ol> <p>References:</p> <ul> <li>app/build.gradle.kts:138</li> <li>core/ui/src/main/kotlin/dev/atick/core/ui/extensions/LifecycleExtensions.kt</li> </ul>"},{"location":"troubleshooting/#app-running-out-of-memory","title":"App Running Out of Memory","text":"<p>Error (Logcat):</p> <pre><code>java.lang.OutOfMemoryError: Failed to allocate\n</code></pre> <p>Solution:</p> <ol> <li>Check for image loading issues - ensure using Coil properly:    <pre><code>// Use DynamicAsyncImage component (handles memory efficiently)\nDynamicAsyncImage(\n    imageUrl = imageUrl,\n    contentDescription = \"Image\",\n    modifier = Modifier.size(200.dp)\n)\n</code></pre></li> <li>Verify Coil configuration uses memory cache (already configured):    <pre><code>// In CoilModule.kt\n.memoryCache {\n    MemoryCache.Builder(context)\n        .maxSizePercent(0.25)  // Use 25% of app memory\n        .build()\n}\n</code></pre></li> <li>For large lists, ensure using <code>LazyColumn</code>/<code>LazyRow</code> (not regular Column/Row)</li> <li>Check if loading too many high-resolution images simultaneously</li> <li>Limit image dimensions:    <pre><code>AsyncImage(\n    model = ImageRequest.Builder(LocalContext.current)\n        .data(imageUrl)\n        .size(800)  // Limit dimensions\n        .build()\n)\n</code></pre></li> </ol> <p>References:</p> <ul> <li>core/network/src/main/kotlin/dev/atick/core/network/di/CoilModule.kt</li> <li>core/ui/src/main/kotlin/dev/atick/core/ui/image/DynamicAsyncImage.kt</li> <li>Performance Guide</li> </ul>"},{"location":"troubleshooting/#large-list-performance-issues","title":"Large List Performance Issues","text":"<p>Problem: App lags or crashes when scrolling through large lists</p> <p>Solution:</p> <ol> <li>Always use <code>LazyColumn</code>/<code>LazyRow</code> for lists (not Column/Row):    <pre><code>// Wrong - loads all items at once\nColumn {\n    items.forEach { item -&gt;\n        ItemCard(item)\n    }\n}\n\n// Correct - lazy loading\nLazyColumn {\n    items(items) { item -&gt;\n        ItemCard(item)\n    }\n}\n</code></pre></li> <li>Provide <code>key</code> parameter for stable list items:    <pre><code>LazyColumn {\n    items(items = jetpacks, key = { it.id }) { jetpack -&gt;\n        JetpackCard(jetpack)\n    }\n}\n</code></pre></li> <li>Use <code>contentType</code> for heterogeneous lists:    <pre><code>items(items, key = { it.id }, contentType = { it.type }) { item -&gt;\n    // Compose can reuse layouts for same content type\n}\n</code></pre></li> <li>Avoid heavy computations in list items</li> <li>Consider using <code>StaggeredGrid</code> for varying item sizes</li> </ol> <p>References:</p> <ul> <li>feature/home/src/main/kotlin/dev/atick/feature/home/ui/home/HomeScreen.kt:104</li> <li>Performance Guide</li> </ul>"},{"location":"troubleshooting/#compose-recomposing-too-often","title":"Compose Recomposing Too Often","text":"<p>Problem: UI stutters or battery drains due to excessive recomposition</p> <p>Solution:</p> <ol> <li>Use <code>derivedStateOf</code> for computed state:    <pre><code>val filteredItems by remember {\n    derivedStateOf {\n        items.filter { it.isActive }\n    }\n}\n</code></pre></li> <li>Pass stable parameters to composables:    <pre><code>// Wrong - lambda creates new instance every recomposition\nButton(onClick = { viewModel.loadData() })\n\n// Correct - stable reference\nButton(onClick = viewModel::loadData)\n</code></pre></li> <li>Mark data classes as <code>@Stable</code> or <code>@Immutable</code> when appropriate:    <pre><code>@Immutable\ndata class ScreenData(val items: List&lt;Item&gt;)\n</code></pre></li> <li>Use <code>key</code> parameter in loops to prevent unnecessary recomposition</li> <li>Avoid reading state in composition that doesn't affect UI</li> </ol> <p>References:</p> <ul> <li>Performance Guide</li> <li>State Management Guide</li> </ul>"},{"location":"troubleshooting/#testing-issues","title":"Testing Issues","text":""},{"location":"troubleshooting/#cannot-run-tests","title":"Cannot Run Tests","text":"<p>Problem: Test infrastructure not yet implemented</p> <p>Solution:</p> <ol> <li>Testing infrastructure is marked as Upcoming \ud83d\udea7 in this template</li> <li>For now, manual testing is required</li> <li>Future updates will include:<ul> <li>Unit test setup for ViewModels</li> <li>Repository tests</li> <li>UI tests with Compose Test</li> </ul> </li> <li>You can add your own testing framework following standard Android practices</li> </ol> <p>References:</p> <ul> <li>docs/guide.md:343-351</li> </ul>"},{"location":"troubleshooting/#getting-additional-help","title":"Getting Additional Help","text":"<p>If you encounter issues not covered in this guide:</p> <ol> <li> <p>Check Related Guides:</p> <ul> <li>Getting Started - Setup and initial configuration</li> <li>Architecture Overview - Understanding the app structure</li> <li>State Management - State-related issues</li> <li>Navigation Deep Dive - Navigation problems</li> <li>Dependency Injection - DI issues</li> <li>Firebase Setup - Firebase-specific problems</li> <li>Spotless Setup - Code formatting issues</li> </ul> </li> <li> <p>Search GitHub Issues:</p> <ul> <li>Check existing   issues: GitHub Issues</li> <li>Search closed issues for solutions</li> </ul> </li> <li> <p>Enable Debug Logging:</p> <ul> <li>Timber is included in this template</li> <li>Add logging to identify issues:   <pre><code>Timber.d(\"Debug message: $variable\")\nTimber.e(throwable, \"Error occurred\")\n</code></pre></li> </ul> </li> <li> <p>Clean Build:</p> <ul> <li>Often resolves mysterious build issues:   <pre><code>./gradlew clean\n./gradlew build --refresh-dependencies\n</code></pre></li> </ul> </li> <li> <p>Invalidate Caches:</p> <ul> <li>Android Studio: File \u2192 Invalidate Caches / Restart</li> </ul> </li> <li> <p>Report a Bug:</p> <ul> <li>If you've found a genuine issue with the template, please report it on GitHub with:<ul> <li>Android Studio version</li> <li>Gradle version</li> <li>Error logs</li> <li>Steps to reproduce</li> </ul> </li> </ul> </li> </ol>"}]}